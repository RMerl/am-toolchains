This is libc.info, produced by makeinfo version 5.2 from libc.texinfo.

This file documents the GNU C Library.

   This is ‘The GNU C Library Reference Manual’, for version 2.30
(Buildroot).

   Copyright © 1993–2019 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being “Free Software Needs Free Documentation” and
“GNU Lesser General Public License”, the Front-Cover texts being “A GNU
Manual”, and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License".

   (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom.”
INFO-DIR-SECTION Software libraries
START-INFO-DIR-ENTRY
* Libc: (libc).                 C library.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION GNU C library functions and macros
START-INFO-DIR-ENTRY
* ALTWERASE: (libc)Local Modes.
* ARGP_ERR_UNKNOWN: (libc)Argp Parser Functions.
* ARG_MAX: (libc)General Limits.
* BC_BASE_MAX: (libc)Utility Limits.
* BC_DIM_MAX: (libc)Utility Limits.
* BC_SCALE_MAX: (libc)Utility Limits.
* BC_STRING_MAX: (libc)Utility Limits.
* BRKINT: (libc)Input Modes.
* BUFSIZ: (libc)Controlling Buffering.
* CCTS_OFLOW: (libc)Control Modes.
* CHAR_BIT: (libc)Width of Type.
* CHILD_MAX: (libc)General Limits.
* CIGNORE: (libc)Control Modes.
* CLK_TCK: (libc)Processor Time.
* CLOCAL: (libc)Control Modes.
* CLOCKS_PER_SEC: (libc)CPU Time.
* COLL_WEIGHTS_MAX: (libc)Utility Limits.
* CPU_CLR: (libc)CPU Affinity.
* CPU_ISSET: (libc)CPU Affinity.
* CPU_SET: (libc)CPU Affinity.
* CPU_SETSIZE: (libc)CPU Affinity.
* CPU_ZERO: (libc)CPU Affinity.
* CREAD: (libc)Control Modes.
* CRTS_IFLOW: (libc)Control Modes.
* CS5: (libc)Control Modes.
* CS6: (libc)Control Modes.
* CS7: (libc)Control Modes.
* CS8: (libc)Control Modes.
* CSIZE: (libc)Control Modes.
* CSTOPB: (libc)Control Modes.
* DTTOIF: (libc)Directory Entries.
* E2BIG: (libc)Error Codes.
* EACCES: (libc)Error Codes.
* EADDRINUSE: (libc)Error Codes.
* EADDRNOTAVAIL: (libc)Error Codes.
* EADV: (libc)Error Codes.
* EAFNOSUPPORT: (libc)Error Codes.
* EAGAIN: (libc)Error Codes.
* EALREADY: (libc)Error Codes.
* EAUTH: (libc)Error Codes.
* EBACKGROUND: (libc)Error Codes.
* EBADE: (libc)Error Codes.
* EBADF: (libc)Error Codes.
* EBADFD: (libc)Error Codes.
* EBADMSG: (libc)Error Codes.
* EBADR: (libc)Error Codes.
* EBADRPC: (libc)Error Codes.
* EBADRQC: (libc)Error Codes.
* EBADSLT: (libc)Error Codes.
* EBFONT: (libc)Error Codes.
* EBUSY: (libc)Error Codes.
* ECANCELED: (libc)Error Codes.
* ECHILD: (libc)Error Codes.
* ECHO: (libc)Local Modes.
* ECHOCTL: (libc)Local Modes.
* ECHOE: (libc)Local Modes.
* ECHOK: (libc)Local Modes.
* ECHOKE: (libc)Local Modes.
* ECHONL: (libc)Local Modes.
* ECHOPRT: (libc)Local Modes.
* ECHRNG: (libc)Error Codes.
* ECOMM: (libc)Error Codes.
* ECONNABORTED: (libc)Error Codes.
* ECONNREFUSED: (libc)Error Codes.
* ECONNRESET: (libc)Error Codes.
* ED: (libc)Error Codes.
* EDEADLK: (libc)Error Codes.
* EDEADLOCK: (libc)Error Codes.
* EDESTADDRREQ: (libc)Error Codes.
* EDIED: (libc)Error Codes.
* EDOM: (libc)Error Codes.
* EDOTDOT: (libc)Error Codes.
* EDQUOT: (libc)Error Codes.
* EEXIST: (libc)Error Codes.
* EFAULT: (libc)Error Codes.
* EFBIG: (libc)Error Codes.
* EFTYPE: (libc)Error Codes.
* EGRATUITOUS: (libc)Error Codes.
* EGREGIOUS: (libc)Error Codes.
* EHOSTDOWN: (libc)Error Codes.
* EHOSTUNREACH: (libc)Error Codes.
* EHWPOISON: (libc)Error Codes.
* EIDRM: (libc)Error Codes.
* EIEIO: (libc)Error Codes.
* EILSEQ: (libc)Error Codes.
* EINPROGRESS: (libc)Error Codes.
* EINTR: (libc)Error Codes.
* EINVAL: (libc)Error Codes.
* EIO: (libc)Error Codes.
* EISCONN: (libc)Error Codes.
* EISDIR: (libc)Error Codes.
* EISNAM: (libc)Error Codes.
* EKEYEXPIRED: (libc)Error Codes.
* EKEYREJECTED: (libc)Error Codes.
* EKEYREVOKED: (libc)Error Codes.
* EL2HLT: (libc)Error Codes.
* EL2NSYNC: (libc)Error Codes.
* EL3HLT: (libc)Error Codes.
* EL3RST: (libc)Error Codes.
* ELIBACC: (libc)Error Codes.
* ELIBBAD: (libc)Error Codes.
* ELIBEXEC: (libc)Error Codes.
* ELIBMAX: (libc)Error Codes.
* ELIBSCN: (libc)Error Codes.
* ELNRNG: (libc)Error Codes.
* ELOOP: (libc)Error Codes.
* EMEDIUMTYPE: (libc)Error Codes.
* EMFILE: (libc)Error Codes.
* EMLINK: (libc)Error Codes.
* EMSGSIZE: (libc)Error Codes.
* EMULTIHOP: (libc)Error Codes.
* ENAMETOOLONG: (libc)Error Codes.
* ENAVAIL: (libc)Error Codes.
* ENEEDAUTH: (libc)Error Codes.
* ENETDOWN: (libc)Error Codes.
* ENETRESET: (libc)Error Codes.
* ENETUNREACH: (libc)Error Codes.
* ENFILE: (libc)Error Codes.
* ENOANO: (libc)Error Codes.
* ENOBUFS: (libc)Error Codes.
* ENOCSI: (libc)Error Codes.
* ENODATA: (libc)Error Codes.
* ENODEV: (libc)Error Codes.
* ENOENT: (libc)Error Codes.
* ENOEXEC: (libc)Error Codes.
* ENOKEY: (libc)Error Codes.
* ENOLCK: (libc)Error Codes.
* ENOLINK: (libc)Error Codes.
* ENOMEDIUM: (libc)Error Codes.
* ENOMEM: (libc)Error Codes.
* ENOMSG: (libc)Error Codes.
* ENONET: (libc)Error Codes.
* ENOPKG: (libc)Error Codes.
* ENOPROTOOPT: (libc)Error Codes.
* ENOSPC: (libc)Error Codes.
* ENOSR: (libc)Error Codes.
* ENOSTR: (libc)Error Codes.
* ENOSYS: (libc)Error Codes.
* ENOTBLK: (libc)Error Codes.
* ENOTCONN: (libc)Error Codes.
* ENOTDIR: (libc)Error Codes.
* ENOTEMPTY: (libc)Error Codes.
* ENOTNAM: (libc)Error Codes.
* ENOTRECOVERABLE: (libc)Error Codes.
* ENOTSOCK: (libc)Error Codes.
* ENOTSUP: (libc)Error Codes.
* ENOTTY: (libc)Error Codes.
* ENOTUNIQ: (libc)Error Codes.
* ENXIO: (libc)Error Codes.
* EOF: (libc)EOF and Errors.
* EOPNOTSUPP: (libc)Error Codes.
* EOVERFLOW: (libc)Error Codes.
* EOWNERDEAD: (libc)Error Codes.
* EPERM: (libc)Error Codes.
* EPFNOSUPPORT: (libc)Error Codes.
* EPIPE: (libc)Error Codes.
* EPROCLIM: (libc)Error Codes.
* EPROCUNAVAIL: (libc)Error Codes.
* EPROGMISMATCH: (libc)Error Codes.
* EPROGUNAVAIL: (libc)Error Codes.
* EPROTO: (libc)Error Codes.
* EPROTONOSUPPORT: (libc)Error Codes.
* EPROTOTYPE: (libc)Error Codes.
* EQUIV_CLASS_MAX: (libc)Utility Limits.
* ERANGE: (libc)Error Codes.
* EREMCHG: (libc)Error Codes.
* EREMOTE: (libc)Error Codes.
* EREMOTEIO: (libc)Error Codes.
* ERESTART: (libc)Error Codes.
* ERFKILL: (libc)Error Codes.
* EROFS: (libc)Error Codes.
* ERPCMISMATCH: (libc)Error Codes.
* ESHUTDOWN: (libc)Error Codes.
* ESOCKTNOSUPPORT: (libc)Error Codes.
* ESPIPE: (libc)Error Codes.
* ESRCH: (libc)Error Codes.
* ESRMNT: (libc)Error Codes.
* ESTALE: (libc)Error Codes.
* ESTRPIPE: (libc)Error Codes.
* ETIME: (libc)Error Codes.
* ETIMEDOUT: (libc)Error Codes.
* ETOOMANYREFS: (libc)Error Codes.
* ETXTBSY: (libc)Error Codes.
* EUCLEAN: (libc)Error Codes.
* EUNATCH: (libc)Error Codes.
* EUSERS: (libc)Error Codes.
* EWOULDBLOCK: (libc)Error Codes.
* EXDEV: (libc)Error Codes.
* EXFULL: (libc)Error Codes.
* EXIT_FAILURE: (libc)Exit Status.
* EXIT_SUCCESS: (libc)Exit Status.
* EXPR_NEST_MAX: (libc)Utility Limits.
* FD_CLOEXEC: (libc)Descriptor Flags.
* FD_CLR: (libc)Waiting for I/O.
* FD_ISSET: (libc)Waiting for I/O.
* FD_SET: (libc)Waiting for I/O.
* FD_SETSIZE: (libc)Waiting for I/O.
* FD_ZERO: (libc)Waiting for I/O.
* FE_SNANS_ALWAYS_SIGNAL: (libc)Infinity and NaN.
* FILENAME_MAX: (libc)Limits for Files.
* FLUSHO: (libc)Local Modes.
* FOPEN_MAX: (libc)Opening Streams.
* FP_ILOGB0: (libc)Exponents and Logarithms.
* FP_ILOGBNAN: (libc)Exponents and Logarithms.
* FP_LLOGB0: (libc)Exponents and Logarithms.
* FP_LLOGBNAN: (libc)Exponents and Logarithms.
* F_DUPFD: (libc)Duplicating Descriptors.
* F_GETFD: (libc)Descriptor Flags.
* F_GETFL: (libc)Getting File Status Flags.
* F_GETLK: (libc)File Locks.
* F_GETOWN: (libc)Interrupt Input.
* F_OFD_GETLK: (libc)Open File Description Locks.
* F_OFD_SETLK: (libc)Open File Description Locks.
* F_OFD_SETLKW: (libc)Open File Description Locks.
* F_OK: (libc)Testing File Access.
* F_SETFD: (libc)Descriptor Flags.
* F_SETFL: (libc)Getting File Status Flags.
* F_SETLK: (libc)File Locks.
* F_SETLKW: (libc)File Locks.
* F_SETOWN: (libc)Interrupt Input.
* HUGE_VAL: (libc)Math Error Reporting.
* HUGE_VALF: (libc)Math Error Reporting.
* HUGE_VALL: (libc)Math Error Reporting.
* HUGE_VAL_FN: (libc)Math Error Reporting.
* HUGE_VAL_FNx: (libc)Math Error Reporting.
* HUPCL: (libc)Control Modes.
* I: (libc)Complex Numbers.
* ICANON: (libc)Local Modes.
* ICRNL: (libc)Input Modes.
* IEXTEN: (libc)Local Modes.
* IFNAMSIZ: (libc)Interface Naming.
* IFTODT: (libc)Directory Entries.
* IGNBRK: (libc)Input Modes.
* IGNCR: (libc)Input Modes.
* IGNPAR: (libc)Input Modes.
* IMAXBEL: (libc)Input Modes.
* INADDR_ANY: (libc)Host Address Data Type.
* INADDR_BROADCAST: (libc)Host Address Data Type.
* INADDR_LOOPBACK: (libc)Host Address Data Type.
* INADDR_NONE: (libc)Host Address Data Type.
* INFINITY: (libc)Infinity and NaN.
* INLCR: (libc)Input Modes.
* INPCK: (libc)Input Modes.
* IPPORT_RESERVED: (libc)Ports.
* IPPORT_USERRESERVED: (libc)Ports.
* ISIG: (libc)Local Modes.
* ISTRIP: (libc)Input Modes.
* IXANY: (libc)Input Modes.
* IXOFF: (libc)Input Modes.
* IXON: (libc)Input Modes.
* LINE_MAX: (libc)Utility Limits.
* LINK_MAX: (libc)Limits for Files.
* L_ctermid: (libc)Identifying the Terminal.
* L_cuserid: (libc)Who Logged In.
* L_tmpnam: (libc)Temporary Files.
* MAXNAMLEN: (libc)Limits for Files.
* MAXSYMLINKS: (libc)Symbolic Links.
* MAX_CANON: (libc)Limits for Files.
* MAX_INPUT: (libc)Limits for Files.
* MB_CUR_MAX: (libc)Selecting the Conversion.
* MB_LEN_MAX: (libc)Selecting the Conversion.
* MDMBUF: (libc)Control Modes.
* MSG_DONTROUTE: (libc)Socket Data Options.
* MSG_OOB: (libc)Socket Data Options.
* MSG_PEEK: (libc)Socket Data Options.
* NAME_MAX: (libc)Limits for Files.
* NAN: (libc)Infinity and NaN.
* NCCS: (libc)Mode Data Types.
* NGROUPS_MAX: (libc)General Limits.
* NOFLSH: (libc)Local Modes.
* NOKERNINFO: (libc)Local Modes.
* NSIG: (libc)Standard Signals.
* NULL: (libc)Null Pointer Constant.
* ONLCR: (libc)Output Modes.
* ONOEOT: (libc)Output Modes.
* OPEN_MAX: (libc)General Limits.
* OPOST: (libc)Output Modes.
* OXTABS: (libc)Output Modes.
* O_ACCMODE: (libc)Access Modes.
* O_APPEND: (libc)Operating Modes.
* O_ASYNC: (libc)Operating Modes.
* O_CREAT: (libc)Open-time Flags.
* O_DIRECTORY: (libc)Open-time Flags.
* O_EXCL: (libc)Open-time Flags.
* O_EXEC: (libc)Access Modes.
* O_EXLOCK: (libc)Open-time Flags.
* O_FSYNC: (libc)Operating Modes.
* O_IGNORE_CTTY: (libc)Open-time Flags.
* O_NDELAY: (libc)Operating Modes.
* O_NOATIME: (libc)Operating Modes.
* O_NOCTTY: (libc)Open-time Flags.
* O_NOLINK: (libc)Open-time Flags.
* O_NONBLOCK: (libc)Open-time Flags.
* O_NONBLOCK: (libc)Operating Modes.
* O_NOTRANS: (libc)Open-time Flags.
* O_RDONLY: (libc)Access Modes.
* O_RDWR: (libc)Access Modes.
* O_READ: (libc)Access Modes.
* O_SHLOCK: (libc)Open-time Flags.
* O_SYNC: (libc)Operating Modes.
* O_TMPFILE: (libc)Open-time Flags.
* O_TRUNC: (libc)Open-time Flags.
* O_WRITE: (libc)Access Modes.
* O_WRONLY: (libc)Access Modes.
* PARENB: (libc)Control Modes.
* PARMRK: (libc)Input Modes.
* PARODD: (libc)Control Modes.
* PATH_MAX: (libc)Limits for Files.
* PA_FLAG_MASK: (libc)Parsing a Template String.
* PENDIN: (libc)Local Modes.
* PF_FILE: (libc)Local Namespace Details.
* PF_INET6: (libc)Internet Namespace.
* PF_INET: (libc)Internet Namespace.
* PF_LOCAL: (libc)Local Namespace Details.
* PF_UNIX: (libc)Local Namespace Details.
* PIPE_BUF: (libc)Limits for Files.
* P_tmpdir: (libc)Temporary Files.
* RAND_MAX: (libc)ISO Random.
* RE_DUP_MAX: (libc)General Limits.
* RLIM_INFINITY: (libc)Limits on Resources.
* R_OK: (libc)Testing File Access.
* SA_NOCLDSTOP: (libc)Flags for Sigaction.
* SA_ONSTACK: (libc)Flags for Sigaction.
* SA_RESTART: (libc)Flags for Sigaction.
* SEEK_CUR: (libc)File Positioning.
* SEEK_END: (libc)File Positioning.
* SEEK_SET: (libc)File Positioning.
* SIGABRT: (libc)Program Error Signals.
* SIGALRM: (libc)Alarm Signals.
* SIGBUS: (libc)Program Error Signals.
* SIGCHLD: (libc)Job Control Signals.
* SIGCLD: (libc)Job Control Signals.
* SIGCONT: (libc)Job Control Signals.
* SIGEMT: (libc)Program Error Signals.
* SIGFPE: (libc)Program Error Signals.
* SIGHUP: (libc)Termination Signals.
* SIGILL: (libc)Program Error Signals.
* SIGINFO: (libc)Miscellaneous Signals.
* SIGINT: (libc)Termination Signals.
* SIGIO: (libc)Asynchronous I/O Signals.
* SIGIOT: (libc)Program Error Signals.
* SIGKILL: (libc)Termination Signals.
* SIGLOST: (libc)Operation Error Signals.
* SIGPIPE: (libc)Operation Error Signals.
* SIGPOLL: (libc)Asynchronous I/O Signals.
* SIGPROF: (libc)Alarm Signals.
* SIGQUIT: (libc)Termination Signals.
* SIGSEGV: (libc)Program Error Signals.
* SIGSTOP: (libc)Job Control Signals.
* SIGSYS: (libc)Program Error Signals.
* SIGTERM: (libc)Termination Signals.
* SIGTRAP: (libc)Program Error Signals.
* SIGTSTP: (libc)Job Control Signals.
* SIGTTIN: (libc)Job Control Signals.
* SIGTTOU: (libc)Job Control Signals.
* SIGURG: (libc)Asynchronous I/O Signals.
* SIGUSR1: (libc)Miscellaneous Signals.
* SIGUSR2: (libc)Miscellaneous Signals.
* SIGVTALRM: (libc)Alarm Signals.
* SIGWINCH: (libc)Miscellaneous Signals.
* SIGXCPU: (libc)Operation Error Signals.
* SIGXFSZ: (libc)Operation Error Signals.
* SIG_ERR: (libc)Basic Signal Handling.
* SNAN: (libc)Infinity and NaN.
* SNANF: (libc)Infinity and NaN.
* SNANFN: (libc)Infinity and NaN.
* SNANFNx: (libc)Infinity and NaN.
* SNANL: (libc)Infinity and NaN.
* SOCK_DGRAM: (libc)Communication Styles.
* SOCK_RAW: (libc)Communication Styles.
* SOCK_RDM: (libc)Communication Styles.
* SOCK_SEQPACKET: (libc)Communication Styles.
* SOCK_STREAM: (libc)Communication Styles.
* SOL_SOCKET: (libc)Socket-Level Options.
* SSIZE_MAX: (libc)General Limits.
* STREAM_MAX: (libc)General Limits.
* SUN_LEN: (libc)Local Namespace Details.
* S_IFMT: (libc)Testing File Type.
* S_ISBLK: (libc)Testing File Type.
* S_ISCHR: (libc)Testing File Type.
* S_ISDIR: (libc)Testing File Type.
* S_ISFIFO: (libc)Testing File Type.
* S_ISLNK: (libc)Testing File Type.
* S_ISREG: (libc)Testing File Type.
* S_ISSOCK: (libc)Testing File Type.
* S_TYPEISMQ: (libc)Testing File Type.
* S_TYPEISSEM: (libc)Testing File Type.
* S_TYPEISSHM: (libc)Testing File Type.
* TMP_MAX: (libc)Temporary Files.
* TOSTOP: (libc)Local Modes.
* TZNAME_MAX: (libc)General Limits.
* VDISCARD: (libc)Other Special.
* VDSUSP: (libc)Signal Characters.
* VEOF: (libc)Editing Characters.
* VEOL2: (libc)Editing Characters.
* VEOL: (libc)Editing Characters.
* VERASE: (libc)Editing Characters.
* VINTR: (libc)Signal Characters.
* VKILL: (libc)Editing Characters.
* VLNEXT: (libc)Other Special.
* VMIN: (libc)Noncanonical Input.
* VQUIT: (libc)Signal Characters.
* VREPRINT: (libc)Editing Characters.
* VSTART: (libc)Start/Stop Characters.
* VSTATUS: (libc)Other Special.
* VSTOP: (libc)Start/Stop Characters.
* VSUSP: (libc)Signal Characters.
* VTIME: (libc)Noncanonical Input.
* VWERASE: (libc)Editing Characters.
* WCHAR_MAX: (libc)Extended Char Intro.
* WCHAR_MIN: (libc)Extended Char Intro.
* WCOREDUMP: (libc)Process Completion Status.
* WEOF: (libc)EOF and Errors.
* WEOF: (libc)Extended Char Intro.
* WEXITSTATUS: (libc)Process Completion Status.
* WIFEXITED: (libc)Process Completion Status.
* WIFSIGNALED: (libc)Process Completion Status.
* WIFSTOPPED: (libc)Process Completion Status.
* WSTOPSIG: (libc)Process Completion Status.
* WTERMSIG: (libc)Process Completion Status.
* W_OK: (libc)Testing File Access.
* X_OK: (libc)Testing File Access.
* _Complex_I: (libc)Complex Numbers.
* _Exit: (libc)Termination Internals.
* _IOFBF: (libc)Controlling Buffering.
* _IOLBF: (libc)Controlling Buffering.
* _IONBF: (libc)Controlling Buffering.
* _Imaginary_I: (libc)Complex Numbers.
* _PATH_UTMP: (libc)Manipulating the Database.
* _PATH_WTMP: (libc)Manipulating the Database.
* _POSIX2_C_DEV: (libc)System Options.
* _POSIX2_C_VERSION: (libc)Version Supported.
* _POSIX2_FORT_DEV: (libc)System Options.
* _POSIX2_FORT_RUN: (libc)System Options.
* _POSIX2_LOCALEDEF: (libc)System Options.
* _POSIX2_SW_DEV: (libc)System Options.
* _POSIX_CHOWN_RESTRICTED: (libc)Options for Files.
* _POSIX_JOB_CONTROL: (libc)System Options.
* _POSIX_NO_TRUNC: (libc)Options for Files.
* _POSIX_SAVED_IDS: (libc)System Options.
* _POSIX_VDISABLE: (libc)Options for Files.
* _POSIX_VERSION: (libc)Version Supported.
* __fbufsize: (libc)Controlling Buffering.
* __flbf: (libc)Controlling Buffering.
* __fpending: (libc)Controlling Buffering.
* __fpurge: (libc)Flushing Buffers.
* __freadable: (libc)Opening Streams.
* __freading: (libc)Opening Streams.
* __fsetlocking: (libc)Streams and Threads.
* __fwritable: (libc)Opening Streams.
* __fwriting: (libc)Opening Streams.
* __gconv_end_fct: (libc)glibc iconv Implementation.
* __gconv_fct: (libc)glibc iconv Implementation.
* __gconv_init_fct: (libc)glibc iconv Implementation.
* __ppc_get_timebase: (libc)PowerPC.
* __ppc_get_timebase_freq: (libc)PowerPC.
* __ppc_mdoio: (libc)PowerPC.
* __ppc_mdoom: (libc)PowerPC.
* __ppc_set_ppr_low: (libc)PowerPC.
* __ppc_set_ppr_med: (libc)PowerPC.
* __ppc_set_ppr_med_high: (libc)PowerPC.
* __ppc_set_ppr_med_low: (libc)PowerPC.
* __ppc_set_ppr_very_low: (libc)PowerPC.
* __ppc_yield: (libc)PowerPC.
* __riscv_flush_icache: (libc)RISC-V.
* __va_copy: (libc)Argument Macros.
* _exit: (libc)Termination Internals.
* _flushlbf: (libc)Flushing Buffers.
* _tolower: (libc)Case Conversion.
* _toupper: (libc)Case Conversion.
* a64l: (libc)Encode Binary Data.
* abort: (libc)Aborting a Program.
* abs: (libc)Absolute Value.
* accept: (libc)Accepting Connections.
* access: (libc)Testing File Access.
* acos: (libc)Inverse Trig Functions.
* acosf: (libc)Inverse Trig Functions.
* acosfN: (libc)Inverse Trig Functions.
* acosfNx: (libc)Inverse Trig Functions.
* acosh: (libc)Hyperbolic Functions.
* acoshf: (libc)Hyperbolic Functions.
* acoshfN: (libc)Hyperbolic Functions.
* acoshfNx: (libc)Hyperbolic Functions.
* acoshl: (libc)Hyperbolic Functions.
* acosl: (libc)Inverse Trig Functions.
* addmntent: (libc)mtab.
* addseverity: (libc)Adding Severity Classes.
* adjtime: (libc)High-Resolution Calendar.
* adjtimex: (libc)High-Resolution Calendar.
* aio_cancel64: (libc)Cancel AIO Operations.
* aio_cancel: (libc)Cancel AIO Operations.
* aio_error64: (libc)Status of AIO Operations.
* aio_error: (libc)Status of AIO Operations.
* aio_fsync64: (libc)Synchronizing AIO Operations.
* aio_fsync: (libc)Synchronizing AIO Operations.
* aio_init: (libc)Configuration of AIO.
* aio_read64: (libc)Asynchronous Reads/Writes.
* aio_read: (libc)Asynchronous Reads/Writes.
* aio_return64: (libc)Status of AIO Operations.
* aio_return: (libc)Status of AIO Operations.
* aio_suspend64: (libc)Synchronizing AIO Operations.
* aio_suspend: (libc)Synchronizing AIO Operations.
* aio_write64: (libc)Asynchronous Reads/Writes.
* aio_write: (libc)Asynchronous Reads/Writes.
* alarm: (libc)Setting an Alarm.
* aligned_alloc: (libc)Aligned Memory Blocks.
* alloca: (libc)Variable Size Automatic.
* alphasort64: (libc)Scanning Directory Content.
* alphasort: (libc)Scanning Directory Content.
* argp_error: (libc)Argp Helper Functions.
* argp_failure: (libc)Argp Helper Functions.
* argp_help: (libc)Argp Help.
* argp_parse: (libc)Argp.
* argp_state_help: (libc)Argp Helper Functions.
* argp_usage: (libc)Argp Helper Functions.
* argz_add: (libc)Argz Functions.
* argz_add_sep: (libc)Argz Functions.
* argz_append: (libc)Argz Functions.
* argz_count: (libc)Argz Functions.
* argz_create: (libc)Argz Functions.
* argz_create_sep: (libc)Argz Functions.
* argz_delete: (libc)Argz Functions.
* argz_extract: (libc)Argz Functions.
* argz_insert: (libc)Argz Functions.
* argz_next: (libc)Argz Functions.
* argz_replace: (libc)Argz Functions.
* argz_stringify: (libc)Argz Functions.
* asctime: (libc)Formatting Calendar Time.
* asctime_r: (libc)Formatting Calendar Time.
* asin: (libc)Inverse Trig Functions.
* asinf: (libc)Inverse Trig Functions.
* asinfN: (libc)Inverse Trig Functions.
* asinfNx: (libc)Inverse Trig Functions.
* asinh: (libc)Hyperbolic Functions.
* asinhf: (libc)Hyperbolic Functions.
* asinhfN: (libc)Hyperbolic Functions.
* asinhfNx: (libc)Hyperbolic Functions.
* asinhl: (libc)Hyperbolic Functions.
* asinl: (libc)Inverse Trig Functions.
* asprintf: (libc)Dynamic Output.
* assert: (libc)Consistency Checking.
* assert_perror: (libc)Consistency Checking.
* atan2: (libc)Inverse Trig Functions.
* atan2f: (libc)Inverse Trig Functions.
* atan2fN: (libc)Inverse Trig Functions.
* atan2fNx: (libc)Inverse Trig Functions.
* atan2l: (libc)Inverse Trig Functions.
* atan: (libc)Inverse Trig Functions.
* atanf: (libc)Inverse Trig Functions.
* atanfN: (libc)Inverse Trig Functions.
* atanfNx: (libc)Inverse Trig Functions.
* atanh: (libc)Hyperbolic Functions.
* atanhf: (libc)Hyperbolic Functions.
* atanhfN: (libc)Hyperbolic Functions.
* atanhfNx: (libc)Hyperbolic Functions.
* atanhl: (libc)Hyperbolic Functions.
* atanl: (libc)Inverse Trig Functions.
* atexit: (libc)Cleanups on Exit.
* atof: (libc)Parsing of Floats.
* atoi: (libc)Parsing of Integers.
* atol: (libc)Parsing of Integers.
* atoll: (libc)Parsing of Integers.
* backtrace: (libc)Backtraces.
* backtrace_symbols: (libc)Backtraces.
* backtrace_symbols_fd: (libc)Backtraces.
* basename: (libc)Finding Tokens in a String.
* basename: (libc)Finding Tokens in a String.
* bcmp: (libc)String/Array Comparison.
* bcopy: (libc)Copying Strings and Arrays.
* bind: (libc)Setting Address.
* bind_textdomain_codeset: (libc)Charset conversion in gettext.
* bindtextdomain: (libc)Locating gettext catalog.
* brk: (libc)Resizing the Data Segment.
* bsearch: (libc)Array Search Function.
* btowc: (libc)Converting a Character.
* bzero: (libc)Copying Strings and Arrays.
* cabs: (libc)Absolute Value.
* cabsf: (libc)Absolute Value.
* cabsfN: (libc)Absolute Value.
* cabsfNx: (libc)Absolute Value.
* cabsl: (libc)Absolute Value.
* cacos: (libc)Inverse Trig Functions.
* cacosf: (libc)Inverse Trig Functions.
* cacosfN: (libc)Inverse Trig Functions.
* cacosfNx: (libc)Inverse Trig Functions.
* cacosh: (libc)Hyperbolic Functions.
* cacoshf: (libc)Hyperbolic Functions.
* cacoshfN: (libc)Hyperbolic Functions.
* cacoshfNx: (libc)Hyperbolic Functions.
* cacoshl: (libc)Hyperbolic Functions.
* cacosl: (libc)Inverse Trig Functions.
* call_once: (libc)Call Once.
* calloc: (libc)Allocating Cleared Space.
* canonicalize: (libc)FP Bit Twiddling.
* canonicalize_file_name: (libc)Symbolic Links.
* canonicalizef: (libc)FP Bit Twiddling.
* canonicalizefN: (libc)FP Bit Twiddling.
* canonicalizefNx: (libc)FP Bit Twiddling.
* canonicalizel: (libc)FP Bit Twiddling.
* carg: (libc)Operations on Complex.
* cargf: (libc)Operations on Complex.
* cargfN: (libc)Operations on Complex.
* cargfNx: (libc)Operations on Complex.
* cargl: (libc)Operations on Complex.
* casin: (libc)Inverse Trig Functions.
* casinf: (libc)Inverse Trig Functions.
* casinfN: (libc)Inverse Trig Functions.
* casinfNx: (libc)Inverse Trig Functions.
* casinh: (libc)Hyperbolic Functions.
* casinhf: (libc)Hyperbolic Functions.
* casinhfN: (libc)Hyperbolic Functions.
* casinhfNx: (libc)Hyperbolic Functions.
* casinhl: (libc)Hyperbolic Functions.
* casinl: (libc)Inverse Trig Functions.
* catan: (libc)Inverse Trig Functions.
* catanf: (libc)Inverse Trig Functions.
* catanfN: (libc)Inverse Trig Functions.
* catanfNx: (libc)Inverse Trig Functions.
* catanh: (libc)Hyperbolic Functions.
* catanhf: (libc)Hyperbolic Functions.
* catanhfN: (libc)Hyperbolic Functions.
* catanhfNx: (libc)Hyperbolic Functions.
* catanhl: (libc)Hyperbolic Functions.
* catanl: (libc)Inverse Trig Functions.
* catclose: (libc)The catgets Functions.
* catgets: (libc)The catgets Functions.
* catopen: (libc)The catgets Functions.
* cbrt: (libc)Exponents and Logarithms.
* cbrtf: (libc)Exponents and Logarithms.
* cbrtfN: (libc)Exponents and Logarithms.
* cbrtfNx: (libc)Exponents and Logarithms.
* cbrtl: (libc)Exponents and Logarithms.
* ccos: (libc)Trig Functions.
* ccosf: (libc)Trig Functions.
* ccosfN: (libc)Trig Functions.
* ccosfNx: (libc)Trig Functions.
* ccosh: (libc)Hyperbolic Functions.
* ccoshf: (libc)Hyperbolic Functions.
* ccoshfN: (libc)Hyperbolic Functions.
* ccoshfNx: (libc)Hyperbolic Functions.
* ccoshl: (libc)Hyperbolic Functions.
* ccosl: (libc)Trig Functions.
* ceil: (libc)Rounding Functions.
* ceilf: (libc)Rounding Functions.
* ceilfN: (libc)Rounding Functions.
* ceilfNx: (libc)Rounding Functions.
* ceill: (libc)Rounding Functions.
* cexp: (libc)Exponents and Logarithms.
* cexpf: (libc)Exponents and Logarithms.
* cexpfN: (libc)Exponents and Logarithms.
* cexpfNx: (libc)Exponents and Logarithms.
* cexpl: (libc)Exponents and Logarithms.
* cfgetispeed: (libc)Line Speed.
* cfgetospeed: (libc)Line Speed.
* cfmakeraw: (libc)Noncanonical Input.
* cfsetispeed: (libc)Line Speed.
* cfsetospeed: (libc)Line Speed.
* cfsetspeed: (libc)Line Speed.
* chdir: (libc)Working Directory.
* chmod: (libc)Setting Permissions.
* chown: (libc)File Owner.
* cimag: (libc)Operations on Complex.
* cimagf: (libc)Operations on Complex.
* cimagfN: (libc)Operations on Complex.
* cimagfNx: (libc)Operations on Complex.
* cimagl: (libc)Operations on Complex.
* clearenv: (libc)Environment Access.
* clearerr: (libc)Error Recovery.
* clearerr_unlocked: (libc)Error Recovery.
* clock: (libc)CPU Time.
* clog10: (libc)Exponents and Logarithms.
* clog10f: (libc)Exponents and Logarithms.
* clog10fN: (libc)Exponents and Logarithms.
* clog10fNx: (libc)Exponents and Logarithms.
* clog10l: (libc)Exponents and Logarithms.
* clog: (libc)Exponents and Logarithms.
* clogf: (libc)Exponents and Logarithms.
* clogfN: (libc)Exponents and Logarithms.
* clogfNx: (libc)Exponents and Logarithms.
* clogl: (libc)Exponents and Logarithms.
* close: (libc)Opening and Closing Files.
* closedir: (libc)Reading/Closing Directory.
* closelog: (libc)closelog.
* cnd_broadcast: (libc)ISO C Condition Variables.
* cnd_destroy: (libc)ISO C Condition Variables.
* cnd_init: (libc)ISO C Condition Variables.
* cnd_signal: (libc)ISO C Condition Variables.
* cnd_timedwait: (libc)ISO C Condition Variables.
* cnd_wait: (libc)ISO C Condition Variables.
* confstr: (libc)String Parameters.
* conj: (libc)Operations on Complex.
* conjf: (libc)Operations on Complex.
* conjfN: (libc)Operations on Complex.
* conjfNx: (libc)Operations on Complex.
* conjl: (libc)Operations on Complex.
* connect: (libc)Connecting.
* copy_file_range: (libc)Copying File Data.
* copysign: (libc)FP Bit Twiddling.
* copysignf: (libc)FP Bit Twiddling.
* copysignfN: (libc)FP Bit Twiddling.
* copysignfNx: (libc)FP Bit Twiddling.
* copysignl: (libc)FP Bit Twiddling.
* cos: (libc)Trig Functions.
* cosf: (libc)Trig Functions.
* cosfN: (libc)Trig Functions.
* cosfNx: (libc)Trig Functions.
* cosh: (libc)Hyperbolic Functions.
* coshf: (libc)Hyperbolic Functions.
* coshfN: (libc)Hyperbolic Functions.
* coshfNx: (libc)Hyperbolic Functions.
* coshl: (libc)Hyperbolic Functions.
* cosl: (libc)Trig Functions.
* cpow: (libc)Exponents and Logarithms.
* cpowf: (libc)Exponents and Logarithms.
* cpowfN: (libc)Exponents and Logarithms.
* cpowfNx: (libc)Exponents and Logarithms.
* cpowl: (libc)Exponents and Logarithms.
* cproj: (libc)Operations on Complex.
* cprojf: (libc)Operations on Complex.
* cprojfN: (libc)Operations on Complex.
* cprojfNx: (libc)Operations on Complex.
* cprojl: (libc)Operations on Complex.
* creal: (libc)Operations on Complex.
* crealf: (libc)Operations on Complex.
* crealfN: (libc)Operations on Complex.
* crealfNx: (libc)Operations on Complex.
* creall: (libc)Operations on Complex.
* creat64: (libc)Opening and Closing Files.
* creat: (libc)Opening and Closing Files.
* crypt: (libc)Passphrase Storage.
* crypt_r: (libc)Passphrase Storage.
* csin: (libc)Trig Functions.
* csinf: (libc)Trig Functions.
* csinfN: (libc)Trig Functions.
* csinfNx: (libc)Trig Functions.
* csinh: (libc)Hyperbolic Functions.
* csinhf: (libc)Hyperbolic Functions.
* csinhfN: (libc)Hyperbolic Functions.
* csinhfNx: (libc)Hyperbolic Functions.
* csinhl: (libc)Hyperbolic Functions.
* csinl: (libc)Trig Functions.
* csqrt: (libc)Exponents and Logarithms.
* csqrtf: (libc)Exponents and Logarithms.
* csqrtfN: (libc)Exponents and Logarithms.
* csqrtfNx: (libc)Exponents and Logarithms.
* csqrtl: (libc)Exponents and Logarithms.
* ctan: (libc)Trig Functions.
* ctanf: (libc)Trig Functions.
* ctanfN: (libc)Trig Functions.
* ctanfNx: (libc)Trig Functions.
* ctanh: (libc)Hyperbolic Functions.
* ctanhf: (libc)Hyperbolic Functions.
* ctanhfN: (libc)Hyperbolic Functions.
* ctanhfNx: (libc)Hyperbolic Functions.
* ctanhl: (libc)Hyperbolic Functions.
* ctanl: (libc)Trig Functions.
* ctermid: (libc)Identifying the Terminal.
* ctime: (libc)Formatting Calendar Time.
* ctime_r: (libc)Formatting Calendar Time.
* cuserid: (libc)Who Logged In.
* daddl: (libc)Misc FP Arithmetic.
* dcgettext: (libc)Translation with gettext.
* dcngettext: (libc)Advanced gettext functions.
* ddivl: (libc)Misc FP Arithmetic.
* dgettext: (libc)Translation with gettext.
* difftime: (libc)Elapsed Time.
* dirfd: (libc)Opening a Directory.
* dirname: (libc)Finding Tokens in a String.
* div: (libc)Integer Division.
* dmull: (libc)Misc FP Arithmetic.
* dngettext: (libc)Advanced gettext functions.
* drand48: (libc)SVID Random.
* drand48_r: (libc)SVID Random.
* drem: (libc)Remainder Functions.
* dremf: (libc)Remainder Functions.
* dreml: (libc)Remainder Functions.
* dsubl: (libc)Misc FP Arithmetic.
* dup2: (libc)Duplicating Descriptors.
* dup: (libc)Duplicating Descriptors.
* ecvt: (libc)System V Number Conversion.
* ecvt_r: (libc)System V Number Conversion.
* endfsent: (libc)fstab.
* endgrent: (libc)Scanning All Groups.
* endhostent: (libc)Host Names.
* endmntent: (libc)mtab.
* endnetent: (libc)Networks Database.
* endnetgrent: (libc)Lookup Netgroup.
* endprotoent: (libc)Protocols Database.
* endpwent: (libc)Scanning All Users.
* endservent: (libc)Services Database.
* endutent: (libc)Manipulating the Database.
* endutxent: (libc)XPG Functions.
* envz_add: (libc)Envz Functions.
* envz_entry: (libc)Envz Functions.
* envz_get: (libc)Envz Functions.
* envz_merge: (libc)Envz Functions.
* envz_remove: (libc)Envz Functions.
* envz_strip: (libc)Envz Functions.
* erand48: (libc)SVID Random.
* erand48_r: (libc)SVID Random.
* erf: (libc)Special Functions.
* erfc: (libc)Special Functions.
* erfcf: (libc)Special Functions.
* erfcfN: (libc)Special Functions.
* erfcfNx: (libc)Special Functions.
* erfcl: (libc)Special Functions.
* erff: (libc)Special Functions.
* erffN: (libc)Special Functions.
* erffNx: (libc)Special Functions.
* erfl: (libc)Special Functions.
* err: (libc)Error Messages.
* errno: (libc)Checking for Errors.
* error: (libc)Error Messages.
* error_at_line: (libc)Error Messages.
* errx: (libc)Error Messages.
* execl: (libc)Executing a File.
* execle: (libc)Executing a File.
* execlp: (libc)Executing a File.
* execv: (libc)Executing a File.
* execve: (libc)Executing a File.
* execvp: (libc)Executing a File.
* exit: (libc)Normal Termination.
* exp10: (libc)Exponents and Logarithms.
* exp10f: (libc)Exponents and Logarithms.
* exp10fN: (libc)Exponents and Logarithms.
* exp10fNx: (libc)Exponents and Logarithms.
* exp10l: (libc)Exponents and Logarithms.
* exp2: (libc)Exponents and Logarithms.
* exp2f: (libc)Exponents and Logarithms.
* exp2fN: (libc)Exponents and Logarithms.
* exp2fNx: (libc)Exponents and Logarithms.
* exp2l: (libc)Exponents and Logarithms.
* exp: (libc)Exponents and Logarithms.
* expf: (libc)Exponents and Logarithms.
* expfN: (libc)Exponents and Logarithms.
* expfNx: (libc)Exponents and Logarithms.
* expl: (libc)Exponents and Logarithms.
* explicit_bzero: (libc)Erasing Sensitive Data.
* expm1: (libc)Exponents and Logarithms.
* expm1f: (libc)Exponents and Logarithms.
* expm1fN: (libc)Exponents and Logarithms.
* expm1fNx: (libc)Exponents and Logarithms.
* expm1l: (libc)Exponents and Logarithms.
* fMaddfN: (libc)Misc FP Arithmetic.
* fMaddfNx: (libc)Misc FP Arithmetic.
* fMdivfN: (libc)Misc FP Arithmetic.
* fMdivfNx: (libc)Misc FP Arithmetic.
* fMmulfN: (libc)Misc FP Arithmetic.
* fMmulfNx: (libc)Misc FP Arithmetic.
* fMsubfN: (libc)Misc FP Arithmetic.
* fMsubfNx: (libc)Misc FP Arithmetic.
* fMxaddfN: (libc)Misc FP Arithmetic.
* fMxaddfNx: (libc)Misc FP Arithmetic.
* fMxdivfN: (libc)Misc FP Arithmetic.
* fMxdivfNx: (libc)Misc FP Arithmetic.
* fMxmulfN: (libc)Misc FP Arithmetic.
* fMxmulfNx: (libc)Misc FP Arithmetic.
* fMxsubfN: (libc)Misc FP Arithmetic.
* fMxsubfNx: (libc)Misc FP Arithmetic.
* fabs: (libc)Absolute Value.
* fabsf: (libc)Absolute Value.
* fabsfN: (libc)Absolute Value.
* fabsfNx: (libc)Absolute Value.
* fabsl: (libc)Absolute Value.
* fadd: (libc)Misc FP Arithmetic.
* faddl: (libc)Misc FP Arithmetic.
* fchdir: (libc)Working Directory.
* fchmod: (libc)Setting Permissions.
* fchown: (libc)File Owner.
* fclose: (libc)Closing Streams.
* fcloseall: (libc)Closing Streams.
* fcntl: (libc)Control Operations.
* fcvt: (libc)System V Number Conversion.
* fcvt_r: (libc)System V Number Conversion.
* fdatasync: (libc)Synchronizing I/O.
* fdim: (libc)Misc FP Arithmetic.
* fdimf: (libc)Misc FP Arithmetic.
* fdimfN: (libc)Misc FP Arithmetic.
* fdimfNx: (libc)Misc FP Arithmetic.
* fdiml: (libc)Misc FP Arithmetic.
* fdiv: (libc)Misc FP Arithmetic.
* fdivl: (libc)Misc FP Arithmetic.
* fdopen: (libc)Descriptors and Streams.
* fdopendir: (libc)Opening a Directory.
* feclearexcept: (libc)Status bit operations.
* fedisableexcept: (libc)Control Functions.
* feenableexcept: (libc)Control Functions.
* fegetenv: (libc)Control Functions.
* fegetexcept: (libc)Control Functions.
* fegetexceptflag: (libc)Status bit operations.
* fegetmode: (libc)Control Functions.
* fegetround: (libc)Rounding.
* feholdexcept: (libc)Control Functions.
* feof: (libc)EOF and Errors.
* feof_unlocked: (libc)EOF and Errors.
* feraiseexcept: (libc)Status bit operations.
* ferror: (libc)EOF and Errors.
* ferror_unlocked: (libc)EOF and Errors.
* fesetenv: (libc)Control Functions.
* fesetexcept: (libc)Status bit operations.
* fesetexceptflag: (libc)Status bit operations.
* fesetmode: (libc)Control Functions.
* fesetround: (libc)Rounding.
* fetestexcept: (libc)Status bit operations.
* fetestexceptflag: (libc)Status bit operations.
* feupdateenv: (libc)Control Functions.
* fflush: (libc)Flushing Buffers.
* fflush_unlocked: (libc)Flushing Buffers.
* fgetc: (libc)Character Input.
* fgetc_unlocked: (libc)Character Input.
* fgetgrent: (libc)Scanning All Groups.
* fgetgrent_r: (libc)Scanning All Groups.
* fgetpos64: (libc)Portable Positioning.
* fgetpos: (libc)Portable Positioning.
* fgetpwent: (libc)Scanning All Users.
* fgetpwent_r: (libc)Scanning All Users.
* fgets: (libc)Line Input.
* fgets_unlocked: (libc)Line Input.
* fgetwc: (libc)Character Input.
* fgetwc_unlocked: (libc)Character Input.
* fgetws: (libc)Line Input.
* fgetws_unlocked: (libc)Line Input.
* fileno: (libc)Descriptors and Streams.
* fileno_unlocked: (libc)Descriptors and Streams.
* finite: (libc)Floating Point Classes.
* finitef: (libc)Floating Point Classes.
* finitel: (libc)Floating Point Classes.
* flockfile: (libc)Streams and Threads.
* floor: (libc)Rounding Functions.
* floorf: (libc)Rounding Functions.
* floorfN: (libc)Rounding Functions.
* floorfNx: (libc)Rounding Functions.
* floorl: (libc)Rounding Functions.
* fma: (libc)Misc FP Arithmetic.
* fmaf: (libc)Misc FP Arithmetic.
* fmafN: (libc)Misc FP Arithmetic.
* fmafNx: (libc)Misc FP Arithmetic.
* fmal: (libc)Misc FP Arithmetic.
* fmax: (libc)Misc FP Arithmetic.
* fmaxf: (libc)Misc FP Arithmetic.
* fmaxfN: (libc)Misc FP Arithmetic.
* fmaxfNx: (libc)Misc FP Arithmetic.
* fmaxl: (libc)Misc FP Arithmetic.
* fmaxmag: (libc)Misc FP Arithmetic.
* fmaxmagf: (libc)Misc FP Arithmetic.
* fmaxmagfN: (libc)Misc FP Arithmetic.
* fmaxmagfNx: (libc)Misc FP Arithmetic.
* fmaxmagl: (libc)Misc FP Arithmetic.
* fmemopen: (libc)String Streams.
* fmin: (libc)Misc FP Arithmetic.
* fminf: (libc)Misc FP Arithmetic.
* fminfN: (libc)Misc FP Arithmetic.
* fminfNx: (libc)Misc FP Arithmetic.
* fminl: (libc)Misc FP Arithmetic.
* fminmag: (libc)Misc FP Arithmetic.
* fminmagf: (libc)Misc FP Arithmetic.
* fminmagfN: (libc)Misc FP Arithmetic.
* fminmagfNx: (libc)Misc FP Arithmetic.
* fminmagl: (libc)Misc FP Arithmetic.
* fmod: (libc)Remainder Functions.
* fmodf: (libc)Remainder Functions.
* fmodfN: (libc)Remainder Functions.
* fmodfNx: (libc)Remainder Functions.
* fmodl: (libc)Remainder Functions.
* fmtmsg: (libc)Printing Formatted Messages.
* fmul: (libc)Misc FP Arithmetic.
* fmull: (libc)Misc FP Arithmetic.
* fnmatch: (libc)Wildcard Matching.
* fopen64: (libc)Opening Streams.
* fopen: (libc)Opening Streams.
* fopencookie: (libc)Streams and Cookies.
* fork: (libc)Creating a Process.
* forkpty: (libc)Pseudo-Terminal Pairs.
* fpathconf: (libc)Pathconf.
* fpclassify: (libc)Floating Point Classes.
* fprintf: (libc)Formatted Output Functions.
* fputc: (libc)Simple Output.
* fputc_unlocked: (libc)Simple Output.
* fputs: (libc)Simple Output.
* fputs_unlocked: (libc)Simple Output.
* fputwc: (libc)Simple Output.
* fputwc_unlocked: (libc)Simple Output.
* fputws: (libc)Simple Output.
* fputws_unlocked: (libc)Simple Output.
* fread: (libc)Block Input/Output.
* fread_unlocked: (libc)Block Input/Output.
* free: (libc)Freeing after Malloc.
* freopen64: (libc)Opening Streams.
* freopen: (libc)Opening Streams.
* frexp: (libc)Normalization Functions.
* frexpf: (libc)Normalization Functions.
* frexpfN: (libc)Normalization Functions.
* frexpfNx: (libc)Normalization Functions.
* frexpl: (libc)Normalization Functions.
* fromfp: (libc)Rounding Functions.
* fromfpf: (libc)Rounding Functions.
* fromfpfN: (libc)Rounding Functions.
* fromfpfNx: (libc)Rounding Functions.
* fromfpl: (libc)Rounding Functions.
* fromfpx: (libc)Rounding Functions.
* fromfpxf: (libc)Rounding Functions.
* fromfpxfN: (libc)Rounding Functions.
* fromfpxfNx: (libc)Rounding Functions.
* fromfpxl: (libc)Rounding Functions.
* fscanf: (libc)Formatted Input Functions.
* fseek: (libc)File Positioning.
* fseeko64: (libc)File Positioning.
* fseeko: (libc)File Positioning.
* fsetpos64: (libc)Portable Positioning.
* fsetpos: (libc)Portable Positioning.
* fstat64: (libc)Reading Attributes.
* fstat: (libc)Reading Attributes.
* fsub: (libc)Misc FP Arithmetic.
* fsubl: (libc)Misc FP Arithmetic.
* fsync: (libc)Synchronizing I/O.
* ftell: (libc)File Positioning.
* ftello64: (libc)File Positioning.
* ftello: (libc)File Positioning.
* ftruncate64: (libc)File Size.
* ftruncate: (libc)File Size.
* ftrylockfile: (libc)Streams and Threads.
* ftw64: (libc)Working with Directory Trees.
* ftw: (libc)Working with Directory Trees.
* funlockfile: (libc)Streams and Threads.
* futimes: (libc)File Times.
* fwide: (libc)Streams and I18N.
* fwprintf: (libc)Formatted Output Functions.
* fwrite: (libc)Block Input/Output.
* fwrite_unlocked: (libc)Block Input/Output.
* fwscanf: (libc)Formatted Input Functions.
* gamma: (libc)Special Functions.
* gammaf: (libc)Special Functions.
* gammal: (libc)Special Functions.
* gcvt: (libc)System V Number Conversion.
* get_avphys_pages: (libc)Query Memory Parameters.
* get_current_dir_name: (libc)Working Directory.
* get_nprocs: (libc)Processor Resources.
* get_nprocs_conf: (libc)Processor Resources.
* get_phys_pages: (libc)Query Memory Parameters.
* getauxval: (libc)Auxiliary Vector.
* getc: (libc)Character Input.
* getc_unlocked: (libc)Character Input.
* getchar: (libc)Character Input.
* getchar_unlocked: (libc)Character Input.
* getcontext: (libc)System V contexts.
* getcpu: (libc)CPU Affinity.
* getcwd: (libc)Working Directory.
* getdate: (libc)General Time String Parsing.
* getdate_r: (libc)General Time String Parsing.
* getdelim: (libc)Line Input.
* getdents64: (libc)Low-level Directory Access.
* getdomainnname: (libc)Host Identification.
* getegid: (libc)Reading Persona.
* getentropy: (libc)Unpredictable Bytes.
* getenv: (libc)Environment Access.
* geteuid: (libc)Reading Persona.
* getfsent: (libc)fstab.
* getfsfile: (libc)fstab.
* getfsspec: (libc)fstab.
* getgid: (libc)Reading Persona.
* getgrent: (libc)Scanning All Groups.
* getgrent_r: (libc)Scanning All Groups.
* getgrgid: (libc)Lookup Group.
* getgrgid_r: (libc)Lookup Group.
* getgrnam: (libc)Lookup Group.
* getgrnam_r: (libc)Lookup Group.
* getgrouplist: (libc)Setting Groups.
* getgroups: (libc)Reading Persona.
* gethostbyaddr: (libc)Host Names.
* gethostbyaddr_r: (libc)Host Names.
* gethostbyname2: (libc)Host Names.
* gethostbyname2_r: (libc)Host Names.
* gethostbyname: (libc)Host Names.
* gethostbyname_r: (libc)Host Names.
* gethostent: (libc)Host Names.
* gethostid: (libc)Host Identification.
* gethostname: (libc)Host Identification.
* getitimer: (libc)Setting an Alarm.
* getline: (libc)Line Input.
* getloadavg: (libc)Processor Resources.
* getlogin: (libc)Who Logged In.
* getmntent: (libc)mtab.
* getmntent_r: (libc)mtab.
* getnetbyaddr: (libc)Networks Database.
* getnetbyname: (libc)Networks Database.
* getnetent: (libc)Networks Database.
* getnetgrent: (libc)Lookup Netgroup.
* getnetgrent_r: (libc)Lookup Netgroup.
* getopt: (libc)Using Getopt.
* getopt_long: (libc)Getopt Long Options.
* getopt_long_only: (libc)Getopt Long Options.
* getpagesize: (libc)Query Memory Parameters.
* getpass: (libc)getpass.
* getpayload: (libc)FP Bit Twiddling.
* getpayloadf: (libc)FP Bit Twiddling.
* getpayloadfN: (libc)FP Bit Twiddling.
* getpayloadfNx: (libc)FP Bit Twiddling.
* getpayloadl: (libc)FP Bit Twiddling.
* getpeername: (libc)Who is Connected.
* getpgid: (libc)Process Group Functions.
* getpgrp: (libc)Process Group Functions.
* getpid: (libc)Process Identification.
* getppid: (libc)Process Identification.
* getpriority: (libc)Traditional Scheduling Functions.
* getprotobyname: (libc)Protocols Database.
* getprotobynumber: (libc)Protocols Database.
* getprotoent: (libc)Protocols Database.
* getpt: (libc)Allocation.
* getpwent: (libc)Scanning All Users.
* getpwent_r: (libc)Scanning All Users.
* getpwnam: (libc)Lookup User.
* getpwnam_r: (libc)Lookup User.
* getpwuid: (libc)Lookup User.
* getpwuid_r: (libc)Lookup User.
* getrandom: (libc)Unpredictable Bytes.
* getrlimit64: (libc)Limits on Resources.
* getrlimit: (libc)Limits on Resources.
* getrusage: (libc)Resource Usage.
* gets: (libc)Line Input.
* getservbyname: (libc)Services Database.
* getservbyport: (libc)Services Database.
* getservent: (libc)Services Database.
* getsid: (libc)Process Group Functions.
* getsockname: (libc)Reading Address.
* getsockopt: (libc)Socket Option Functions.
* getsubopt: (libc)Suboptions.
* gettext: (libc)Translation with gettext.
* gettid: (libc)Process Identification.
* gettimeofday: (libc)High-Resolution Calendar.
* getuid: (libc)Reading Persona.
* getumask: (libc)Setting Permissions.
* getutent: (libc)Manipulating the Database.
* getutent_r: (libc)Manipulating the Database.
* getutid: (libc)Manipulating the Database.
* getutid_r: (libc)Manipulating the Database.
* getutline: (libc)Manipulating the Database.
* getutline_r: (libc)Manipulating the Database.
* getutmp: (libc)XPG Functions.
* getutmpx: (libc)XPG Functions.
* getutxent: (libc)XPG Functions.
* getutxid: (libc)XPG Functions.
* getutxline: (libc)XPG Functions.
* getw: (libc)Character Input.
* getwc: (libc)Character Input.
* getwc_unlocked: (libc)Character Input.
* getwchar: (libc)Character Input.
* getwchar_unlocked: (libc)Character Input.
* getwd: (libc)Working Directory.
* glob64: (libc)Calling Glob.
* glob: (libc)Calling Glob.
* globfree64: (libc)More Flags for Globbing.
* globfree: (libc)More Flags for Globbing.
* gmtime: (libc)Broken-down Time.
* gmtime_r: (libc)Broken-down Time.
* grantpt: (libc)Allocation.
* gsignal: (libc)Signaling Yourself.
* gtty: (libc)BSD Terminal Modes.
* hasmntopt: (libc)mtab.
* hcreate: (libc)Hash Search Function.
* hcreate_r: (libc)Hash Search Function.
* hdestroy: (libc)Hash Search Function.
* hdestroy_r: (libc)Hash Search Function.
* hsearch: (libc)Hash Search Function.
* hsearch_r: (libc)Hash Search Function.
* htonl: (libc)Byte Order.
* htons: (libc)Byte Order.
* hypot: (libc)Exponents and Logarithms.
* hypotf: (libc)Exponents and Logarithms.
* hypotfN: (libc)Exponents and Logarithms.
* hypotfNx: (libc)Exponents and Logarithms.
* hypotl: (libc)Exponents and Logarithms.
* iconv: (libc)Generic Conversion Interface.
* iconv_close: (libc)Generic Conversion Interface.
* iconv_open: (libc)Generic Conversion Interface.
* if_freenameindex: (libc)Interface Naming.
* if_indextoname: (libc)Interface Naming.
* if_nameindex: (libc)Interface Naming.
* if_nametoindex: (libc)Interface Naming.
* ilogb: (libc)Exponents and Logarithms.
* ilogbf: (libc)Exponents and Logarithms.
* ilogbfN: (libc)Exponents and Logarithms.
* ilogbfNx: (libc)Exponents and Logarithms.
* ilogbl: (libc)Exponents and Logarithms.
* imaxabs: (libc)Absolute Value.
* imaxdiv: (libc)Integer Division.
* in6addr_any: (libc)Host Address Data Type.
* in6addr_loopback: (libc)Host Address Data Type.
* index: (libc)Search Functions.
* inet_addr: (libc)Host Address Functions.
* inet_aton: (libc)Host Address Functions.
* inet_lnaof: (libc)Host Address Functions.
* inet_makeaddr: (libc)Host Address Functions.
* inet_netof: (libc)Host Address Functions.
* inet_network: (libc)Host Address Functions.
* inet_ntoa: (libc)Host Address Functions.
* inet_ntop: (libc)Host Address Functions.
* inet_pton: (libc)Host Address Functions.
* initgroups: (libc)Setting Groups.
* initstate: (libc)BSD Random.
* initstate_r: (libc)BSD Random.
* innetgr: (libc)Netgroup Membership.
* ioctl: (libc)IOCTLs.
* isalnum: (libc)Classification of Characters.
* isalpha: (libc)Classification of Characters.
* isascii: (libc)Classification of Characters.
* isatty: (libc)Is It a Terminal.
* isblank: (libc)Classification of Characters.
* iscanonical: (libc)Floating Point Classes.
* iscntrl: (libc)Classification of Characters.
* isdigit: (libc)Classification of Characters.
* iseqsig: (libc)FP Comparison Functions.
* isfinite: (libc)Floating Point Classes.
* isgraph: (libc)Classification of Characters.
* isgreater: (libc)FP Comparison Functions.
* isgreaterequal: (libc)FP Comparison Functions.
* isinf: (libc)Floating Point Classes.
* isinff: (libc)Floating Point Classes.
* isinfl: (libc)Floating Point Classes.
* isless: (libc)FP Comparison Functions.
* islessequal: (libc)FP Comparison Functions.
* islessgreater: (libc)FP Comparison Functions.
* islower: (libc)Classification of Characters.
* isnan: (libc)Floating Point Classes.
* isnan: (libc)Floating Point Classes.
* isnanf: (libc)Floating Point Classes.
* isnanl: (libc)Floating Point Classes.
* isnormal: (libc)Floating Point Classes.
* isprint: (libc)Classification of Characters.
* ispunct: (libc)Classification of Characters.
* issignaling: (libc)Floating Point Classes.
* isspace: (libc)Classification of Characters.
* issubnormal: (libc)Floating Point Classes.
* isunordered: (libc)FP Comparison Functions.
* isupper: (libc)Classification of Characters.
* iswalnum: (libc)Classification of Wide Characters.
* iswalpha: (libc)Classification of Wide Characters.
* iswblank: (libc)Classification of Wide Characters.
* iswcntrl: (libc)Classification of Wide Characters.
* iswctype: (libc)Classification of Wide Characters.
* iswdigit: (libc)Classification of Wide Characters.
* iswgraph: (libc)Classification of Wide Characters.
* iswlower: (libc)Classification of Wide Characters.
* iswprint: (libc)Classification of Wide Characters.
* iswpunct: (libc)Classification of Wide Characters.
* iswspace: (libc)Classification of Wide Characters.
* iswupper: (libc)Classification of Wide Characters.
* iswxdigit: (libc)Classification of Wide Characters.
* isxdigit: (libc)Classification of Characters.
* iszero: (libc)Floating Point Classes.
* j0: (libc)Special Functions.
* j0f: (libc)Special Functions.
* j0fN: (libc)Special Functions.
* j0fNx: (libc)Special Functions.
* j0l: (libc)Special Functions.
* j1: (libc)Special Functions.
* j1f: (libc)Special Functions.
* j1fN: (libc)Special Functions.
* j1fNx: (libc)Special Functions.
* j1l: (libc)Special Functions.
* jn: (libc)Special Functions.
* jnf: (libc)Special Functions.
* jnfN: (libc)Special Functions.
* jnfNx: (libc)Special Functions.
* jnl: (libc)Special Functions.
* jrand48: (libc)SVID Random.
* jrand48_r: (libc)SVID Random.
* kill: (libc)Signaling Another Process.
* killpg: (libc)Signaling Another Process.
* l64a: (libc)Encode Binary Data.
* labs: (libc)Absolute Value.
* lcong48: (libc)SVID Random.
* lcong48_r: (libc)SVID Random.
* ldexp: (libc)Normalization Functions.
* ldexpf: (libc)Normalization Functions.
* ldexpfN: (libc)Normalization Functions.
* ldexpfNx: (libc)Normalization Functions.
* ldexpl: (libc)Normalization Functions.
* ldiv: (libc)Integer Division.
* lfind: (libc)Array Search Function.
* lgamma: (libc)Special Functions.
* lgamma_r: (libc)Special Functions.
* lgammaf: (libc)Special Functions.
* lgammafN: (libc)Special Functions.
* lgammafN_r: (libc)Special Functions.
* lgammafNx: (libc)Special Functions.
* lgammafNx_r: (libc)Special Functions.
* lgammaf_r: (libc)Special Functions.
* lgammal: (libc)Special Functions.
* lgammal_r: (libc)Special Functions.
* link: (libc)Hard Links.
* linkat: (libc)Hard Links.
* lio_listio64: (libc)Asynchronous Reads/Writes.
* lio_listio: (libc)Asynchronous Reads/Writes.
* listen: (libc)Listening.
* llabs: (libc)Absolute Value.
* lldiv: (libc)Integer Division.
* llogb: (libc)Exponents and Logarithms.
* llogbf: (libc)Exponents and Logarithms.
* llogbfN: (libc)Exponents and Logarithms.
* llogbfNx: (libc)Exponents and Logarithms.
* llogbl: (libc)Exponents and Logarithms.
* llrint: (libc)Rounding Functions.
* llrintf: (libc)Rounding Functions.
* llrintfN: (libc)Rounding Functions.
* llrintfNx: (libc)Rounding Functions.
* llrintl: (libc)Rounding Functions.
* llround: (libc)Rounding Functions.
* llroundf: (libc)Rounding Functions.
* llroundfN: (libc)Rounding Functions.
* llroundfNx: (libc)Rounding Functions.
* llroundl: (libc)Rounding Functions.
* localeconv: (libc)The Lame Way to Locale Data.
* localtime: (libc)Broken-down Time.
* localtime_r: (libc)Broken-down Time.
* log10: (libc)Exponents and Logarithms.
* log10f: (libc)Exponents and Logarithms.
* log10fN: (libc)Exponents and Logarithms.
* log10fNx: (libc)Exponents and Logarithms.
* log10l: (libc)Exponents and Logarithms.
* log1p: (libc)Exponents and Logarithms.
* log1pf: (libc)Exponents and Logarithms.
* log1pfN: (libc)Exponents and Logarithms.
* log1pfNx: (libc)Exponents and Logarithms.
* log1pl: (libc)Exponents and Logarithms.
* log2: (libc)Exponents and Logarithms.
* log2f: (libc)Exponents and Logarithms.
* log2fN: (libc)Exponents and Logarithms.
* log2fNx: (libc)Exponents and Logarithms.
* log2l: (libc)Exponents and Logarithms.
* log: (libc)Exponents and Logarithms.
* logb: (libc)Exponents and Logarithms.
* logbf: (libc)Exponents and Logarithms.
* logbfN: (libc)Exponents and Logarithms.
* logbfNx: (libc)Exponents and Logarithms.
* logbl: (libc)Exponents and Logarithms.
* logf: (libc)Exponents and Logarithms.
* logfN: (libc)Exponents and Logarithms.
* logfNx: (libc)Exponents and Logarithms.
* login: (libc)Logging In and Out.
* login_tty: (libc)Logging In and Out.
* logl: (libc)Exponents and Logarithms.
* logout: (libc)Logging In and Out.
* logwtmp: (libc)Logging In and Out.
* longjmp: (libc)Non-Local Details.
* lrand48: (libc)SVID Random.
* lrand48_r: (libc)SVID Random.
* lrint: (libc)Rounding Functions.
* lrintf: (libc)Rounding Functions.
* lrintfN: (libc)Rounding Functions.
* lrintfNx: (libc)Rounding Functions.
* lrintl: (libc)Rounding Functions.
* lround: (libc)Rounding Functions.
* lroundf: (libc)Rounding Functions.
* lroundfN: (libc)Rounding Functions.
* lroundfNx: (libc)Rounding Functions.
* lroundl: (libc)Rounding Functions.
* lsearch: (libc)Array Search Function.
* lseek64: (libc)File Position Primitive.
* lseek: (libc)File Position Primitive.
* lstat64: (libc)Reading Attributes.
* lstat: (libc)Reading Attributes.
* lutimes: (libc)File Times.
* madvise: (libc)Memory-mapped I/O.
* makecontext: (libc)System V contexts.
* mallinfo: (libc)Statistics of Malloc.
* malloc: (libc)Basic Allocation.
* mallopt: (libc)Malloc Tunable Parameters.
* mblen: (libc)Non-reentrant Character Conversion.
* mbrlen: (libc)Converting a Character.
* mbrtowc: (libc)Converting a Character.
* mbsinit: (libc)Keeping the state.
* mbsnrtowcs: (libc)Converting Strings.
* mbsrtowcs: (libc)Converting Strings.
* mbstowcs: (libc)Non-reentrant String Conversion.
* mbtowc: (libc)Non-reentrant Character Conversion.
* mcheck: (libc)Heap Consistency Checking.
* memalign: (libc)Aligned Memory Blocks.
* memccpy: (libc)Copying Strings and Arrays.
* memchr: (libc)Search Functions.
* memcmp: (libc)String/Array Comparison.
* memcpy: (libc)Copying Strings and Arrays.
* memfd_create: (libc)Memory-mapped I/O.
* memfrob: (libc)Obfuscating Data.
* memmem: (libc)Search Functions.
* memmove: (libc)Copying Strings and Arrays.
* mempcpy: (libc)Copying Strings and Arrays.
* memrchr: (libc)Search Functions.
* memset: (libc)Copying Strings and Arrays.
* mkdir: (libc)Creating Directories.
* mkdtemp: (libc)Temporary Files.
* mkfifo: (libc)FIFO Special Files.
* mknod: (libc)Making Special Files.
* mkstemp: (libc)Temporary Files.
* mktemp: (libc)Temporary Files.
* mktime: (libc)Broken-down Time.
* mlock2: (libc)Page Lock Functions.
* mlock: (libc)Page Lock Functions.
* mlockall: (libc)Page Lock Functions.
* mmap64: (libc)Memory-mapped I/O.
* mmap: (libc)Memory-mapped I/O.
* modf: (libc)Rounding Functions.
* modff: (libc)Rounding Functions.
* modffN: (libc)Rounding Functions.
* modffNx: (libc)Rounding Functions.
* modfl: (libc)Rounding Functions.
* mount: (libc)Mount-Unmount-Remount.
* mprobe: (libc)Heap Consistency Checking.
* mprotect: (libc)Memory Protection.
* mrand48: (libc)SVID Random.
* mrand48_r: (libc)SVID Random.
* mremap: (libc)Memory-mapped I/O.
* msync: (libc)Memory-mapped I/O.
* mtrace: (libc)Tracing malloc.
* mtx_destroy: (libc)ISO C Mutexes.
* mtx_init: (libc)ISO C Mutexes.
* mtx_lock: (libc)ISO C Mutexes.
* mtx_timedlock: (libc)ISO C Mutexes.
* mtx_trylock: (libc)ISO C Mutexes.
* mtx_unlock: (libc)ISO C Mutexes.
* munlock: (libc)Page Lock Functions.
* munlockall: (libc)Page Lock Functions.
* munmap: (libc)Memory-mapped I/O.
* muntrace: (libc)Tracing malloc.
* nan: (libc)FP Bit Twiddling.
* nanf: (libc)FP Bit Twiddling.
* nanfN: (libc)FP Bit Twiddling.
* nanfNx: (libc)FP Bit Twiddling.
* nanl: (libc)FP Bit Twiddling.
* nanosleep: (libc)Sleeping.
* nearbyint: (libc)Rounding Functions.
* nearbyintf: (libc)Rounding Functions.
* nearbyintfN: (libc)Rounding Functions.
* nearbyintfNx: (libc)Rounding Functions.
* nearbyintl: (libc)Rounding Functions.
* nextafter: (libc)FP Bit Twiddling.
* nextafterf: (libc)FP Bit Twiddling.
* nextafterfN: (libc)FP Bit Twiddling.
* nextafterfNx: (libc)FP Bit Twiddling.
* nextafterl: (libc)FP Bit Twiddling.
* nextdown: (libc)FP Bit Twiddling.
* nextdownf: (libc)FP Bit Twiddling.
* nextdownfN: (libc)FP Bit Twiddling.
* nextdownfNx: (libc)FP Bit Twiddling.
* nextdownl: (libc)FP Bit Twiddling.
* nexttoward: (libc)FP Bit Twiddling.
* nexttowardf: (libc)FP Bit Twiddling.
* nexttowardl: (libc)FP Bit Twiddling.
* nextup: (libc)FP Bit Twiddling.
* nextupf: (libc)FP Bit Twiddling.
* nextupfN: (libc)FP Bit Twiddling.
* nextupfNx: (libc)FP Bit Twiddling.
* nextupl: (libc)FP Bit Twiddling.
* nftw64: (libc)Working with Directory Trees.
* nftw: (libc)Working with Directory Trees.
* ngettext: (libc)Advanced gettext functions.
* nice: (libc)Traditional Scheduling Functions.
* nl_langinfo: (libc)The Elegant and Fast Way.
* nrand48: (libc)SVID Random.
* nrand48_r: (libc)SVID Random.
* ntohl: (libc)Byte Order.
* ntohs: (libc)Byte Order.
* ntp_adjtime: (libc)High Accuracy Clock.
* ntp_gettime: (libc)High Accuracy Clock.
* obstack_1grow: (libc)Growing Objects.
* obstack_1grow_fast: (libc)Extra Fast Growing.
* obstack_alignment_mask: (libc)Obstacks Data Alignment.
* obstack_alloc: (libc)Allocation in an Obstack.
* obstack_base: (libc)Status of an Obstack.
* obstack_blank: (libc)Growing Objects.
* obstack_blank_fast: (libc)Extra Fast Growing.
* obstack_chunk_size: (libc)Obstack Chunks.
* obstack_copy0: (libc)Allocation in an Obstack.
* obstack_copy: (libc)Allocation in an Obstack.
* obstack_finish: (libc)Growing Objects.
* obstack_free: (libc)Freeing Obstack Objects.
* obstack_grow0: (libc)Growing Objects.
* obstack_grow: (libc)Growing Objects.
* obstack_init: (libc)Preparing for Obstacks.
* obstack_int_grow: (libc)Growing Objects.
* obstack_int_grow_fast: (libc)Extra Fast Growing.
* obstack_next_free: (libc)Status of an Obstack.
* obstack_object_size: (libc)Growing Objects.
* obstack_object_size: (libc)Status of an Obstack.
* obstack_printf: (libc)Dynamic Output.
* obstack_ptr_grow: (libc)Growing Objects.
* obstack_ptr_grow_fast: (libc)Extra Fast Growing.
* obstack_room: (libc)Extra Fast Growing.
* obstack_vprintf: (libc)Variable Arguments Output.
* offsetof: (libc)Structure Measurement.
* on_exit: (libc)Cleanups on Exit.
* open64: (libc)Opening and Closing Files.
* open: (libc)Opening and Closing Files.
* open_memstream: (libc)String Streams.
* opendir: (libc)Opening a Directory.
* openlog: (libc)openlog.
* openpty: (libc)Pseudo-Terminal Pairs.
* parse_printf_format: (libc)Parsing a Template String.
* pathconf: (libc)Pathconf.
* pause: (libc)Using Pause.
* pclose: (libc)Pipe to a Subprocess.
* perror: (libc)Error Messages.
* pipe: (libc)Creating a Pipe.
* pkey_alloc: (libc)Memory Protection.
* pkey_free: (libc)Memory Protection.
* pkey_get: (libc)Memory Protection.
* pkey_mprotect: (libc)Memory Protection.
* pkey_set: (libc)Memory Protection.
* popen: (libc)Pipe to a Subprocess.
* posix_fallocate64: (libc)Storage Allocation.
* posix_fallocate: (libc)Storage Allocation.
* posix_memalign: (libc)Aligned Memory Blocks.
* pow: (libc)Exponents and Logarithms.
* powf: (libc)Exponents and Logarithms.
* powfN: (libc)Exponents and Logarithms.
* powfNx: (libc)Exponents and Logarithms.
* powl: (libc)Exponents and Logarithms.
* pread64: (libc)I/O Primitives.
* pread: (libc)I/O Primitives.
* preadv2: (libc)Scatter-Gather.
* preadv64: (libc)Scatter-Gather.
* preadv64v2: (libc)Scatter-Gather.
* preadv: (libc)Scatter-Gather.
* printf: (libc)Formatted Output Functions.
* printf_size: (libc)Predefined Printf Handlers.
* printf_size_info: (libc)Predefined Printf Handlers.
* psignal: (libc)Signal Messages.
* pthread_cond_clockwait: (libc)Default Thread Attributes.
* pthread_getattr_default_np: (libc)Default Thread Attributes.
* pthread_getspecific: (libc)Thread-specific Data.
* pthread_key_create: (libc)Thread-specific Data.
* pthread_key_delete: (libc)Thread-specific Data.
* pthread_rwlock_clockrdlock: (libc)Default Thread Attributes.
* pthread_rwlock_clockwrlock: (libc)Default Thread Attributes.
* pthread_setattr_default_np: (libc)Default Thread Attributes.
* pthread_setspecific: (libc)Thread-specific Data.
* ptsname: (libc)Allocation.
* ptsname_r: (libc)Allocation.
* putc: (libc)Simple Output.
* putc_unlocked: (libc)Simple Output.
* putchar: (libc)Simple Output.
* putchar_unlocked: (libc)Simple Output.
* putenv: (libc)Environment Access.
* putpwent: (libc)Writing a User Entry.
* puts: (libc)Simple Output.
* pututline: (libc)Manipulating the Database.
* pututxline: (libc)XPG Functions.
* putw: (libc)Simple Output.
* putwc: (libc)Simple Output.
* putwc_unlocked: (libc)Simple Output.
* putwchar: (libc)Simple Output.
* putwchar_unlocked: (libc)Simple Output.
* pwrite64: (libc)I/O Primitives.
* pwrite: (libc)I/O Primitives.
* pwritev2: (libc)Scatter-Gather.
* pwritev64: (libc)Scatter-Gather.
* pwritev64v2: (libc)Scatter-Gather.
* pwritev: (libc)Scatter-Gather.
* qecvt: (libc)System V Number Conversion.
* qecvt_r: (libc)System V Number Conversion.
* qfcvt: (libc)System V Number Conversion.
* qfcvt_r: (libc)System V Number Conversion.
* qgcvt: (libc)System V Number Conversion.
* qsort: (libc)Array Sort Function.
* raise: (libc)Signaling Yourself.
* rand: (libc)ISO Random.
* rand_r: (libc)ISO Random.
* random: (libc)BSD Random.
* random_r: (libc)BSD Random.
* rawmemchr: (libc)Search Functions.
* read: (libc)I/O Primitives.
* readdir64: (libc)Reading/Closing Directory.
* readdir64_r: (libc)Reading/Closing Directory.
* readdir: (libc)Reading/Closing Directory.
* readdir_r: (libc)Reading/Closing Directory.
* readlink: (libc)Symbolic Links.
* readv: (libc)Scatter-Gather.
* realloc: (libc)Changing Block Size.
* reallocarray: (libc)Changing Block Size.
* realpath: (libc)Symbolic Links.
* recv: (libc)Receiving Data.
* recvfrom: (libc)Receiving Datagrams.
* recvmsg: (libc)Receiving Datagrams.
* regcomp: (libc)POSIX Regexp Compilation.
* regerror: (libc)Regexp Cleanup.
* regexec: (libc)Matching POSIX Regexps.
* regfree: (libc)Regexp Cleanup.
* register_printf_function: (libc)Registering New Conversions.
* remainder: (libc)Remainder Functions.
* remainderf: (libc)Remainder Functions.
* remainderfN: (libc)Remainder Functions.
* remainderfNx: (libc)Remainder Functions.
* remainderl: (libc)Remainder Functions.
* remove: (libc)Deleting Files.
* rename: (libc)Renaming Files.
* rewind: (libc)File Positioning.
* rewinddir: (libc)Random Access Directory.
* rindex: (libc)Search Functions.
* rint: (libc)Rounding Functions.
* rintf: (libc)Rounding Functions.
* rintfN: (libc)Rounding Functions.
* rintfNx: (libc)Rounding Functions.
* rintl: (libc)Rounding Functions.
* rmdir: (libc)Deleting Files.
* round: (libc)Rounding Functions.
* roundeven: (libc)Rounding Functions.
* roundevenf: (libc)Rounding Functions.
* roundevenfN: (libc)Rounding Functions.
* roundevenfNx: (libc)Rounding Functions.
* roundevenl: (libc)Rounding Functions.
* roundf: (libc)Rounding Functions.
* roundfN: (libc)Rounding Functions.
* roundfNx: (libc)Rounding Functions.
* roundl: (libc)Rounding Functions.
* rpmatch: (libc)Yes-or-No Questions.
* sbrk: (libc)Resizing the Data Segment.
* scalb: (libc)Normalization Functions.
* scalbf: (libc)Normalization Functions.
* scalbl: (libc)Normalization Functions.
* scalbln: (libc)Normalization Functions.
* scalblnf: (libc)Normalization Functions.
* scalblnfN: (libc)Normalization Functions.
* scalblnfNx: (libc)Normalization Functions.
* scalblnl: (libc)Normalization Functions.
* scalbn: (libc)Normalization Functions.
* scalbnf: (libc)Normalization Functions.
* scalbnfN: (libc)Normalization Functions.
* scalbnfNx: (libc)Normalization Functions.
* scalbnl: (libc)Normalization Functions.
* scandir64: (libc)Scanning Directory Content.
* scandir: (libc)Scanning Directory Content.
* scanf: (libc)Formatted Input Functions.
* sched_get_priority_max: (libc)Basic Scheduling Functions.
* sched_get_priority_min: (libc)Basic Scheduling Functions.
* sched_getaffinity: (libc)CPU Affinity.
* sched_getparam: (libc)Basic Scheduling Functions.
* sched_getscheduler: (libc)Basic Scheduling Functions.
* sched_rr_get_interval: (libc)Basic Scheduling Functions.
* sched_setaffinity: (libc)CPU Affinity.
* sched_setparam: (libc)Basic Scheduling Functions.
* sched_setscheduler: (libc)Basic Scheduling Functions.
* sched_yield: (libc)Basic Scheduling Functions.
* secure_getenv: (libc)Environment Access.
* seed48: (libc)SVID Random.
* seed48_r: (libc)SVID Random.
* seekdir: (libc)Random Access Directory.
* select: (libc)Waiting for I/O.
* sem_clockwait: (libc)Default Thread Attributes.
* sem_close: (libc)Semaphores.
* sem_destroy: (libc)Semaphores.
* sem_getvalue: (libc)Semaphores.
* sem_init: (libc)Semaphores.
* sem_open: (libc)Semaphores.
* sem_post: (libc)Semaphores.
* sem_timedwait: (libc)Semaphores.
* sem_trywait: (libc)Semaphores.
* sem_unlink: (libc)Semaphores.
* sem_wait: (libc)Semaphores.
* semctl: (libc)Semaphores.
* semget: (libc)Semaphores.
* semop: (libc)Semaphores.
* semtimedop: (libc)Semaphores.
* send: (libc)Sending Data.
* sendmsg: (libc)Receiving Datagrams.
* sendto: (libc)Sending Datagrams.
* setbuf: (libc)Controlling Buffering.
* setbuffer: (libc)Controlling Buffering.
* setcontext: (libc)System V contexts.
* setdomainname: (libc)Host Identification.
* setegid: (libc)Setting Groups.
* setenv: (libc)Environment Access.
* seteuid: (libc)Setting User ID.
* setfsent: (libc)fstab.
* setgid: (libc)Setting Groups.
* setgrent: (libc)Scanning All Groups.
* setgroups: (libc)Setting Groups.
* sethostent: (libc)Host Names.
* sethostid: (libc)Host Identification.
* sethostname: (libc)Host Identification.
* setitimer: (libc)Setting an Alarm.
* setjmp: (libc)Non-Local Details.
* setlinebuf: (libc)Controlling Buffering.
* setlocale: (libc)Setting the Locale.
* setlogmask: (libc)setlogmask.
* setmntent: (libc)mtab.
* setnetent: (libc)Networks Database.
* setnetgrent: (libc)Lookup Netgroup.
* setpayload: (libc)FP Bit Twiddling.
* setpayloadf: (libc)FP Bit Twiddling.
* setpayloadfN: (libc)FP Bit Twiddling.
* setpayloadfNx: (libc)FP Bit Twiddling.
* setpayloadl: (libc)FP Bit Twiddling.
* setpayloadsig: (libc)FP Bit Twiddling.
* setpayloadsigf: (libc)FP Bit Twiddling.
* setpayloadsigfN: (libc)FP Bit Twiddling.
* setpayloadsigfNx: (libc)FP Bit Twiddling.
* setpayloadsigl: (libc)FP Bit Twiddling.
* setpgid: (libc)Process Group Functions.
* setpgrp: (libc)Process Group Functions.
* setpriority: (libc)Traditional Scheduling Functions.
* setprotoent: (libc)Protocols Database.
* setpwent: (libc)Scanning All Users.
* setregid: (libc)Setting Groups.
* setreuid: (libc)Setting User ID.
* setrlimit64: (libc)Limits on Resources.
* setrlimit: (libc)Limits on Resources.
* setservent: (libc)Services Database.
* setsid: (libc)Process Group Functions.
* setsockopt: (libc)Socket Option Functions.
* setstate: (libc)BSD Random.
* setstate_r: (libc)BSD Random.
* settimeofday: (libc)High-Resolution Calendar.
* setuid: (libc)Setting User ID.
* setutent: (libc)Manipulating the Database.
* setutxent: (libc)XPG Functions.
* setvbuf: (libc)Controlling Buffering.
* shm_open: (libc)Memory-mapped I/O.
* shm_unlink: (libc)Memory-mapped I/O.
* shutdown: (libc)Closing a Socket.
* sigaction: (libc)Advanced Signal Handling.
* sigaddset: (libc)Signal Sets.
* sigaltstack: (libc)Signal Stack.
* sigblock: (libc)BSD Signal Handling.
* sigdelset: (libc)Signal Sets.
* sigemptyset: (libc)Signal Sets.
* sigfillset: (libc)Signal Sets.
* siginterrupt: (libc)BSD Signal Handling.
* sigismember: (libc)Signal Sets.
* siglongjmp: (libc)Non-Local Exits and Signals.
* sigmask: (libc)BSD Signal Handling.
* signal: (libc)Basic Signal Handling.
* signbit: (libc)FP Bit Twiddling.
* significand: (libc)Normalization Functions.
* significandf: (libc)Normalization Functions.
* significandl: (libc)Normalization Functions.
* sigpause: (libc)BSD Signal Handling.
* sigpending: (libc)Checking for Pending Signals.
* sigprocmask: (libc)Process Signal Mask.
* sigsetjmp: (libc)Non-Local Exits and Signals.
* sigsetmask: (libc)BSD Signal Handling.
* sigstack: (libc)Signal Stack.
* sigsuspend: (libc)Sigsuspend.
* sin: (libc)Trig Functions.
* sincos: (libc)Trig Functions.
* sincosf: (libc)Trig Functions.
* sincosfN: (libc)Trig Functions.
* sincosfNx: (libc)Trig Functions.
* sincosl: (libc)Trig Functions.
* sinf: (libc)Trig Functions.
* sinfN: (libc)Trig Functions.
* sinfNx: (libc)Trig Functions.
* sinh: (libc)Hyperbolic Functions.
* sinhf: (libc)Hyperbolic Functions.
* sinhfN: (libc)Hyperbolic Functions.
* sinhfNx: (libc)Hyperbolic Functions.
* sinhl: (libc)Hyperbolic Functions.
* sinl: (libc)Trig Functions.
* sleep: (libc)Sleeping.
* snprintf: (libc)Formatted Output Functions.
* socket: (libc)Creating a Socket.
* socketpair: (libc)Socket Pairs.
* sprintf: (libc)Formatted Output Functions.
* sqrt: (libc)Exponents and Logarithms.
* sqrtf: (libc)Exponents and Logarithms.
* sqrtfN: (libc)Exponents and Logarithms.
* sqrtfNx: (libc)Exponents and Logarithms.
* sqrtl: (libc)Exponents and Logarithms.
* srand48: (libc)SVID Random.
* srand48_r: (libc)SVID Random.
* srand: (libc)ISO Random.
* srandom: (libc)BSD Random.
* srandom_r: (libc)BSD Random.
* sscanf: (libc)Formatted Input Functions.
* ssignal: (libc)Basic Signal Handling.
* stat64: (libc)Reading Attributes.
* stat: (libc)Reading Attributes.
* stime: (libc)Simple Calendar Time.
* stpcpy: (libc)Copying Strings and Arrays.
* stpncpy: (libc)Truncating Strings.
* strcasecmp: (libc)String/Array Comparison.
* strcasestr: (libc)Search Functions.
* strcat: (libc)Concatenating Strings.
* strchr: (libc)Search Functions.
* strchrnul: (libc)Search Functions.
* strcmp: (libc)String/Array Comparison.
* strcoll: (libc)Collation Functions.
* strcpy: (libc)Copying Strings and Arrays.
* strcspn: (libc)Search Functions.
* strdup: (libc)Copying Strings and Arrays.
* strdupa: (libc)Copying Strings and Arrays.
* strerror: (libc)Error Messages.
* strerror_r: (libc)Error Messages.
* strfmon: (libc)Formatting Numbers.
* strfromd: (libc)Printing of Floats.
* strfromf: (libc)Printing of Floats.
* strfromfN: (libc)Printing of Floats.
* strfromfNx: (libc)Printing of Floats.
* strfroml: (libc)Printing of Floats.
* strfry: (libc)Shuffling Bytes.
* strftime: (libc)Formatting Calendar Time.
* strlen: (libc)String Length.
* strncasecmp: (libc)String/Array Comparison.
* strncat: (libc)Truncating Strings.
* strncmp: (libc)String/Array Comparison.
* strncpy: (libc)Truncating Strings.
* strndup: (libc)Truncating Strings.
* strndupa: (libc)Truncating Strings.
* strnlen: (libc)String Length.
* strpbrk: (libc)Search Functions.
* strptime: (libc)Low-Level Time String Parsing.
* strrchr: (libc)Search Functions.
* strsep: (libc)Finding Tokens in a String.
* strsignal: (libc)Signal Messages.
* strspn: (libc)Search Functions.
* strstr: (libc)Search Functions.
* strtod: (libc)Parsing of Floats.
* strtof: (libc)Parsing of Floats.
* strtofN: (libc)Parsing of Floats.
* strtofNx: (libc)Parsing of Floats.
* strtoimax: (libc)Parsing of Integers.
* strtok: (libc)Finding Tokens in a String.
* strtok_r: (libc)Finding Tokens in a String.
* strtol: (libc)Parsing of Integers.
* strtold: (libc)Parsing of Floats.
* strtoll: (libc)Parsing of Integers.
* strtoq: (libc)Parsing of Integers.
* strtoul: (libc)Parsing of Integers.
* strtoull: (libc)Parsing of Integers.
* strtoumax: (libc)Parsing of Integers.
* strtouq: (libc)Parsing of Integers.
* strverscmp: (libc)String/Array Comparison.
* strxfrm: (libc)Collation Functions.
* stty: (libc)BSD Terminal Modes.
* swapcontext: (libc)System V contexts.
* swprintf: (libc)Formatted Output Functions.
* swscanf: (libc)Formatted Input Functions.
* symlink: (libc)Symbolic Links.
* sync: (libc)Synchronizing I/O.
* syscall: (libc)System Calls.
* sysconf: (libc)Sysconf Definition.
* sysctl: (libc)System Parameters.
* syslog: (libc)syslog; vsyslog.
* system: (libc)Running a Command.
* sysv_signal: (libc)Basic Signal Handling.
* tan: (libc)Trig Functions.
* tanf: (libc)Trig Functions.
* tanfN: (libc)Trig Functions.
* tanfNx: (libc)Trig Functions.
* tanh: (libc)Hyperbolic Functions.
* tanhf: (libc)Hyperbolic Functions.
* tanhfN: (libc)Hyperbolic Functions.
* tanhfNx: (libc)Hyperbolic Functions.
* tanhl: (libc)Hyperbolic Functions.
* tanl: (libc)Trig Functions.
* tcdrain: (libc)Line Control.
* tcflow: (libc)Line Control.
* tcflush: (libc)Line Control.
* tcgetattr: (libc)Mode Functions.
* tcgetpgrp: (libc)Terminal Access Functions.
* tcgetsid: (libc)Terminal Access Functions.
* tcsendbreak: (libc)Line Control.
* tcsetattr: (libc)Mode Functions.
* tcsetpgrp: (libc)Terminal Access Functions.
* tdelete: (libc)Tree Search Function.
* tdestroy: (libc)Tree Search Function.
* telldir: (libc)Random Access Directory.
* tempnam: (libc)Temporary Files.
* textdomain: (libc)Locating gettext catalog.
* tfind: (libc)Tree Search Function.
* tgamma: (libc)Special Functions.
* tgammaf: (libc)Special Functions.
* tgammafN: (libc)Special Functions.
* tgammafNx: (libc)Special Functions.
* tgammal: (libc)Special Functions.
* tgkill: (libc)Signaling Another Process.
* thrd_create: (libc)ISO C Thread Management.
* thrd_current: (libc)ISO C Thread Management.
* thrd_detach: (libc)ISO C Thread Management.
* thrd_equal: (libc)ISO C Thread Management.
* thrd_exit: (libc)ISO C Thread Management.
* thrd_join: (libc)ISO C Thread Management.
* thrd_sleep: (libc)ISO C Thread Management.
* thrd_yield: (libc)ISO C Thread Management.
* time: (libc)Simple Calendar Time.
* timegm: (libc)Broken-down Time.
* timelocal: (libc)Broken-down Time.
* times: (libc)Processor Time.
* tmpfile64: (libc)Temporary Files.
* tmpfile: (libc)Temporary Files.
* tmpnam: (libc)Temporary Files.
* tmpnam_r: (libc)Temporary Files.
* toascii: (libc)Case Conversion.
* tolower: (libc)Case Conversion.
* totalorder: (libc)FP Comparison Functions.
* totalorderf: (libc)FP Comparison Functions.
* totalorderfN: (libc)FP Comparison Functions.
* totalorderfNx: (libc)FP Comparison Functions.
* totalorderl: (libc)FP Comparison Functions.
* totalordermag: (libc)FP Comparison Functions.
* totalordermagf: (libc)FP Comparison Functions.
* totalordermagfN: (libc)FP Comparison Functions.
* totalordermagfNx: (libc)FP Comparison Functions.
* totalordermagl: (libc)FP Comparison Functions.
* toupper: (libc)Case Conversion.
* towctrans: (libc)Wide Character Case Conversion.
* towlower: (libc)Wide Character Case Conversion.
* towupper: (libc)Wide Character Case Conversion.
* trunc: (libc)Rounding Functions.
* truncate64: (libc)File Size.
* truncate: (libc)File Size.
* truncf: (libc)Rounding Functions.
* truncfN: (libc)Rounding Functions.
* truncfNx: (libc)Rounding Functions.
* truncl: (libc)Rounding Functions.
* tsearch: (libc)Tree Search Function.
* tss_create: (libc)ISO C Thread-local Storage.
* tss_delete: (libc)ISO C Thread-local Storage.
* tss_get: (libc)ISO C Thread-local Storage.
* tss_set: (libc)ISO C Thread-local Storage.
* ttyname: (libc)Is It a Terminal.
* ttyname_r: (libc)Is It a Terminal.
* twalk: (libc)Tree Search Function.
* twalk_r: (libc)Tree Search Function.
* tzset: (libc)Time Zone Functions.
* ufromfp: (libc)Rounding Functions.
* ufromfpf: (libc)Rounding Functions.
* ufromfpfN: (libc)Rounding Functions.
* ufromfpfNx: (libc)Rounding Functions.
* ufromfpl: (libc)Rounding Functions.
* ufromfpx: (libc)Rounding Functions.
* ufromfpxf: (libc)Rounding Functions.
* ufromfpxfN: (libc)Rounding Functions.
* ufromfpxfNx: (libc)Rounding Functions.
* ufromfpxl: (libc)Rounding Functions.
* ulimit: (libc)Limits on Resources.
* umask: (libc)Setting Permissions.
* umount2: (libc)Mount-Unmount-Remount.
* umount: (libc)Mount-Unmount-Remount.
* uname: (libc)Platform Type.
* ungetc: (libc)How Unread.
* ungetwc: (libc)How Unread.
* unlink: (libc)Deleting Files.
* unlockpt: (libc)Allocation.
* unsetenv: (libc)Environment Access.
* updwtmp: (libc)Manipulating the Database.
* utime: (libc)File Times.
* utimes: (libc)File Times.
* utmpname: (libc)Manipulating the Database.
* utmpxname: (libc)XPG Functions.
* va_arg: (libc)Argument Macros.
* va_copy: (libc)Argument Macros.
* va_end: (libc)Argument Macros.
* va_start: (libc)Argument Macros.
* valloc: (libc)Aligned Memory Blocks.
* vasprintf: (libc)Variable Arguments Output.
* verr: (libc)Error Messages.
* verrx: (libc)Error Messages.
* versionsort64: (libc)Scanning Directory Content.
* versionsort: (libc)Scanning Directory Content.
* vfork: (libc)Creating a Process.
* vfprintf: (libc)Variable Arguments Output.
* vfscanf: (libc)Variable Arguments Input.
* vfwprintf: (libc)Variable Arguments Output.
* vfwscanf: (libc)Variable Arguments Input.
* vlimit: (libc)Limits on Resources.
* vprintf: (libc)Variable Arguments Output.
* vscanf: (libc)Variable Arguments Input.
* vsnprintf: (libc)Variable Arguments Output.
* vsprintf: (libc)Variable Arguments Output.
* vsscanf: (libc)Variable Arguments Input.
* vswprintf: (libc)Variable Arguments Output.
* vswscanf: (libc)Variable Arguments Input.
* vsyslog: (libc)syslog; vsyslog.
* vtimes: (libc)Resource Usage.
* vwarn: (libc)Error Messages.
* vwarnx: (libc)Error Messages.
* vwprintf: (libc)Variable Arguments Output.
* vwscanf: (libc)Variable Arguments Input.
* wait3: (libc)BSD Wait Functions.
* wait4: (libc)Process Completion.
* wait: (libc)Process Completion.
* waitpid: (libc)Process Completion.
* warn: (libc)Error Messages.
* warnx: (libc)Error Messages.
* wcpcpy: (libc)Copying Strings and Arrays.
* wcpncpy: (libc)Truncating Strings.
* wcrtomb: (libc)Converting a Character.
* wcscasecmp: (libc)String/Array Comparison.
* wcscat: (libc)Concatenating Strings.
* wcschr: (libc)Search Functions.
* wcschrnul: (libc)Search Functions.
* wcscmp: (libc)String/Array Comparison.
* wcscoll: (libc)Collation Functions.
* wcscpy: (libc)Copying Strings and Arrays.
* wcscspn: (libc)Search Functions.
* wcsdup: (libc)Copying Strings and Arrays.
* wcsftime: (libc)Formatting Calendar Time.
* wcslen: (libc)String Length.
* wcsncasecmp: (libc)String/Array Comparison.
* wcsncat: (libc)Truncating Strings.
* wcsncmp: (libc)String/Array Comparison.
* wcsncpy: (libc)Truncating Strings.
* wcsnlen: (libc)String Length.
* wcsnrtombs: (libc)Converting Strings.
* wcspbrk: (libc)Search Functions.
* wcsrchr: (libc)Search Functions.
* wcsrtombs: (libc)Converting Strings.
* wcsspn: (libc)Search Functions.
* wcsstr: (libc)Search Functions.
* wcstod: (libc)Parsing of Floats.
* wcstof: (libc)Parsing of Floats.
* wcstofN: (libc)Parsing of Floats.
* wcstofNx: (libc)Parsing of Floats.
* wcstoimax: (libc)Parsing of Integers.
* wcstok: (libc)Finding Tokens in a String.
* wcstol: (libc)Parsing of Integers.
* wcstold: (libc)Parsing of Floats.
* wcstoll: (libc)Parsing of Integers.
* wcstombs: (libc)Non-reentrant String Conversion.
* wcstoq: (libc)Parsing of Integers.
* wcstoul: (libc)Parsing of Integers.
* wcstoull: (libc)Parsing of Integers.
* wcstoumax: (libc)Parsing of Integers.
* wcstouq: (libc)Parsing of Integers.
* wcswcs: (libc)Search Functions.
* wcsxfrm: (libc)Collation Functions.
* wctob: (libc)Converting a Character.
* wctomb: (libc)Non-reentrant Character Conversion.
* wctrans: (libc)Wide Character Case Conversion.
* wctype: (libc)Classification of Wide Characters.
* wmemchr: (libc)Search Functions.
* wmemcmp: (libc)String/Array Comparison.
* wmemcpy: (libc)Copying Strings and Arrays.
* wmemmove: (libc)Copying Strings and Arrays.
* wmempcpy: (libc)Copying Strings and Arrays.
* wmemset: (libc)Copying Strings and Arrays.
* wordexp: (libc)Calling Wordexp.
* wordfree: (libc)Calling Wordexp.
* wprintf: (libc)Formatted Output Functions.
* write: (libc)I/O Primitives.
* writev: (libc)Scatter-Gather.
* wscanf: (libc)Formatted Input Functions.
* y0: (libc)Special Functions.
* y0f: (libc)Special Functions.
* y0fN: (libc)Special Functions.
* y0fNx: (libc)Special Functions.
* y0l: (libc)Special Functions.
* y1: (libc)Special Functions.
* y1f: (libc)Special Functions.
* y1fN: (libc)Special Functions.
* y1fNx: (libc)Special Functions.
* y1l: (libc)Special Functions.
* yn: (libc)Special Functions.
* ynf: (libc)Special Functions.
* ynfN: (libc)Special Functions.
* ynfNx: (libc)Special Functions.
* ynl: (libc)Special Functions.
END-INFO-DIR-ENTRY


File: libc.info,  Node: Hooks for Malloc,  Next: Statistics of Malloc,  Prev: Heap Consistency Checking,  Up: Unconstrained Allocation

3.2.3.9 Memory Allocation Hooks
...............................

The GNU C Library lets you modify the behavior of ‘malloc’, ‘realloc’,
and ‘free’ by specifying appropriate hook functions.  You can use these
hooks to help you debug programs that use dynamic memory allocation, for
example.

   The hook variables are declared in ‘malloc.h’.

 -- Variable: __malloc_hook

     The value of this variable is a pointer to the function that
     ‘malloc’ uses whenever it is called.  You should define this
     function to look like ‘malloc’; that is, like:

          void *FUNCTION (size_t SIZE, const void *CALLER)

     The value of CALLER is the return address found on the stack when
     the ‘malloc’ function was called.  This value allows you to trace
     the memory consumption of the program.

 -- Variable: __realloc_hook

     The value of this variable is a pointer to function that ‘realloc’
     uses whenever it is called.  You should define this function to
     look like ‘realloc’; that is, like:

          void *FUNCTION (void *PTR, size_t SIZE, const void *CALLER)

     The value of CALLER is the return address found on the stack when
     the ‘realloc’ function was called.  This value allows you to trace
     the memory consumption of the program.

 -- Variable: __free_hook

     The value of this variable is a pointer to function that ‘free’
     uses whenever it is called.  You should define this function to
     look like ‘free’; that is, like:

          void FUNCTION (void *PTR, const void *CALLER)

     The value of CALLER is the return address found on the stack when
     the ‘free’ function was called.  This value allows you to trace the
     memory consumption of the program.

 -- Variable: __memalign_hook

     The value of this variable is a pointer to function that
     ‘aligned_alloc’, ‘memalign’, ‘posix_memalign’ and ‘valloc’ use
     whenever they are called.  You should define this function to look
     like ‘aligned_alloc’; that is, like:

          void *FUNCTION (size_t ALIGNMENT, size_t SIZE, const void *CALLER)

     The value of CALLER is the return address found on the stack when
     the ‘aligned_alloc’, ‘memalign’, ‘posix_memalign’ or ‘valloc’
     functions are called.  This value allows you to trace the memory
     consumption of the program.

   You must make sure that the function you install as a hook for one of
these functions does not call that function recursively without
restoring the old value of the hook first!  Otherwise, your program will
get stuck in an infinite recursion.  Before calling the function
recursively, one should make sure to restore all the hooks to their
previous value.  When coming back from the recursive call, all the hooks
should be resaved since a hook might modify itself.

   An issue to look out for is the time at which the malloc hook
functions can be safely installed.  If the hook functions call the
malloc-related functions recursively, it is necessary that malloc has
already properly initialized itself at the time when ‘__malloc_hook’
etc.  is assigned to.  On the other hand, if the hook functions provide
a complete malloc implementation of their own, it is vital that the
hooks are assigned to _before_ the very first ‘malloc’ call has
completed, because otherwise a chunk obtained from the ordinary,
un-hooked malloc may later be handed to ‘__free_hook’, for example.

   Here is an example showing how to use ‘__malloc_hook’ and
‘__free_hook’ properly.  It installs a function that prints out
information every time ‘malloc’ or ‘free’ is called.  We just assume
here that ‘realloc’ and ‘memalign’ are not used in our program.

     /* Prototypes for __malloc_hook, __free_hook */
     #include <malloc.h>

     /* Prototypes for our hooks.  */
     static void my_init_hook (void);
     static void *my_malloc_hook (size_t, const void *);
     static void my_free_hook (void*, const void *);

     static void
     my_init (void)
     {
       old_malloc_hook = __malloc_hook;
       old_free_hook = __free_hook;
       __malloc_hook = my_malloc_hook;
       __free_hook = my_free_hook;
     }

     static void *
     my_malloc_hook (size_t size, const void *caller)
     {
       void *result;
       /* Restore all old hooks */
       __malloc_hook = old_malloc_hook;
       __free_hook = old_free_hook;
       /* Call recursively */
       result = malloc (size);
       /* Save underlying hooks */
       old_malloc_hook = __malloc_hook;
       old_free_hook = __free_hook;
       /* ‘printf’ might call ‘malloc’, so protect it too. */
       printf ("malloc (%u) returns %p\n", (unsigned int) size, result);
       /* Restore our own hooks */
       __malloc_hook = my_malloc_hook;
       __free_hook = my_free_hook;
       return result;
     }

     static void
     my_free_hook (void *ptr, const void *caller)
     {
       /* Restore all old hooks */
       __malloc_hook = old_malloc_hook;
       __free_hook = old_free_hook;
       /* Call recursively */
       free (ptr);
       /* Save underlying hooks */
       old_malloc_hook = __malloc_hook;
       old_free_hook = __free_hook;
       /* ‘printf’ might call ‘free’, so protect it too. */
       printf ("freed pointer %p\n", ptr);
       /* Restore our own hooks */
       __malloc_hook = my_malloc_hook;
       __free_hook = my_free_hook;
     }

     main ()
     {
       my_init ();
       …
     }

   The ‘mcheck’ function (*note Heap Consistency Checking::) works by
installing such hooks.


File: libc.info,  Node: Statistics of Malloc,  Next: Summary of Malloc,  Prev: Hooks for Malloc,  Up: Unconstrained Allocation

3.2.3.10 Statistics for Memory Allocation with ‘malloc’
.......................................................

You can get information about dynamic memory allocation by calling the
‘mallinfo’ function.  This function and its associated data type are
declared in ‘malloc.h’; they are an extension of the standard SVID/XPG
version.

 -- Data Type: struct mallinfo

     This structure type is used to return information about the dynamic
     memory allocator.  It contains the following members:

     ‘int arena’
          This is the total size of memory allocated with ‘sbrk’ by
          ‘malloc’, in bytes.

     ‘int ordblks’
          This is the number of chunks not in use.  (The memory
          allocator internally gets chunks of memory from the operating
          system, and then carves them up to satisfy individual ‘malloc’
          requests; *note The GNU Allocator::.)

     ‘int smblks’
          This field is unused.

     ‘int hblks’
          This is the total number of chunks allocated with ‘mmap’.

     ‘int hblkhd’
          This is the total size of memory allocated with ‘mmap’, in
          bytes.

     ‘int usmblks’
          This field is unused and always 0.

     ‘int fsmblks’
          This field is unused.

     ‘int uordblks’
          This is the total size of memory occupied by chunks handed out
          by ‘malloc’.

     ‘int fordblks’
          This is the total size of memory occupied by free (not in use)
          chunks.

     ‘int keepcost’
          This is the size of the top-most releasable chunk that
          normally borders the end of the heap (i.e., the high end of
          the virtual address space’s data segment).

 -- Function: struct mallinfo mallinfo (void)

     Preliminary: | MT-Unsafe init const:mallopt | AS-Unsafe init lock |
     AC-Unsafe init lock | *Note POSIX Safety Concepts::.

     This function returns information about the current dynamic memory
     usage in a structure of type ‘struct mallinfo’.


File: libc.info,  Node: Summary of Malloc,  Prev: Statistics of Malloc,  Up: Unconstrained Allocation

3.2.3.11 Summary of ‘malloc’-Related Functions
..............................................

Here is a summary of the functions that work with ‘malloc’:

‘void *malloc (size_t SIZE)’
     Allocate a block of SIZE bytes.  *Note Basic Allocation::.

‘void free (void *ADDR)’
     Free a block previously allocated by ‘malloc’.  *Note Freeing after
     Malloc::.

‘void *realloc (void *ADDR, size_t SIZE)’
     Make a block previously allocated by ‘malloc’ larger or smaller,
     possibly by copying it to a new location.  *Note Changing Block
     Size::.

‘void *reallocarray (void *PTR, size_t NMEMB, size_t SIZE)’
     Change the size of a block previously allocated by ‘malloc’ to
     ‘NMEMB * SIZE’ bytes as with ‘realloc’.  *Note Changing Block
     Size::.

‘void *calloc (size_t COUNT, size_t ELTSIZE)’
     Allocate a block of COUNT * ELTSIZE bytes using ‘malloc’, and set
     its contents to zero.  *Note Allocating Cleared Space::.

‘void *valloc (size_t SIZE)’
     Allocate a block of SIZE bytes, starting on a page boundary.  *Note
     Aligned Memory Blocks::.

‘void *aligned_alloc (size_t SIZE, size_t ALIGNMENT)’
     Allocate a block of SIZE bytes, starting on an address that is a
     multiple of ALIGNMENT.  *Note Aligned Memory Blocks::.

‘int posix_memalign (void **MEMPTR, size_t ALIGNMENT, size_t SIZE)’
     Allocate a block of SIZE bytes, starting on an address that is a
     multiple of ALIGNMENT.  *Note Aligned Memory Blocks::.

‘void *memalign (size_t SIZE, size_t BOUNDARY)’
     Allocate a block of SIZE bytes, starting on an address that is a
     multiple of BOUNDARY.  *Note Aligned Memory Blocks::.

‘int mallopt (int PARAM, int VALUE)’
     Adjust a tunable parameter.  *Note Malloc Tunable Parameters::.

‘int mcheck (void (*ABORTFN) (void))’
     Tell ‘malloc’ to perform occasional consistency checks on
     dynamically allocated memory, and to call ABORTFN when an
     inconsistency is found.  *Note Heap Consistency Checking::.

‘void *(*__malloc_hook) (size_t SIZE, const void *CALLER)’
     A pointer to a function that ‘malloc’ uses whenever it is called.

‘void *(*__realloc_hook) (void *PTR, size_t SIZE, const void *CALLER)’
     A pointer to a function that ‘realloc’ uses whenever it is called.

‘void (*__free_hook) (void *PTR, const void *CALLER)’
     A pointer to a function that ‘free’ uses whenever it is called.

‘void (*__memalign_hook) (size_t SIZE, size_t ALIGNMENT, const void *CALLER)’
     A pointer to a function that ‘aligned_alloc’, ‘memalign’,
     ‘posix_memalign’ and ‘valloc’ use whenever they are called.

‘struct mallinfo mallinfo (void)’
     Return information about the current dynamic memory usage.  *Note
     Statistics of Malloc::.


File: libc.info,  Node: Allocation Debugging,  Next: Replacing malloc,  Prev: Unconstrained Allocation,  Up: Memory Allocation

3.2.4 Allocation Debugging
--------------------------

A complicated task when programming with languages which do not use
garbage collected dynamic memory allocation is to find memory leaks.
Long running programs must ensure that dynamically allocated objects are
freed at the end of their lifetime.  If this does not happen the system
runs out of memory, sooner or later.

   The ‘malloc’ implementation in the GNU C Library provides some simple
means to detect such leaks and obtain some information to find the
location.  To do this the application must be started in a special mode
which is enabled by an environment variable.  There are no speed
penalties for the program if the debugging mode is not enabled.

* Menu:

* Tracing malloc::               How to install the tracing functionality.
* Using the Memory Debugger::    Example programs excerpts.
* Tips for the Memory Debugger:: Some more or less clever ideas.
* Interpreting the traces::      What do all these lines mean?


File: libc.info,  Node: Tracing malloc,  Next: Using the Memory Debugger,  Up: Allocation Debugging

3.2.4.1 How to install the tracing functionality
................................................

 -- Function: void mtrace (void)

     Preliminary: | MT-Unsafe env race:mtrace const:malloc_hooks init |
     AS-Unsafe init heap corrupt lock | AC-Unsafe init corrupt lock fd
     mem | *Note POSIX Safety Concepts::.

     When the ‘mtrace’ function is called it looks for an environment
     variable named ‘MALLOC_TRACE’.  This variable is supposed to
     contain a valid file name.  The user must have write access.  If
     the file already exists it is truncated.  If the environment
     variable is not set or it does not name a valid file which can be
     opened for writing nothing is done.  The behavior of ‘malloc’ etc.
     is not changed.  For obvious reasons this also happens if the
     application is installed with the SUID or SGID bit set.

     If the named file is successfully opened, ‘mtrace’ installs special
     handlers for the functions ‘malloc’, ‘realloc’, and ‘free’ (*note
     Hooks for Malloc::).  From then on, all uses of these functions are
     traced and protocolled into the file.  There is now of course a
     speed penalty for all calls to the traced functions so tracing
     should not be enabled during normal use.

     This function is a GNU extension and generally not available on
     other systems.  The prototype can be found in ‘mcheck.h’.

 -- Function: void muntrace (void)

     Preliminary: | MT-Unsafe race:mtrace const:malloc_hooks locale |
     AS-Unsafe corrupt heap | AC-Unsafe corrupt mem lock fd | *Note
     POSIX Safety Concepts::.

     The ‘muntrace’ function can be called after ‘mtrace’ was used to
     enable tracing the ‘malloc’ calls.  If no (successful) call of
     ‘mtrace’ was made ‘muntrace’ does nothing.

     Otherwise it deinstalls the handlers for ‘malloc’, ‘realloc’, and
     ‘free’ and then closes the protocol file.  No calls are protocolled
     anymore and the program runs again at full speed.

     This function is a GNU extension and generally not available on
     other systems.  The prototype can be found in ‘mcheck.h’.


File: libc.info,  Node: Using the Memory Debugger,  Next: Tips for the Memory Debugger,  Prev: Tracing malloc,  Up: Allocation Debugging

3.2.4.2 Example program excerpts
................................

Even though the tracing functionality does not influence the runtime
behavior of the program it is not a good idea to call ‘mtrace’ in all
programs.  Just imagine that you debug a program using ‘mtrace’ and all
other programs used in the debugging session also trace their ‘malloc’
calls.  The output file would be the same for all programs and thus is
unusable.  Therefore one should call ‘mtrace’ only if compiled for
debugging.  A program could therefore start like this:

     #include <mcheck.h>

     int
     main (int argc, char *argv[])
     {
     #ifdef DEBUGGING
       mtrace ();
     #endif
       …
     }

   This is all that is needed if you want to trace the calls during the
whole runtime of the program.  Alternatively you can stop the tracing at
any time with a call to ‘muntrace’.  It is even possible to restart the
tracing again with a new call to ‘mtrace’.  But this can cause
unreliable results since there may be calls of the functions which are
not called.  Please note that not only the application uses the traced
functions, also libraries (including the C library itself) use these
functions.

   This last point is also why it is not a good idea to call ‘muntrace’
before the program terminates.  The libraries are informed about the
termination of the program only after the program returns from ‘main’ or
calls ‘exit’ and so cannot free the memory they use before this time.

   So the best thing one can do is to call ‘mtrace’ as the very first
function in the program and never call ‘muntrace’.  So the program
traces almost all uses of the ‘malloc’ functions (except those calls
which are executed by constructors of the program or used libraries).


File: libc.info,  Node: Tips for the Memory Debugger,  Next: Interpreting the traces,  Prev: Using the Memory Debugger,  Up: Allocation Debugging

3.2.4.3 Some more or less clever ideas
......................................

You know the situation.  The program is prepared for debugging and in
all debugging sessions it runs well.  But once it is started without
debugging the error shows up.  A typical example is a memory leak that
becomes visible only when we turn off the debugging.  If you foresee
such situations you can still win.  Simply use something equivalent to
the following little program:

     #include <mcheck.h>
     #include <signal.h>

     static void
     enable (int sig)
     {
       mtrace ();
       signal (SIGUSR1, enable);
     }

     static void
     disable (int sig)
     {
       muntrace ();
       signal (SIGUSR2, disable);
     }

     int
     main (int argc, char *argv[])
     {
       …

       signal (SIGUSR1, enable);
       signal (SIGUSR2, disable);

       …
     }

   I.e., the user can start the memory debugger any time s/he wants if
the program was started with ‘MALLOC_TRACE’ set in the environment.  The
output will of course not show the allocations which happened before the
first signal but if there is a memory leak this will show up
nevertheless.


File: libc.info,  Node: Interpreting the traces,  Prev: Tips for the Memory Debugger,  Up: Allocation Debugging

3.2.4.4 Interpreting the traces
...............................

If you take a look at the output it will look similar to this:

     = Start
      [0x8048209] - 0x8064cc8
      [0x8048209] - 0x8064ce0
      [0x8048209] - 0x8064cf8
      [0x80481eb] + 0x8064c48 0x14
      [0x80481eb] + 0x8064c60 0x14
      [0x80481eb] + 0x8064c78 0x14
      [0x80481eb] + 0x8064c90 0x14
     = End

   What this all means is not really important since the trace file is
not meant to be read by a human.  Therefore no attention is given to
readability.  Instead there is a program which comes with the GNU C
Library which interprets the traces and outputs a summary in an
user-friendly way.  The program is called ‘mtrace’ (it is in fact a Perl
script) and it takes one or two arguments.  In any case the name of the
file with the trace output must be specified.  If an optional argument
precedes the name of the trace file this must be the name of the program
which generated the trace.

     drepper$ mtrace tst-mtrace log
     No memory leaks.

   In this case the program ‘tst-mtrace’ was run and it produced a trace
file ‘log’.  The message printed by ‘mtrace’ shows there are no problems
with the code, all allocated memory was freed afterwards.

   If we call ‘mtrace’ on the example trace given above we would get a
different outout:

     drepper$ mtrace errlog
     - 0x08064cc8 Free 2 was never alloc'd 0x8048209
     - 0x08064ce0 Free 3 was never alloc'd 0x8048209
     - 0x08064cf8 Free 4 was never alloc'd 0x8048209

     Memory not freed:
     -----------------
        Address     Size     Caller
     0x08064c48     0x14  at 0x80481eb
     0x08064c60     0x14  at 0x80481eb
     0x08064c78     0x14  at 0x80481eb
     0x08064c90     0x14  at 0x80481eb

   We have called ‘mtrace’ with only one argument and so the script has
no chance to find out what is meant with the addresses given in the
trace.  We can do better:

     drepper$ mtrace tst errlog
     - 0x08064cc8 Free 2 was never alloc'd /home/drepper/tst.c:39
     - 0x08064ce0 Free 3 was never alloc'd /home/drepper/tst.c:39
     - 0x08064cf8 Free 4 was never alloc'd /home/drepper/tst.c:39

     Memory not freed:
     -----------------
        Address     Size     Caller
     0x08064c48     0x14  at /home/drepper/tst.c:33
     0x08064c60     0x14  at /home/drepper/tst.c:33
     0x08064c78     0x14  at /home/drepper/tst.c:33
     0x08064c90     0x14  at /home/drepper/tst.c:33

   Suddenly the output makes much more sense and the user can see
immediately where the function calls causing the trouble can be found.

   Interpreting this output is not complicated.  There are at most two
different situations being detected.  First, ‘free’ was called for
pointers which were never returned by one of the allocation functions.
This is usually a very bad problem and what this looks like is shown in
the first three lines of the output.  Situations like this are quite
rare and if they appear they show up very drastically: the program
normally crashes.

   The other situation which is much harder to detect are memory leaks.
As you can see in the output the ‘mtrace’ function collects all this
information and so can say that the program calls an allocation function
from line 33 in the source file ‘/home/drepper/tst-mtrace.c’ four times
without freeing this memory before the program terminates.  Whether this
is a real problem remains to be investigated.


File: libc.info,  Node: Replacing malloc,  Next: Obstacks,  Prev: Allocation Debugging,  Up: Memory Allocation

3.2.5 Replacing ‘malloc’
------------------------

The GNU C Library supports replacing the built-in ‘malloc’
implementation with a different allocator with the same interface.  For
dynamically linked programs, this happens through ELF symbol
interposition, either using shared object dependencies or ‘LD_PRELOAD’.
For static linking, the ‘malloc’ replacement library must be linked in
before linking against ‘libc.a’ (explicitly or implicitly).

   *Note:* Failure to provide a complete set of replacement functions
(that is, all the functions used by the application, the GNU C Library,
and other linked-in libraries) can lead to static linking failures, and,
at run time, to heap corruption and application crashes.

   The minimum set of functions which has to be provided by a custom
‘malloc’ is given in the table below.

‘malloc’
‘free’
‘calloc’
‘realloc’

   These ‘malloc’-related functions are required for the GNU C Library
to work.(1)

   The ‘malloc’ implementation in the GNU C Library provides additional
functionality not used by the library itself, but which is often used by
other system libraries and applications.  A general-purpose replacement
‘malloc’ implementation should provide definitions of these functions,
too.  Their names are listed in the following table.

‘aligned_alloc’
‘malloc_usable_size’
‘memalign’
‘posix_memalign’
‘pvalloc’
‘valloc’

   In addition, very old applications may use the obsolete ‘cfree’
function.

   Further ‘malloc’-related functions such as ‘mallopt’ or ‘mallinfo’
will not have any effect or return incorrect statistics when a
replacement ‘malloc’ is in use.  However, failure to replace these
functions typically does not result in crashes or other incorrect
application behavior, but may result in static linking failures.

   ---------- Footnotes ----------

   (1) Versions of the GNU C Library before 2.25 required that a custom
‘malloc’ defines ‘__libc_memalign’ (with the same interface as the
‘memalign’ function).


File: libc.info,  Node: Obstacks,  Next: Variable Size Automatic,  Prev: Replacing malloc,  Up: Memory Allocation

3.2.6 Obstacks
--------------

An "obstack" is a pool of memory containing a stack of objects.  You can
create any number of separate obstacks, and then allocate objects in
specified obstacks.  Within each obstack, the last object allocated must
always be the first one freed, but distinct obstacks are independent of
each other.

   Aside from this one constraint of order of freeing, obstacks are
totally general: an obstack can contain any number of objects of any
size.  They are implemented with macros, so allocation is usually very
fast as long as the objects are usually small.  And the only space
overhead per object is the padding needed to start each object on a
suitable boundary.

* Menu:

* Creating Obstacks::		How to declare an obstack in your program.
* Preparing for Obstacks::	Preparations needed before you can
				 use obstacks.
* Allocation in an Obstack::    Allocating objects in an obstack.
* Freeing Obstack Objects::     Freeing objects in an obstack.
* Obstack Functions::		The obstack functions are both
				 functions and macros.
* Growing Objects::             Making an object bigger by stages.
* Extra Fast Growing::		Extra-high-efficiency (though more
				 complicated) growing objects.
* Status of an Obstack::        Inquiries about the status of an obstack.
* Obstacks Data Alignment::     Controlling alignment of objects in obstacks.
* Obstack Chunks::              How obstacks obtain and release chunks;
				 efficiency considerations.
* Summary of Obstacks::


File: libc.info,  Node: Creating Obstacks,  Next: Preparing for Obstacks,  Up: Obstacks

3.2.6.1 Creating Obstacks
.........................

The utilities for manipulating obstacks are declared in the header file
‘obstack.h’.

 -- Data Type: struct obstack

     An obstack is represented by a data structure of type ‘struct
     obstack’.  This structure has a small fixed size; it records the
     status of the obstack and how to find the space in which objects
     are allocated.  It does not contain any of the objects themselves.
     You should not try to access the contents of the structure
     directly; use only the functions described in this chapter.

   You can declare variables of type ‘struct obstack’ and use them as
obstacks, or you can allocate obstacks dynamically like any other kind
of object.  Dynamic allocation of obstacks allows your program to have a
variable number of different stacks.  (You can even allocate an obstack
structure in another obstack, but this is rarely useful.)

   All the functions that work with obstacks require you to specify
which obstack to use.  You do this with a pointer of type ‘struct
obstack *’.  In the following, we often say “an obstack” when strictly
speaking the object at hand is such a pointer.

   The objects in the obstack are packed into large blocks called
"chunks".  The ‘struct obstack’ structure points to a chain of the
chunks currently in use.

   The obstack library obtains a new chunk whenever you allocate an
object that won’t fit in the previous chunk.  Since the obstack library
manages chunks automatically, you don’t need to pay much attention to
them, but you do need to supply a function which the obstack library
should use to get a chunk.  Usually you supply a function which uses
‘malloc’ directly or indirectly.  You must also supply a function to
free a chunk.  These matters are described in the following section.


File: libc.info,  Node: Preparing for Obstacks,  Next: Allocation in an Obstack,  Prev: Creating Obstacks,  Up: Obstacks

3.2.6.2 Preparing for Using Obstacks
....................................

Each source file in which you plan to use the obstack functions must
include the header file ‘obstack.h’, like this:

     #include <obstack.h>

   Also, if the source file uses the macro ‘obstack_init’, it must
declare or define two functions or macros that will be called by the
obstack library.  One, ‘obstack_chunk_alloc’, is used to allocate the
chunks of memory into which objects are packed.  The other,
‘obstack_chunk_free’, is used to return chunks when the objects in them
are freed.  These macros should appear before any use of obstacks in the
source file.

   Usually these are defined to use ‘malloc’ via the intermediary
‘xmalloc’ (*note Unconstrained Allocation::).  This is done with the
following pair of macro definitions:

     #define obstack_chunk_alloc xmalloc
     #define obstack_chunk_free free

Though the memory you get using obstacks really comes from ‘malloc’,
using obstacks is faster because ‘malloc’ is called less often, for
larger blocks of memory.  *Note Obstack Chunks::, for full details.

   At run time, before the program can use a ‘struct obstack’ object as
an obstack, it must initialize the obstack by calling ‘obstack_init’.

 -- Function: int obstack_init (struct obstack *OBSTACK-PTR)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Safe mem |
     *Note POSIX Safety Concepts::.

     Initialize obstack OBSTACK-PTR for allocation of objects.  This
     function calls the obstack’s ‘obstack_chunk_alloc’ function.  If
     allocation of memory fails, the function pointed to by
     ‘obstack_alloc_failed_handler’ is called.  The ‘obstack_init’
     function always returns 1 (Compatibility notice: Former versions of
     obstack returned 0 if allocation failed).

   Here are two examples of how to allocate the space for an obstack and
initialize it.  First, an obstack that is a static variable:

     static struct obstack myobstack;
     …
     obstack_init (&myobstack);

Second, an obstack that is itself dynamically allocated:

     struct obstack *myobstack_ptr
       = (struct obstack *) xmalloc (sizeof (struct obstack));

     obstack_init (myobstack_ptr);

 -- Variable: obstack_alloc_failed_handler

     The value of this variable is a pointer to a function that
     ‘obstack’ uses when ‘obstack_chunk_alloc’ fails to allocate memory.
     The default action is to print a message and abort.  You should
     supply a function that either calls ‘exit’ (*note Program
     Termination::) or ‘longjmp’ (*note Non-Local Exits::) and doesn’t
     return.

          void my_obstack_alloc_failed (void)
          …
          obstack_alloc_failed_handler = &my_obstack_alloc_failed;


File: libc.info,  Node: Allocation in an Obstack,  Next: Freeing Obstack Objects,  Prev: Preparing for Obstacks,  Up: Obstacks

3.2.6.3 Allocation in an Obstack
................................

The most direct way to allocate an object in an obstack is with
‘obstack_alloc’, which is invoked almost like ‘malloc’.

 -- Function: void * obstack_alloc (struct obstack *OBSTACK-PTR, int
          SIZE)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Unsafe
     corrupt mem | *Note POSIX Safety Concepts::.

     This allocates an uninitialized block of SIZE bytes in an obstack
     and returns its address.  Here OBSTACK-PTR specifies which obstack
     to allocate the block in; it is the address of the ‘struct obstack’
     object which represents the obstack.  Each obstack function or
     macro requires you to specify an OBSTACK-PTR as the first argument.

     This function calls the obstack’s ‘obstack_chunk_alloc’ function if
     it needs to allocate a new chunk of memory; it calls
     ‘obstack_alloc_failed_handler’ if allocation of memory by
     ‘obstack_chunk_alloc’ failed.

   For example, here is a function that allocates a copy of a string STR
in a specific obstack, which is in the variable ‘string_obstack’:

     struct obstack string_obstack;

     char *
     copystring (char *string)
     {
       size_t len = strlen (string) + 1;
       char *s = (char *) obstack_alloc (&string_obstack, len);
       memcpy (s, string, len);
       return s;
     }

   To allocate a block with specified contents, use the function
‘obstack_copy’, declared like this:

 -- Function: void * obstack_copy (struct obstack *OBSTACK-PTR, void
          *ADDRESS, int SIZE)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Unsafe
     corrupt mem | *Note POSIX Safety Concepts::.

     This allocates a block and initializes it by copying SIZE bytes of
     data starting at ADDRESS.  It calls ‘obstack_alloc_failed_handler’
     if allocation of memory by ‘obstack_chunk_alloc’ failed.

 -- Function: void * obstack_copy0 (struct obstack *OBSTACK-PTR, void
          *ADDRESS, int SIZE)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Unsafe
     corrupt mem | *Note POSIX Safety Concepts::.

     Like ‘obstack_copy’, but appends an extra byte containing a null
     character.  This extra byte is not counted in the argument SIZE.

   The ‘obstack_copy0’ function is convenient for copying a sequence of
characters into an obstack as a null-terminated string.  Here is an
example of its use:

     char *
     obstack_savestring (char *addr, int size)
     {
       return obstack_copy0 (&myobstack, addr, size);
     }

Contrast this with the previous example of ‘savestring’ using ‘malloc’
(*note Basic Allocation::).


File: libc.info,  Node: Freeing Obstack Objects,  Next: Obstack Functions,  Prev: Allocation in an Obstack,  Up: Obstacks

3.2.6.4 Freeing Objects in an Obstack
.....................................

To free an object allocated in an obstack, use the function
‘obstack_free’.  Since the obstack is a stack of objects, freeing one
object automatically frees all other objects allocated more recently in
the same obstack.

 -- Function: void obstack_free (struct obstack *OBSTACK-PTR, void
          *OBJECT)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Unsafe
     corrupt | *Note POSIX Safety Concepts::.

     If OBJECT is a null pointer, everything allocated in the obstack is
     freed.  Otherwise, OBJECT must be the address of an object
     allocated in the obstack.  Then OBJECT is freed, along with
     everything allocated in OBSTACK-PTR since OBJECT.

   Note that if OBJECT is a null pointer, the result is an uninitialized
obstack.  To free all memory in an obstack but leave it valid for
further allocation, call ‘obstack_free’ with the address of the first
object allocated on the obstack:

     obstack_free (obstack_ptr, first_object_allocated_ptr);

   Recall that the objects in an obstack are grouped into chunks.  When
all the objects in a chunk become free, the obstack library
automatically frees the chunk (*note Preparing for Obstacks::).  Then
other obstacks, or non-obstack allocation, can reuse the space of the
chunk.


File: libc.info,  Node: Obstack Functions,  Next: Growing Objects,  Prev: Freeing Obstack Objects,  Up: Obstacks

3.2.6.5 Obstack Functions and Macros
....................................

The interfaces for using obstacks may be defined either as functions or
as macros, depending on the compiler.  The obstack facility works with
all C compilers, including both ISO C and traditional C, but there are
precautions you must take if you plan to use compilers other than GNU C.

   If you are using an old-fashioned non-ISO C compiler, all the obstack
“functions” are actually defined only as macros.  You can call these
macros like functions, but you cannot use them in any other way (for
example, you cannot take their address).

   Calling the macros requires a special precaution: namely, the first
operand (the obstack pointer) may not contain any side effects, because
it may be computed more than once.  For example, if you write this:

     obstack_alloc (get_obstack (), 4);

you will find that ‘get_obstack’ may be called several times.  If you
use ‘*obstack_list_ptr++’ as the obstack pointer argument, you will get
very strange results since the incrementation may occur several times.

   In ISO C, each function has both a macro definition and a function
definition.  The function definition is used if you take the address of
the function without calling it.  An ordinary call uses the macro
definition by default, but you can request the function definition
instead by writing the function name in parentheses, as shown here:

     char *x;
     void *(*funcp) ();
     /* Use the macro.  */
     x = (char *) obstack_alloc (obptr, size);
     /* Call the function.  */
     x = (char *) (obstack_alloc) (obptr, size);
     /* Take the address of the function.  */
     funcp = obstack_alloc;

This is the same situation that exists in ISO C for the standard library
functions.  *Note Macro Definitions::.

   *Warning:* When you do use the macros, you must observe the
precaution of avoiding side effects in the first operand, even in ISO C.

   If you use the GNU C compiler, this precaution is not necessary,
because various language extensions in GNU C permit defining the macros
so as to compute each argument only once.


File: libc.info,  Node: Growing Objects,  Next: Extra Fast Growing,  Prev: Obstack Functions,  Up: Obstacks

3.2.6.6 Growing Objects
.......................

Because memory in obstack chunks is used sequentially, it is possible to
build up an object step by step, adding one or more bytes at a time to
the end of the object.  With this technique, you do not need to know how
much data you will put in the object until you come to the end of it.
We call this the technique of "growing objects".  The special functions
for adding data to the growing object are described in this section.

   You don’t need to do anything special when you start to grow an
object.  Using one of the functions to add data to the object
automatically starts it.  However, it is necessary to say explicitly
when the object is finished.  This is done with the function
‘obstack_finish’.

   The actual address of the object thus built up is not known until the
object is finished.  Until then, it always remains possible that you
will add so much data that the object must be copied into a new chunk.

   While the obstack is in use for a growing object, you cannot use it
for ordinary allocation of another object.  If you try to do so, the
space already added to the growing object will become part of the other
object.

 -- Function: void obstack_blank (struct obstack *OBSTACK-PTR, int SIZE)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Unsafe
     corrupt mem | *Note POSIX Safety Concepts::.

     The most basic function for adding to a growing object is
     ‘obstack_blank’, which adds space without initializing it.

 -- Function: void obstack_grow (struct obstack *OBSTACK-PTR, void
          *DATA, int SIZE)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Unsafe
     corrupt mem | *Note POSIX Safety Concepts::.

     To add a block of initialized space, use ‘obstack_grow’, which is
     the growing-object analogue of ‘obstack_copy’.  It adds SIZE bytes
     of data to the growing object, copying the contents from DATA.

 -- Function: void obstack_grow0 (struct obstack *OBSTACK-PTR, void
          *DATA, int SIZE)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Unsafe
     corrupt mem | *Note POSIX Safety Concepts::.

     This is the growing-object analogue of ‘obstack_copy0’.  It adds
     SIZE bytes copied from DATA, followed by an additional null
     character.

 -- Function: void obstack_1grow (struct obstack *OBSTACK-PTR, char C)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Unsafe
     corrupt mem | *Note POSIX Safety Concepts::.

     To add one character at a time, use the function ‘obstack_1grow’.
     It adds a single byte containing C to the growing object.

 -- Function: void obstack_ptr_grow (struct obstack *OBSTACK-PTR, void
          *DATA)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Unsafe
     corrupt mem | *Note POSIX Safety Concepts::.

     Adding the value of a pointer one can use the function
     ‘obstack_ptr_grow’.  It adds ‘sizeof (void *)’ bytes containing the
     value of DATA.

 -- Function: void obstack_int_grow (struct obstack *OBSTACK-PTR, int
          DATA)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Unsafe
     corrupt mem | *Note POSIX Safety Concepts::.

     A single value of type ‘int’ can be added by using the
     ‘obstack_int_grow’ function.  It adds ‘sizeof (int)’ bytes to the
     growing object and initializes them with the value of DATA.

 -- Function: void * obstack_finish (struct obstack *OBSTACK-PTR)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Unsafe
     corrupt | *Note POSIX Safety Concepts::.

     When you are finished growing the object, use the function
     ‘obstack_finish’ to close it off and return its final address.

     Once you have finished the object, the obstack is available for
     ordinary allocation or for growing another object.

     This function can return a null pointer under the same conditions
     as ‘obstack_alloc’ (*note Allocation in an Obstack::).

   When you build an object by growing it, you will probably need to
know afterward how long it became.  You need not keep track of this as
you grow the object, because you can find out the length from the
obstack just before finishing the object with the function
‘obstack_object_size’, declared as follows:

 -- Function: int obstack_object_size (struct obstack *OBSTACK-PTR)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Safe | *Note
     POSIX Safety Concepts::.

     This function returns the current size of the growing object, in
     bytes.  Remember to call this function _before_ finishing the
     object.  After it is finished, ‘obstack_object_size’ will return
     zero.

   If you have started growing an object and wish to cancel it, you
should finish it and then free it, like this:

     obstack_free (obstack_ptr, obstack_finish (obstack_ptr));

This has no effect if no object was growing.

   You can use ‘obstack_blank’ with a negative size argument to make the
current object smaller.  Just don’t try to shrink it beyond zero
length—there’s no telling what will happen if you do that.


File: libc.info,  Node: Extra Fast Growing,  Next: Status of an Obstack,  Prev: Growing Objects,  Up: Obstacks

3.2.6.7 Extra Fast Growing Objects
..................................

The usual functions for growing objects incur overhead for checking
whether there is room for the new growth in the current chunk.  If you
are frequently constructing objects in small steps of growth, this
overhead can be significant.

   You can reduce the overhead by using special “fast growth” functions
that grow the object without checking.  In order to have a robust
program, you must do the checking yourself.  If you do this checking in
the simplest way each time you are about to add data to the object, you
have not saved anything, because that is what the ordinary growth
functions do.  But if you can arrange to check less often, or check more
efficiently, then you make the program faster.

   The function ‘obstack_room’ returns the amount of room available in
the current chunk.  It is declared as follows:

 -- Function: int obstack_room (struct obstack *OBSTACK-PTR)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Safe | *Note
     POSIX Safety Concepts::.

     This returns the number of bytes that can be added safely to the
     current growing object (or to an object about to be started) in
     obstack OBSTACK-PTR using the fast growth functions.

   While you know there is room, you can use these fast growth functions
for adding data to a growing object:

 -- Function: void obstack_1grow_fast (struct obstack *OBSTACK-PTR, char
          C)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Unsafe
     corrupt mem | *Note POSIX Safety Concepts::.

     The function ‘obstack_1grow_fast’ adds one byte containing the
     character C to the growing object in obstack OBSTACK-PTR.

 -- Function: void obstack_ptr_grow_fast (struct obstack *OBSTACK-PTR,
          void *DATA)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Safe | *Note
     POSIX Safety Concepts::.

     The function ‘obstack_ptr_grow_fast’ adds ‘sizeof (void *)’ bytes
     containing the value of DATA to the growing object in obstack
     OBSTACK-PTR.

 -- Function: void obstack_int_grow_fast (struct obstack *OBSTACK-PTR,
          int DATA)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Safe | *Note
     POSIX Safety Concepts::.

     The function ‘obstack_int_grow_fast’ adds ‘sizeof (int)’ bytes
     containing the value of DATA to the growing object in obstack
     OBSTACK-PTR.

 -- Function: void obstack_blank_fast (struct obstack *OBSTACK-PTR, int
          SIZE)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Safe | *Note
     POSIX Safety Concepts::.

     The function ‘obstack_blank_fast’ adds SIZE bytes to the growing
     object in obstack OBSTACK-PTR without initializing them.

   When you check for space using ‘obstack_room’ and there is not enough
room for what you want to add, the fast growth functions are not safe.
In this case, simply use the corresponding ordinary growth function
instead.  Very soon this will copy the object to a new chunk; then there
will be lots of room available again.

   So, each time you use an ordinary growth function, check afterward
for sufficient space using ‘obstack_room’.  Once the object is copied to
a new chunk, there will be plenty of space again, so the program will
start using the fast growth functions again.

   Here is an example:

     void
     add_string (struct obstack *obstack, const char *ptr, int len)
     {
       while (len > 0)
         {
           int room = obstack_room (obstack);
           if (room == 0)
             {
               /* Not enough room.  Add one character slowly,
                  which may copy to a new chunk and make room.  */
               obstack_1grow (obstack, *ptr++);
               len--;
             }
           else
             {
               if (room > len)
                 room = len;
               /* Add fast as much as we have room for. */
               len -= room;
               while (room-- > 0)
                 obstack_1grow_fast (obstack, *ptr++);
             }
         }
     }


File: libc.info,  Node: Status of an Obstack,  Next: Obstacks Data Alignment,  Prev: Extra Fast Growing,  Up: Obstacks

3.2.6.8 Status of an Obstack
............................

Here are functions that provide information on the current status of
allocation in an obstack.  You can use them to learn about an object
while still growing it.

 -- Function: void * obstack_base (struct obstack *OBSTACK-PTR)

     Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Safe | *Note POSIX
     Safety Concepts::.

     This function returns the tentative address of the beginning of the
     currently growing object in OBSTACK-PTR.  If you finish the object
     immediately, it will have that address.  If you make it larger
     first, it may outgrow the current chunk—then its address will
     change!

     If no object is growing, this value says where the next object you
     allocate will start (once again assuming it fits in the current
     chunk).

 -- Function: void * obstack_next_free (struct obstack *OBSTACK-PTR)

     Preliminary: | MT-Safe | AS-Unsafe corrupt | AC-Safe | *Note POSIX
     Safety Concepts::.

     This function returns the address of the first free byte in the
     current chunk of obstack OBSTACK-PTR.  This is the end of the
     currently growing object.  If no object is growing,
     ‘obstack_next_free’ returns the same value as ‘obstack_base’.

 -- Function: int obstack_object_size (struct obstack *OBSTACK-PTR)

     Preliminary: | MT-Safe race:obstack-ptr | AS-Safe | AC-Safe | *Note
     POSIX Safety Concepts::.

     This function returns the size in bytes of the currently growing
     object.  This is equivalent to

          obstack_next_free (OBSTACK-PTR) - obstack_base (OBSTACK-PTR)


File: libc.info,  Node: Obstacks Data Alignment,  Next: Obstack Chunks,  Prev: Status of an Obstack,  Up: Obstacks

3.2.6.9 Alignment of Data in Obstacks
.....................................

Each obstack has an "alignment boundary"; each object allocated in the
obstack automatically starts on an address that is a multiple of the
specified boundary.  By default, this boundary is aligned so that the
object can hold any type of data.

   To access an obstack’s alignment boundary, use the macro
‘obstack_alignment_mask’, whose function prototype looks like this:

 -- Macro: int obstack_alignment_mask (struct obstack *OBSTACK-PTR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The value is a bit mask; a bit that is 1 indicates that the
     corresponding bit in the address of an object should be 0.  The
     mask value should be one less than a power of 2; the effect is that
     all object addresses are multiples of that power of 2.  The default
     value of the mask is a value that allows aligned objects to hold
     any type of data: for example, if its value is 3, any type of data
     can be stored at locations whose addresses are multiples of 4.  A
     mask value of 0 means an object can start on any multiple of 1
     (that is, no alignment is required).

     The expansion of the macro ‘obstack_alignment_mask’ is an lvalue,
     so you can alter the mask by assignment.  For example, this
     statement:

          obstack_alignment_mask (obstack_ptr) = 0;

     has the effect of turning off alignment processing in the specified
     obstack.

   Note that a change in alignment mask does not take effect until
_after_ the next time an object is allocated or finished in the obstack.
If you are not growing an object, you can make the new alignment mask
take effect immediately by calling ‘obstack_finish’.  This will finish a
zero-length object and then do proper alignment for the next object.


File: libc.info,  Node: Obstack Chunks,  Next: Summary of Obstacks,  Prev: Obstacks Data Alignment,  Up: Obstacks

3.2.6.10 Obstack Chunks
.......................

Obstacks work by allocating space for themselves in large chunks, and
then parceling out space in the chunks to satisfy your requests.  Chunks
are normally 4096 bytes long unless you specify a different chunk size.
The chunk size includes 8 bytes of overhead that are not actually used
for storing objects.  Regardless of the specified size, longer chunks
will be allocated when necessary for long objects.

   The obstack library allocates chunks by calling the function
‘obstack_chunk_alloc’, which you must define.  When a chunk is no longer
needed because you have freed all the objects in it, the obstack library
frees the chunk by calling ‘obstack_chunk_free’, which you must also
define.

   These two must be defined (as macros) or declared (as functions) in
each source file that uses ‘obstack_init’ (*note Creating Obstacks::).
Most often they are defined as macros like this:

     #define obstack_chunk_alloc malloc
     #define obstack_chunk_free free

   Note that these are simple macros (no arguments).  Macro definitions
with arguments will not work!  It is necessary that
‘obstack_chunk_alloc’ or ‘obstack_chunk_free’, alone, expand into a
function name if it is not itself a function name.

   If you allocate chunks with ‘malloc’, the chunk size should be a
power of 2.  The default chunk size, 4096, was chosen because it is long
enough to satisfy many typical requests on the obstack yet short enough
not to waste too much memory in the portion of the last chunk not yet
used.

 -- Macro: int obstack_chunk_size (struct obstack *OBSTACK-PTR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This returns the chunk size of the given obstack.

   Since this macro expands to an lvalue, you can specify a new chunk
size by assigning it a new value.  Doing so does not affect the chunks
already allocated, but will change the size of chunks allocated for that
particular obstack in the future.  It is unlikely to be useful to make
the chunk size smaller, but making it larger might improve efficiency if
you are allocating many objects whose size is comparable to the chunk
size.  Here is how to do so cleanly:

     if (obstack_chunk_size (obstack_ptr) < NEW-CHUNK-SIZE)
       obstack_chunk_size (obstack_ptr) = NEW-CHUNK-SIZE;


File: libc.info,  Node: Summary of Obstacks,  Prev: Obstack Chunks,  Up: Obstacks

3.2.6.11 Summary of Obstack Functions
.....................................

Here is a summary of all the functions associated with obstacks.  Each
takes the address of an obstack (‘struct obstack *’) as its first
argument.

‘void obstack_init (struct obstack *OBSTACK-PTR)’
     Initialize use of an obstack.  *Note Creating Obstacks::.

‘void *obstack_alloc (struct obstack *OBSTACK-PTR, int SIZE)’
     Allocate an object of SIZE uninitialized bytes.  *Note Allocation
     in an Obstack::.

‘void *obstack_copy (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)’
     Allocate an object of SIZE bytes, with contents copied from
     ADDRESS.  *Note Allocation in an Obstack::.

‘void *obstack_copy0 (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)’
     Allocate an object of SIZE+1 bytes, with SIZE of them copied from
     ADDRESS, followed by a null character at the end.  *Note Allocation
     in an Obstack::.

‘void obstack_free (struct obstack *OBSTACK-PTR, void *OBJECT)’
     Free OBJECT (and everything allocated in the specified obstack more
     recently than OBJECT).  *Note Freeing Obstack Objects::.

‘void obstack_blank (struct obstack *OBSTACK-PTR, int SIZE)’
     Add SIZE uninitialized bytes to a growing object.  *Note Growing
     Objects::.

‘void obstack_grow (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)’
     Add SIZE bytes, copied from ADDRESS, to a growing object.  *Note
     Growing Objects::.

‘void obstack_grow0 (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)’
     Add SIZE bytes, copied from ADDRESS, to a growing object, and then
     add another byte containing a null character.  *Note Growing
     Objects::.

‘void obstack_1grow (struct obstack *OBSTACK-PTR, char DATA-CHAR)’
     Add one byte containing DATA-CHAR to a growing object.  *Note
     Growing Objects::.

‘void *obstack_finish (struct obstack *OBSTACK-PTR)’
     Finalize the object that is growing and return its permanent
     address.  *Note Growing Objects::.

‘int obstack_object_size (struct obstack *OBSTACK-PTR)’
     Get the current size of the currently growing object.  *Note
     Growing Objects::.

‘void obstack_blank_fast (struct obstack *OBSTACK-PTR, int SIZE)’
     Add SIZE uninitialized bytes to a growing object without checking
     that there is enough room.  *Note Extra Fast Growing::.

‘void obstack_1grow_fast (struct obstack *OBSTACK-PTR, char DATA-CHAR)’
     Add one byte containing DATA-CHAR to a growing object without
     checking that there is enough room.  *Note Extra Fast Growing::.

‘int obstack_room (struct obstack *OBSTACK-PTR)’
     Get the amount of room now available for growing the current
     object.  *Note Extra Fast Growing::.

‘int obstack_alignment_mask (struct obstack *OBSTACK-PTR)’
     The mask used for aligning the beginning of an object.  This is an
     lvalue.  *Note Obstacks Data Alignment::.

‘int obstack_chunk_size (struct obstack *OBSTACK-PTR)’
     The size for allocating chunks.  This is an lvalue.  *Note Obstack
     Chunks::.

‘void *obstack_base (struct obstack *OBSTACK-PTR)’
     Tentative starting address of the currently growing object.  *Note
     Status of an Obstack::.

‘void *obstack_next_free (struct obstack *OBSTACK-PTR)’
     Address just after the end of the currently growing object.  *Note
     Status of an Obstack::.


File: libc.info,  Node: Variable Size Automatic,  Prev: Obstacks,  Up: Memory Allocation

3.2.7 Automatic Storage with Variable Size
------------------------------------------

The function ‘alloca’ supports a kind of half-dynamic allocation in
which blocks are allocated dynamically but freed automatically.

   Allocating a block with ‘alloca’ is an explicit action; you can
allocate as many blocks as you wish, and compute the size at run time.
But all the blocks are freed when you exit the function that ‘alloca’
was called from, just as if they were automatic variables declared in
that function.  There is no way to free the space explicitly.

   The prototype for ‘alloca’ is in ‘stdlib.h’.  This function is a BSD
extension.

 -- Function: void * alloca (size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The return value of ‘alloca’ is the address of a block of SIZE
     bytes of memory, allocated in the stack frame of the calling
     function.

   Do not use ‘alloca’ inside the arguments of a function call—you will
get unpredictable results, because the stack space for the ‘alloca’
would appear on the stack in the middle of the space for the function
arguments.  An example of what to avoid is ‘foo (x, alloca (4), y)’.

* Menu:

* Alloca Example::              Example of using ‘alloca’.
* Advantages of Alloca::        Reasons to use ‘alloca’.
* Disadvantages of Alloca::     Reasons to avoid ‘alloca’.
* GNU C Variable-Size Arrays::  Only in GNU C, here is an alternative
				 method of allocating dynamically and
				 freeing automatically.


File: libc.info,  Node: Alloca Example,  Next: Advantages of Alloca,  Up: Variable Size Automatic

3.2.7.1 ‘alloca’ Example
........................

As an example of the use of ‘alloca’, here is a function that opens a
file name made from concatenating two argument strings, and returns a
file descriptor or minus one signifying failure:

     int
     open2 (char *str1, char *str2, int flags, int mode)
     {
       char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
       stpcpy (stpcpy (name, str1), str2);
       return open (name, flags, mode);
     }

Here is how you would get the same results with ‘malloc’ and ‘free’:

     int
     open2 (char *str1, char *str2, int flags, int mode)
     {
       char *name = (char *) malloc (strlen (str1) + strlen (str2) + 1);
       int desc;
       if (name == 0)
         fatal ("virtual memory exceeded");
       stpcpy (stpcpy (name, str1), str2);
       desc = open (name, flags, mode);
       free (name);
       return desc;
     }

   As you can see, it is simpler with ‘alloca’.  But ‘alloca’ has other,
more important advantages, and some disadvantages.


File: libc.info,  Node: Advantages of Alloca,  Next: Disadvantages of Alloca,  Prev: Alloca Example,  Up: Variable Size Automatic

3.2.7.2 Advantages of ‘alloca’
..............................

Here are the reasons why ‘alloca’ may be preferable to ‘malloc’:

   • Using ‘alloca’ wastes very little space and is very fast.  (It is
     open-coded by the GNU C compiler.)

   • Since ‘alloca’ does not have separate pools for different sizes of
     blocks, space used for any size block can be reused for any other
     size.  ‘alloca’ does not cause memory fragmentation.

   • Nonlocal exits done with ‘longjmp’ (*note Non-Local Exits::)
     automatically free the space allocated with ‘alloca’ when they exit
     through the function that called ‘alloca’.  This is the most
     important reason to use ‘alloca’.

     To illustrate this, suppose you have a function
     ‘open_or_report_error’ which returns a descriptor, like ‘open’, if
     it succeeds, but does not return to its caller if it fails.  If the
     file cannot be opened, it prints an error message and jumps out to
     the command level of your program using ‘longjmp’.  Let’s change
     ‘open2’ (*note Alloca Example::) to use this subroutine:

          int
          open2 (char *str1, char *str2, int flags, int mode)
          {
            char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
            stpcpy (stpcpy (name, str1), str2);
            return open_or_report_error (name, flags, mode);
          }

     Because of the way ‘alloca’ works, the memory it allocates is freed
     even when an error occurs, with no special effort required.

     By contrast, the previous definition of ‘open2’ (which uses
     ‘malloc’ and ‘free’) would develop a memory leak if it were changed
     in this way.  Even if you are willing to make more changes to fix
     it, there is no easy way to do so.


File: libc.info,  Node: Disadvantages of Alloca,  Next: GNU C Variable-Size Arrays,  Prev: Advantages of Alloca,  Up: Variable Size Automatic

3.2.7.3 Disadvantages of ‘alloca’
.................................

These are the disadvantages of ‘alloca’ in comparison with ‘malloc’:

   • If you try to allocate more memory than the machine can provide,
     you don’t get a clean error message.  Instead you get a fatal
     signal like the one you would get from an infinite recursion;
     probably a segmentation violation (*note Program Error Signals::).

   • Some non-GNU systems fail to support ‘alloca’, so it is less
     portable.  However, a slower emulation of ‘alloca’ written in C is
     available for use on systems with this deficiency.


File: libc.info,  Node: GNU C Variable-Size Arrays,  Prev: Disadvantages of Alloca,  Up: Variable Size Automatic

3.2.7.4 GNU C Variable-Size Arrays
..................................

In GNU C, you can replace most uses of ‘alloca’ with an array of
variable size.  Here is how ‘open2’ would look then:

     int open2 (char *str1, char *str2, int flags, int mode)
     {
       char name[strlen (str1) + strlen (str2) + 1];
       stpcpy (stpcpy (name, str1), str2);
       return open (name, flags, mode);
     }

   But ‘alloca’ is not always equivalent to a variable-sized array, for
several reasons:

   • A variable size array’s space is freed at the end of the scope of
     the name of the array.  The space allocated with ‘alloca’ remains
     until the end of the function.

   • It is possible to use ‘alloca’ within a loop, allocating an
     additional block on each iteration.  This is impossible with
     variable-sized arrays.

   *NB:* If you mix use of ‘alloca’ and variable-sized arrays within one
function, exiting a scope in which a variable-sized array was declared
frees all blocks allocated with ‘alloca’ during the execution of that
scope.


File: libc.info,  Node: Resizing the Data Segment,  Next: Memory Protection,  Prev: Memory Allocation,  Up: Memory

3.3 Resizing the Data Segment
=============================

The symbols in this section are declared in ‘unistd.h’.

   You will not normally use the functions in this section, because the
functions described in *note Memory Allocation:: are easier to use.
Those are interfaces to a GNU C Library memory allocator that uses the
functions below itself.  The functions below are simple interfaces to
system calls.

 -- Function: int brk (void *ADDR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘brk’ sets the high end of the calling process’ data segment to
     ADDR.

     The address of the end of a segment is defined to be the address of
     the last byte in the segment plus 1.

     The function has no effect if ADDR is lower than the low end of the
     data segment.  (This is considered success, by the way.)

     The function fails if it would cause the data segment to overlap
     another segment or exceed the process’ data storage limit (*note
     Limits on Resources::).

     The function is named for a common historical case where data
     storage and the stack are in the same segment.  Data storage
     allocation grows upward from the bottom of the segment while the
     stack grows downward toward it from the top of the segment and the
     curtain between them is called the "break".

     The return value is zero on success.  On failure, the return value
     is ‘-1’ and ‘errno’ is set accordingly.  The following ‘errno’
     values are specific to this function:

     ‘ENOMEM’
          The request would cause the data segment to overlap another
          segment or exceed the process’ data storage limit.

 -- Function: void *sbrk (ptrdiff_t DELTA)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is the same as ‘brk’ except that you specify the new
     end of the data segment as an offset DELTA from the current end and
     on success the return value is the address of the resulting end of
     the data segment instead of zero.

     This means you can use ‘sbrk(0)’ to find out what the current end
     of the data segment is.


File: libc.info,  Node: Memory Protection,  Next: Locking Pages,  Prev: Resizing the Data Segment,  Up: Memory

3.4 Memory Protection
=====================

When a page is mapped using ‘mmap’, page protection flags can be
specified using the protection flags argument.  *Note Memory-mapped
I/O::.

   The following flags are available:

‘PROT_WRITE’

     The memory can be written to.

‘PROT_READ’

     The memory can be read.  On some architectures, this flag implies
     that the memory can be executed as well (as if ‘PROT_EXEC’ had been
     specified at the same time).

‘PROT_EXEC’

     The memory can be used to store instructions which can then be
     executed.  On most architectures, this flag implies that the memory
     can be read (as if ‘PROT_READ’ had been specified).

‘PROT_NONE’

     This flag must be specified on its own.

     The memory is reserved, but cannot be read, written, or executed.
     If this flag is specified in a call to ‘mmap’, a virtual memory
     area will be set aside for future use in the process, and ‘mmap’
     calls without the ‘MAP_FIXED’ flag will not use it for subsequent
     allocations.  For anonymous mappings, the kernel will not reserve
     any physical memory for the allocation at the time the mapping is
     created.

   The operating system may keep track of these flags separately even if
the underlying hardware treats them the same for the purposes of access
checking (as happens with ‘PROT_READ’ and ‘PROT_EXEC’ on some
platforms).  On GNU systems, ‘PROT_EXEC’ always implies ‘PROT_READ’, so
that users can view the machine code which is executing on their system.

   Inappropriate access will cause a segfault (*note Program Error
Signals::).

   After allocation, protection flags can be changed using the
‘mprotect’ function.

 -- Function: int mprotect (void *ADDRESS, size_t LENGTH, int
          PROTECTION)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     A successful call to the ‘mprotect’ function changes the protection
     flags of at least LENGTH bytes of memory, starting at ADDRESS.

     ADDRESS must be aligned to the page size for the mapping.  The
     system page size can be obtained by calling ‘sysconf’ with the
     ‘_SC_PAGESIZE’ parameter (*note Sysconf Definition::).  The system
     page size is the granularity in which the page protection of
     anonymous memory mappings and most file mappings can be changed.
     Memory which is mapped from special files or devices may have
     larger page granularity than the system page size and may require
     larger alignment.

     LENGTH is the number of bytes whose protection flags must be
     changed.  It is automatically rounded up to the next multiple of
     the system page size.

     PROTECTION is a combination of the ‘PROT_*’ flags described above.

     The ‘mprotect’ function returns 0 on success and -1 on failure.

     The following ‘errno’ error conditions are defined for this
     function:

     ‘ENOMEM’
          The system was not able to allocate resources to fulfill the
          request.  This can happen if there is not enough physical
          memory in the system for the allocation of backing storage.
          The error can also occur if the new protection flags would
          cause the memory region to be split from its neighbors, and
          the process limit for the number of such distinct memory
          regions would be exceeded.

     ‘EINVAL’
          ADDRESS is not properly aligned to a page boundary for the
          mapping, or LENGTH (after rounding up to the system page size)
          is not a multiple of the applicable page size for the mapping,
          or the combination of flags in PROTECTION is not valid.

     ‘EACCES’
          The file for a file-based mapping was not opened with open
          flags which are compatible with PROTECTION.

     ‘EPERM’
          The system security policy does not allow a mapping with the
          specified flags.  For example, mappings which are both
          ‘PROT_EXEC’ and ‘PROT_WRITE’ at the same time might not be
          allowed.

   If the ‘mprotect’ function is used to make a region of memory
inaccessible by specifying the ‘PROT_NONE’ protection flag and access is
later restored, the memory retains its previous contents.

   On some systems, it may not be possible to specify additional flags
which were not present when the mapping was first created.  For example,
an attempt to make a region of memory executable could fail if the
initial protection flags were ‘PROT_READ | PROT_WRITE’.

   In general, the ‘mprotect’ function can be used to change any process
memory, no matter how it was allocated.  However, portable use of the
function requires that it is only used with memory regions returned by
‘mmap’ or ‘mmap64’.

3.4.1 Memory Protection Keys
----------------------------

On some systems, further restrictions can be added to specific pages
using "memory protection keys".  These restrictions work as follows:

   • All memory pages are associated with a protection key.  The default
     protection key does not cause any additional protections to be
     applied during memory accesses.  New keys can be allocated with the
     ‘pkey_alloc’ function, and applied to pages using ‘pkey_mprotect’.

   • Each thread has a set of separate access right restriction for each
     protection key.  These access rights can be manipulated using the
     ‘pkey_set’ and ‘pkey_get’ functions.

   • During a memory access, the system obtains the protection key for
     the accessed page and uses that to determine the applicable access
     rights, as configured for the current thread.  If the access is
     restricted, a segmentation fault is the result ((*note Program
     Error Signals::).  These checks happen in addition to the ‘PROT_’*
     protection flags set by ‘mprotect’ or ‘pkey_mprotect’.

   New threads and subprocesses inherit the access rights of the current
thread.  If a protection key is allocated subsequently, existing threads
(except the current) will use an unspecified system default for the
access rights associated with newly allocated keys.

   Upon entering a signal handler, the system resets the access rights
of the current thread so that pages with the default key can be
accessed, but the access rights for other protection keys are
unspecified.

   Applications are expected to allocate a key once using ‘pkey_alloc’,
and apply the key to memory regions which need special protection with
‘pkey_mprotect’:

       int key = pkey_alloc (0, PKEY_DISABLE_ACCESS);
       if (key < 0)
         /* Perform error checking, including fallback for lack of support.  */
         ...;

       /* Apply the key to a special memory region used to store critical
          data.  */
       if (pkey_mprotect (region, region_length,
                          PROT_READ | PROT_WRITE, key) < 0)
         ...; /* Perform error checking (generally fatal).  */

   If the key allocation fails due to lack of support for memory
protection keys, the ‘pkey_mprotect’ call can usually be skipped.  In
this case, the region will not be protected by default.  It is also
possible to call ‘pkey_mprotect’ with a key value of -1, in which case
it will behave in the same way as ‘mprotect’.

   After key allocation assignment to memory pages, ‘pkey_set’ can be
used to temporarily acquire access to the memory region and relinquish
it again:

       if (key >= 0 && pkey_set (key, 0) < 0)
         ...; /* Perform error checking (generally fatal).  */
       /* At this point, the current thread has read-write access to the
          memory region.  */
       ...
       /* Revoke access again.  */
       if (key >= 0 && pkey_set (key, PKEY_DISABLE_ACCESS) < 0)
         ...; /* Perform error checking (generally fatal).  */

   In this example, a negative key value indicates that no key had been
allocated, which means that the system lacks support for memory
protection keys and it is not necessary to change the the access rights
of the current thread (because it always has access).

   Compared to using ‘mprotect’ to change the page protection flags,
this approach has two advantages: It is thread-safe in the sense that
the access rights are only changed for the current thread, so another
thread which changes its own access rights concurrently to gain access
to the mapping will not suddenly see its access rights revoked.  And
‘pkey_set’ typically does not involve a call into the kernel and a
context switch, so it is more efficient.

 -- Function: int pkey_alloc (unsigned int FLAGS, unsigned int
          RESTRICTIONS)

     Preliminary: | MT-Safe | AS-Safe | AC-Unsafe corrupt | *Note POSIX
     Safety Concepts::.

     Allocate a new protection key.  The FLAGS argument is reserved and
     must be zero.  The RESTRICTIONS argument specifies access rights
     which are applied to the current thread (as if with ‘pkey_set’
     below).  Access rights of other threads are not changed.

     The function returns the new protection key, a non-negative number,
     or -1 on error.

     The following ‘errno’ error conditions are defined for this
     function:

     ‘ENOSYS’
          The system does not implement memory protection keys.

     ‘EINVAL’
          The FLAGS argument is not zero.

          The RESTRICTIONS argument is invalid.

          The system does not implement memory protection keys or runs
          in a mode in which memory protection keys are disabled.

     ‘ENOSPC’
          All available protection keys already have been allocated.

 -- Function: int pkey_free (int KEY)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Deallocate the protection key, so that it can be reused by
     ‘pkey_alloc’.

     Calling this function does not change the access rights of the
     freed protection key.  The calling thread and other threads may
     retain access to it, even if it is subsequently allocated again.
     For this reason, it is not recommended to call the ‘pkey_free’
     function.

     ‘ENOSYS’
          The system does not implement memory protection keys.

     ‘EINVAL’
          The KEY argument is not a valid protection key.

 -- Function: int pkey_mprotect (void *ADDRESS, size_t LENGTH, int
          PROTECTION, int KEY)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Similar to ‘mprotect’, but also set the memory protection key for
     the memory region to ‘key’.

     Some systems use memory protection keys to emulate certain
     combinations of PROTECTION flags.  Under such circumstances,
     specifying an explicit protection key may behave as if additional
     flags have been specified in PROTECTION, even though this does not
     happen with the default protection key.  For example, some systems
     can support ‘PROT_EXEC’-only mappings only with a default
     protection key, and memory with a key which was allocated using
     ‘pkey_alloc’ will still be readable if ‘PROT_EXEC’ is specified
     without ‘PROT_READ’.

     If KEY is -1, the default protection key is applied to the mapping,
     just as if ‘mprotect’ had been called.

     The ‘pkey_mprotect’ function returns 0 on success and -1 on
     failure.  The same ‘errno’ error conditions as for ‘mprotect’ are
     defined for this function, with the following addition:

     ‘EINVAL’
          The KEY argument is not -1 or a valid memory protection key
          allocated using ‘pkey_alloc’.

     ‘ENOSYS’
          The system does not implement memory protection keys, and KEY
          is not -1.

 -- Function: int pkey_set (int KEY, unsigned int RIGHTS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Change the access rights of the current thread for memory pages
     with the protection key KEY to RIGHTS.  If RIGHTS is zero, no
     additional access restrictions on top of the page protection flags
     are applied.  Otherwise, RIGHTS is a combination of the following
     flags:

     ‘PKEY_DISABLE_WRITE’

          Subsequent attempts to write to memory with the specified
          protection key will fault.

     ‘PKEY_DISABLE_ACCESS’

          Subsequent attempts to write to or read from memory with the
          specified protection key will fault.

     Operations not specified as flags are not restricted.  In
     particular, this means that the memory region will remain
     executable if it was mapped with the ‘PROT_EXEC’ protection flag
     and ‘PKEY_DISABLE_ACCESS’ has been specified.

     Calling the ‘pkey_set’ function with a protection key which was not
     allocated by ‘pkey_alloc’ results in undefined behavior.  This
     means that calling this function on systems which do not support
     memory protection keys is undefined.

     The ‘pkey_set’ function returns 0 on success and -1 on failure.

     The following ‘errno’ error conditions are defined for this
     function:

     ‘EINVAL’
          The system does not support the access rights restrictions
          expressed in the RIGHTS argument.

 -- Function: int pkey_get (int KEY)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Return the access rights of the current thread for memory pages
     with protection key KEY.  The return value is zero or a combination
     of the ‘PKEY_DISABLE_’* flags; see the ‘pkey_set’ function.

     Calling the ‘pkey_get’ function with a protection key which was not
     allocated by ‘pkey_alloc’ results in undefined behavior.  This
     means that calling this function on systems which do not support
     memory protection keys is undefined.


File: libc.info,  Node: Locking Pages,  Prev: Memory Protection,  Up: Memory

3.5 Locking Pages
=================

You can tell the system to associate a particular virtual memory page
with a real page frame and keep it that way — i.e., cause the page to be
paged in if it isn’t already and mark it so it will never be paged out
and consequently will never cause a page fault.  This is called
"locking" a page.

   The functions in this chapter lock and unlock the calling process’
pages.

* Menu:

* Why Lock Pages::                Reasons to read this section.
* Locked Memory Details::         Everything you need to know locked
                                    memory
* Page Lock Functions::           Here’s how to do it.


File: libc.info,  Node: Why Lock Pages,  Next: Locked Memory Details,  Up: Locking Pages

3.5.1 Why Lock Pages
--------------------

Because page faults cause paged out pages to be paged in transparently,
a process rarely needs to be concerned about locking pages.  However,
there are two reasons people sometimes are:

   • Speed.  A page fault is transparent only insofar as the process is
     not sensitive to how long it takes to do a simple memory access.
     Time-critical processes, especially realtime processes, may not be
     able to wait or may not be able to tolerate variance in execution
     speed.

     A process that needs to lock pages for this reason probably also
     needs priority among other processes for use of the CPU. *Note
     Priority::.

     In some cases, the programmer knows better than the system’s demand
     paging allocator which pages should remain in real memory to
     optimize system performance.  In this case, locking pages can help.

   • Privacy.  If you keep secrets in virtual memory and that virtual
     memory gets paged out, that increases the chance that the secrets
     will get out.  If a passphrase gets written out to disk swap space,
     for example, it might still be there long after virtual and real
     memory have been wiped clean.

   Be aware that when you lock a page, that’s one fewer page frame that
can be used to back other virtual memory (by the same or other
processes), which can mean more page faults, which means the system runs
more slowly.  In fact, if you lock enough memory, some programs may not
be able to run at all for lack of real memory.


File: libc.info,  Node: Locked Memory Details,  Next: Page Lock Functions,  Prev: Why Lock Pages,  Up: Locking Pages

3.5.2 Locked Memory Details
---------------------------

A memory lock is associated with a virtual page, not a real frame.  The
paging rule is: If a frame backs at least one locked page, don’t page it
out.

   Memory locks do not stack.  I.e., you can’t lock a particular page
twice so that it has to be unlocked twice before it is truly unlocked.
It is either locked or it isn’t.

   A memory lock persists until the process that owns the memory
explicitly unlocks it.  (But process termination and exec cause the
virtual memory to cease to exist, which you might say means it isn’t
locked any more).

   Memory locks are not inherited by child processes.  (But note that on
a modern Unix system, immediately after a fork, the parent’s and the
child’s virtual address space are backed by the same real page frames,
so the child enjoys the parent’s locks).  *Note Creating a Process::.

   Because of its ability to impact other processes, only the superuser
can lock a page.  Any process can unlock its own page.

   The system sets limits on the amount of memory a process can have
locked and the amount of real memory it can have dedicated to it.  *Note
Limits on Resources::.

   In Linux, locked pages aren’t as locked as you might think.  Two
virtual pages that are not shared memory can nonetheless be backed by
the same real frame.  The kernel does this in the name of efficiency
when it knows both virtual pages contain identical data, and does it
even if one or both of the virtual pages are locked.

   But when a process modifies one of those pages, the kernel must get
it a separate frame and fill it with the page’s data.  This is known as
a "copy-on-write page fault".  It takes a small amount of time and in a
pathological case, getting that frame may require I/O.

   To make sure this doesn’t happen to your program, don’t just lock the
pages.  Write to them as well, unless you know you won’t write to them
ever.  And to make sure you have pre-allocated frames for your stack,
enter a scope that declares a C automatic variable larger than the
maximum stack size you will need, set it to something, then return from
its scope.


File: libc.info,  Node: Page Lock Functions,  Prev: Locked Memory Details,  Up: Locking Pages

3.5.3 Functions To Lock And Unlock Pages
----------------------------------------

The symbols in this section are declared in ‘sys/mman.h’.  These
functions are defined by POSIX.1b, but their availability depends on
your kernel.  If your kernel doesn’t allow these functions, they exist
but always fail.  They _are_ available with a Linux kernel.

   *Portability Note:* POSIX.1b requires that when the ‘mlock’ and
‘munlock’ functions are available, the file ‘unistd.h’ define the macro
‘_POSIX_MEMLOCK_RANGE’ and the file ‘limits.h’ define the macro
‘PAGESIZE’ to be the size of a memory page in bytes.  It requires that
when the ‘mlockall’ and ‘munlockall’ functions are available, the
‘unistd.h’ file define the macro ‘_POSIX_MEMLOCK’.  The GNU C Library
conforms to this requirement.

 -- Function: int mlock (const void *ADDR, size_t LEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘mlock’ locks a range of the calling process’ virtual pages.

     The range of memory starts at address ADDR and is LEN bytes long.
     Actually, since you must lock whole pages, it is the range of pages
     that include any part of the specified range.

     When the function returns successfully, each of those pages is
     backed by (connected to) a real frame (is resident) and is marked
     to stay that way.  This means the function may cause page-ins and
     have to wait for them.

     When the function fails, it does not affect the lock status of any
     pages.

     The return value is zero if the function succeeds.  Otherwise, it
     is ‘-1’ and ‘errno’ is set accordingly.  ‘errno’ values specific to
     this function are:

     ‘ENOMEM’
             • At least some of the specified address range does not
               exist in the calling process’ virtual address space.
             • The locking would cause the process to exceed its locked
               page limit.

     ‘EPERM’
          The calling process is not superuser.

     ‘EINVAL’
          LEN is not positive.

     ‘ENOSYS’
          The kernel does not provide ‘mlock’ capability.

 -- Function: int mlock2 (const void *ADDR, size_t LEN, unsigned int
          FLAGS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is similar to ‘mlock’.  If FLAGS is zero, a call to
     ‘mlock2’ behaves exactly as the equivalent call to ‘mlock’.

     The FLAGS argument must be a combination of zero or more of the
     following flags:

     ‘MLOCK_ONFAULT’

          Only those pages in the specified address range which are
          already in memory are locked immediately.  Additional pages in
          the range are automatically locked in case of a page fault and
          allocation of memory.

     Like ‘mlock’, ‘mlock2’ returns zero on success and ‘-1’ on failure,
     setting ‘errno’ accordingly.  Additional ‘errno’ values defined for
     ‘mlock2’ are:

     ‘EINVAL’
          The specified (non-zero) FLAGS argument is not supported by
          this system.

   You can lock _all_ a process’ memory with ‘mlockall’.  You unlock
memory with ‘munlock’ or ‘munlockall’.

   To avoid all page faults in a C program, you have to use ‘mlockall’,
because some of the memory a program uses is hidden from the C code,
e.g.  the stack and automatic variables, and you wouldn’t know what
address to tell ‘mlock’.

 -- Function: int munlock (const void *ADDR, size_t LEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘munlock’ unlocks a range of the calling process’ virtual pages.

     ‘munlock’ is the inverse of ‘mlock’ and functions completely
     analogously to ‘mlock’, except that there is no ‘EPERM’ failure.

 -- Function: int mlockall (int FLAGS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘mlockall’ locks all the pages in a process’ virtual memory address
     space, and/or any that are added to it in the future.  This
     includes the pages of the code, data and stack segment, as well as
     shared libraries, user space kernel data, shared memory, and memory
     mapped files.

     FLAGS is a string of single bit flags represented by the following
     macros.  They tell ‘mlockall’ which of its functions you want.  All
     other bits must be zero.

     ‘MCL_CURRENT’
          Lock all pages which currently exist in the calling process’
          virtual address space.

     ‘MCL_FUTURE’
          Set a mode such that any pages added to the process’ virtual
          address space in the future will be locked from birth.  This
          mode does not affect future address spaces owned by the same
          process so exec, which replaces a process’ address space,
          wipes out ‘MCL_FUTURE’.  *Note Executing a File::.

     When the function returns successfully, and you specified
     ‘MCL_CURRENT’, all of the process’ pages are backed by (connected
     to) real frames (they are resident) and are marked to stay that
     way.  This means the function may cause page-ins and have to wait
     for them.

     When the process is in ‘MCL_FUTURE’ mode because it successfully
     executed this function and specified ‘MCL_CURRENT’, any system call
     by the process that requires space be added to its virtual address
     space fails with ‘errno’ = ‘ENOMEM’ if locking the additional space
     would cause the process to exceed its locked page limit.  In the
     case that the address space addition that can’t be accommodated is
     stack expansion, the stack expansion fails and the kernel sends a
     ‘SIGSEGV’ signal to the process.

     When the function fails, it does not affect the lock status of any
     pages or the future locking mode.

     The return value is zero if the function succeeds.  Otherwise, it
     is ‘-1’ and ‘errno’ is set accordingly.  ‘errno’ values specific to
     this function are:

     ‘ENOMEM’
             • At least some of the specified address range does not
               exist in the calling process’ virtual address space.
             • The locking would cause the process to exceed its locked
               page limit.

     ‘EPERM’
          The calling process is not superuser.

     ‘EINVAL’
          Undefined bits in FLAGS are not zero.

     ‘ENOSYS’
          The kernel does not provide ‘mlockall’ capability.

     You can lock just specific pages with ‘mlock’.  You unlock pages
     with ‘munlockall’ and ‘munlock’.

 -- Function: int munlockall (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘munlockall’ unlocks every page in the calling process’ virtual
     address space and turns off ‘MCL_FUTURE’ future locking mode.

     The return value is zero if the function succeeds.  Otherwise, it
     is ‘-1’ and ‘errno’ is set accordingly.  The only way this function
     can fail is for generic reasons that all functions and system calls
     can fail, so there are no specific ‘errno’ values.


File: libc.info,  Node: Character Handling,  Next: String and Array Utilities,  Prev: Memory,  Up: Top

4 Character Handling
********************

Programs that work with characters and strings often need to classify a
character—is it alphabetic, is it a digit, is it whitespace, and so
on—and perform case conversion operations on characters.  The functions
in the header file ‘ctype.h’ are provided for this purpose.

   Since the choice of locale and character set can alter the
classifications of particular character codes, all of these functions
are affected by the current locale.  (More precisely, they are affected
by the locale currently selected for character classification—the
‘LC_CTYPE’ category; see *note Locale Categories::.)

   The ISO C standard specifies two different sets of functions.  The
one set works on ‘char’ type characters, the other one on ‘wchar_t’ wide
characters (*note Extended Char Intro::).

* Menu:

* Classification of Characters::       Testing whether characters are
			                letters, digits, punctuation, etc.

* Case Conversion::                    Case mapping, and the like.
* Classification of Wide Characters::  Character class determination for
                                        wide characters.
* Using Wide Char Classes::            Notes on using the wide character
                                        classes.
* Wide Character Case Conversion::     Mapping of wide characters.


File: libc.info,  Node: Classification of Characters,  Next: Case Conversion,  Up: Character Handling

4.1 Classification of Characters
================================

This section explains the library functions for classifying characters.
For example, ‘isalpha’ is the function to test for an alphabetic
character.  It takes one argument, the character to test, and returns a
nonzero integer if the character is alphabetic, and zero otherwise.  You
would use it like this:

     if (isalpha (c))
       printf ("The character `%c' is alphabetic.\n", c);

   Each of the functions in this section tests for membership in a
particular class of characters; each has a name starting with ‘is’.
Each of them takes one argument, which is a character to test, and
returns an ‘int’ which is treated as a boolean value.  The character
argument is passed as an ‘int’, and it may be the constant value ‘EOF’
instead of a real character.

   The attributes of any given character can vary between locales.
*Note Locales::, for more information on locales.

   These functions are declared in the header file ‘ctype.h’.

 -- Function: int islower (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is a lower-case letter.  The letter need not be
     from the Latin alphabet, any alphabet representable is valid.

 -- Function: int isupper (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is an upper-case letter.  The letter need not be
     from the Latin alphabet, any alphabet representable is valid.

 -- Function: int isalpha (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is an alphabetic character (a letter).  If
     ‘islower’ or ‘isupper’ is true of a character, then ‘isalpha’ is
     also true.

     In some locales, there may be additional characters for which
     ‘isalpha’ is true—letters which are neither upper case nor lower
     case.  But in the standard ‘"C"’ locale, there are no such
     additional characters.

 -- Function: int isdigit (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is a decimal digit (‘0’ through ‘9’).

 -- Function: int isalnum (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is an alphanumeric character (a letter or
     number); in other words, if either ‘isalpha’ or ‘isdigit’ is true
     of a character, then ‘isalnum’ is also true.

 -- Function: int isxdigit (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is a hexadecimal digit.  Hexadecimal digits
     include the normal decimal digits ‘0’ through ‘9’ and the letters
     ‘A’ through ‘F’ and ‘a’ through ‘f’.

 -- Function: int ispunct (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is a punctuation character.  This means any
     printing character that is not alphanumeric or a space character.

 -- Function: int isspace (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is a "whitespace" character.  In the standard
     ‘"C"’ locale, ‘isspace’ returns true for only the standard
     whitespace characters:

     ‘' '’
          space

     ‘'\f'’
          formfeed

     ‘'\n'’
          newline

     ‘'\r'’
          carriage return

     ‘'\t'’
          horizontal tab

     ‘'\v'’
          vertical tab

 -- Function: int isblank (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is a blank character; that is, a space or a tab.
     This function was originally a GNU extension, but was added in
     ISO C99.

 -- Function: int isgraph (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is a graphic character; that is, a character that
     has a glyph associated with it.  The whitespace characters are not
     considered graphic.

 -- Function: int isprint (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is a printing character.  Printing characters
     include all the graphic characters, plus the space (‘ ’) character.

 -- Function: int iscntrl (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is a control character (that is, a character that
     is not a printing character).

 -- Function: int isascii (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Returns true if C is a 7-bit ‘unsigned char’ value that fits into
     the US/UK ASCII character set.  This function is a BSD extension
     and is also an SVID extension.


File: libc.info,  Node: Case Conversion,  Next: Classification of Wide Characters,  Prev: Classification of Characters,  Up: Character Handling

4.2 Case Conversion
===================

This section explains the library functions for performing conversions
such as case mappings on characters.  For example, ‘toupper’ converts
any character to upper case if possible.  If the character can’t be
converted, ‘toupper’ returns it unchanged.

   These functions take one argument of type ‘int’, which is the
character to convert, and return the converted character as an ‘int’.
If the conversion is not applicable to the argument given, the argument
is returned unchanged.

   *Compatibility Note:* In pre-ISO C dialects, instead of returning the
argument unchanged, these functions may fail when the argument is not
suitable for the conversion.  Thus for portability, you may need to
write ‘islower(c) ? toupper(c) : c’ rather than just ‘toupper(c)’.

   These functions are declared in the header file ‘ctype.h’.

 -- Function: int tolower (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     If C is an upper-case letter, ‘tolower’ returns the corresponding
     lower-case letter.  If C is not an upper-case letter, C is returned
     unchanged.

 -- Function: int toupper (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     If C is a lower-case letter, ‘toupper’ returns the corresponding
     upper-case letter.  Otherwise C is returned unchanged.

 -- Function: int toascii (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function converts C to a 7-bit ‘unsigned char’ value that fits
     into the US/UK ASCII character set, by clearing the high-order
     bits.  This function is a BSD extension and is also an SVID
     extension.

 -- Function: int _tolower (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is identical to ‘tolower’, and is provided for compatibility
     with the SVID. *Note SVID::.

 -- Function: int _toupper (int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is identical to ‘toupper’, and is provided for compatibility
     with the SVID.


File: libc.info,  Node: Classification of Wide Characters,  Next: Using Wide Char Classes,  Prev: Case Conversion,  Up: Character Handling

4.3 Character class determination for wide characters
=====================================================

Amendment 1 to ISO C90 defines functions to classify wide characters.
Although the original ISO C90 standard already defined the type
‘wchar_t’, no functions operating on them were defined.

   The general design of the classification functions for wide
characters is more general.  It allows extensions to the set of
available classifications, beyond those which are always available.  The
POSIX standard specifies how extensions can be made, and this is already
implemented in the GNU C Library implementation of the ‘localedef’
program.

   The character class functions are normally implemented with bitsets,
with a bitset per character.  For a given character, the appropriate
bitset is read from a table and a test is performed as to whether a
certain bit is set.  Which bit is tested for is determined by the class.

   For the wide character classification functions this is made visible.
There is a type classification type defined, a function to retrieve this
value for a given class, and a function to test whether a given
character is in this class, using the classification value.  On top of
this the normal character classification functions as used for ‘char’
objects can be defined.

 -- Data type: wctype_t

     The ‘wctype_t’ can hold a value which represents a character class.
     The only defined way to generate such a value is by using the
     ‘wctype’ function.

     This type is defined in ‘wctype.h’.

 -- Function: wctype_t wctype (const char *PROPERTY)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     ‘wctype’ returns a value representing a class of wide characters
     which is identified by the string PROPERTY.  Besides some standard
     properties each locale can define its own ones.  In case no
     property with the given name is known for the current locale
     selected for the ‘LC_CTYPE’ category, the function returns zero.

     The properties known in every locale are:

     ‘"alnum"’          ‘"alpha"’          ‘"cntrl"’          ‘"digit"’
     ‘"graph"’          ‘"lower"’          ‘"print"’          ‘"punct"’
     ‘"space"’          ‘"upper"’          ‘"xdigit"’

     This function is declared in ‘wctype.h’.

   To test the membership of a character to one of the non-standard
classes the ISO C standard defines a completely new function.

 -- Function: int iswctype (wint_t WC, wctype_t DESC)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function returns a nonzero value if WC is in the character
     class specified by DESC.  DESC must previously be returned by a
     successful call to ‘wctype’.

     This function is declared in ‘wctype.h’.

   To make it easier to use the commonly-used classification functions,
they are defined in the C library.  There is no need to use ‘wctype’ if
the property string is one of the known character classes.  In some
situations it is desirable to construct the property strings, and then
it is important that ‘wctype’ can also handle the standard classes.

 -- Function: int iswalnum (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     This function returns a nonzero value if WC is an alphanumeric
     character (a letter or number); in other words, if either
     ‘iswalpha’ or ‘iswdigit’ is true of a character, then ‘iswalnum’ is
     also true.

     This function can be implemented using

          iswctype (wc, wctype ("alnum"))

     It is declared in ‘wctype.h’.

 -- Function: int iswalpha (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     Returns true if WC is an alphabetic character (a letter).  If
     ‘iswlower’ or ‘iswupper’ is true of a character, then ‘iswalpha’ is
     also true.

     In some locales, there may be additional characters for which
     ‘iswalpha’ is true—letters which are neither upper case nor lower
     case.  But in the standard ‘"C"’ locale, there are no such
     additional characters.

     This function can be implemented using

          iswctype (wc, wctype ("alpha"))

     It is declared in ‘wctype.h’.

 -- Function: int iswcntrl (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     Returns true if WC is a control character (that is, a character
     that is not a printing character).

     This function can be implemented using

          iswctype (wc, wctype ("cntrl"))

     It is declared in ‘wctype.h’.

 -- Function: int iswdigit (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     Returns true if WC is a digit (e.g., ‘0’ through ‘9’).  Please note
     that this function does not only return a nonzero value for
     _decimal_ digits, but for all kinds of digits.  A consequence is
     that code like the following will *not* work unconditionally for
     wide characters:

          n = 0;
          while (iswdigit (*wc))
            {
              n *= 10;
              n += *wc++ - L'0';
            }

     This function can be implemented using

          iswctype (wc, wctype ("digit"))

     It is declared in ‘wctype.h’.

 -- Function: int iswgraph (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     Returns true if WC is a graphic character; that is, a character
     that has a glyph associated with it.  The whitespace characters are
     not considered graphic.

     This function can be implemented using

          iswctype (wc, wctype ("graph"))

     It is declared in ‘wctype.h’.

 -- Function: int iswlower (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     Returns true if WC is a lower-case letter.  The letter need not be
     from the Latin alphabet, any alphabet representable is valid.

     This function can be implemented using

          iswctype (wc, wctype ("lower"))

     It is declared in ‘wctype.h’.

 -- Function: int iswprint (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     Returns true if WC is a printing character.  Printing characters
     include all the graphic characters, plus the space (‘ ’) character.

     This function can be implemented using

          iswctype (wc, wctype ("print"))

     It is declared in ‘wctype.h’.

 -- Function: int iswpunct (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     Returns true if WC is a punctuation character.  This means any
     printing character that is not alphanumeric or a space character.

     This function can be implemented using

          iswctype (wc, wctype ("punct"))

     It is declared in ‘wctype.h’.

 -- Function: int iswspace (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     Returns true if WC is a "whitespace" character.  In the standard
     ‘"C"’ locale, ‘iswspace’ returns true for only the standard
     whitespace characters:

     ‘L' '’
          space

     ‘L'\f'’
          formfeed

     ‘L'\n'’
          newline

     ‘L'\r'’
          carriage return

     ‘L'\t'’
          horizontal tab

     ‘L'\v'’
          vertical tab

     This function can be implemented using

          iswctype (wc, wctype ("space"))

     It is declared in ‘wctype.h’.

 -- Function: int iswupper (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     Returns true if WC is an upper-case letter.  The letter need not be
     from the Latin alphabet, any alphabet representable is valid.

     This function can be implemented using

          iswctype (wc, wctype ("upper"))

     It is declared in ‘wctype.h’.

 -- Function: int iswxdigit (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     Returns true if WC is a hexadecimal digit.  Hexadecimal digits
     include the normal decimal digits ‘0’ through ‘9’ and the letters
     ‘A’ through ‘F’ and ‘a’ through ‘f’.

     This function can be implemented using

          iswctype (wc, wctype ("xdigit"))

     It is declared in ‘wctype.h’.

   The GNU C Library also provides a function which is not defined in
the ISO C standard but which is available as a version for single byte
characters as well.

 -- Function: int iswblank (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     Returns true if WC is a blank character; that is, a space or a tab.
     This function was originally a GNU extension, but was added in
     ISO C99.  It is declared in ‘wchar.h’.


File: libc.info,  Node: Using Wide Char Classes,  Next: Wide Character Case Conversion,  Prev: Classification of Wide Characters,  Up: Character Handling

4.4 Notes on using the wide character classes
=============================================

The first note is probably not astonishing but still occasionally a
cause of problems.  The ‘iswXXX’ functions can be implemented using
macros and in fact, the GNU C Library does this.  They are still
available as real functions but when the ‘wctype.h’ header is included
the macros will be used.  This is the same as the ‘char’ type versions
of these functions.

   The second note covers something new.  It can be best illustrated by
a (real-world) example.  The first piece of code is an excerpt from the
original code.  It is truncated a bit but the intention should be clear.

     int
     is_in_class (int c, const char *class)
     {
       if (strcmp (class, "alnum") == 0)
         return isalnum (c);
       if (strcmp (class, "alpha") == 0)
         return isalpha (c);
       if (strcmp (class, "cntrl") == 0)
         return iscntrl (c);
       …
       return 0;
     }

   Now, with the ‘wctype’ and ‘iswctype’ you can avoid the ‘if’
cascades, but rewriting the code as follows is wrong:

     int
     is_in_class (int c, const char *class)
     {
       wctype_t desc = wctype (class);
       return desc ? iswctype ((wint_t) c, desc) : 0;
     }

   The problem is that it is not guaranteed that the wide character
representation of a single-byte character can be found using casting.
In fact, usually this fails miserably.  The correct solution to this
problem is to write the code as follows:

     int
     is_in_class (int c, const char *class)
     {
       wctype_t desc = wctype (class);
       return desc ? iswctype (btowc (c), desc) : 0;
     }

   *Note Converting a Character::, for more information on ‘btowc’.
Note that this change probably does not improve the performance of the
program a lot since the ‘wctype’ function still has to make the string
comparisons.  It gets really interesting if the ‘is_in_class’ function
is called more than once for the same class name.  In this case the
variable DESC could be computed once and reused for all the calls.
Therefore the above form of the function is probably not the final one.


File: libc.info,  Node: Wide Character Case Conversion,  Prev: Using Wide Char Classes,  Up: Character Handling

4.5 Mapping of wide characters.
===============================

The classification functions are also generalized by the ISO C standard.
Instead of just allowing the two standard mappings, a locale can contain
others.  Again, the ‘localedef’ program already supports generating such
locale data files.

 -- Data Type: wctrans_t

     This data type is defined as a scalar type which can hold a value
     representing the locale-dependent character mapping.  There is no
     way to construct such a value apart from using the return value of
     the ‘wctrans’ function.

     This type is defined in ‘wctype.h’.

 -- Function: wctrans_t wctrans (const char *PROPERTY)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The ‘wctrans’ function has to be used to find out whether a named
     mapping is defined in the current locale selected for the
     ‘LC_CTYPE’ category.  If the returned value is non-zero, you can
     use it afterwards in calls to ‘towctrans’.  If the return value is
     zero no such mapping is known in the current locale.

     Beside locale-specific mappings there are two mappings which are
     guaranteed to be available in every locale:

     ‘"tolower"’                          ‘"toupper"’

     These functions are declared in ‘wctype.h’.

 -- Function: wint_t towctrans (wint_t WC, wctrans_t DESC)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘towctrans’ maps the input character WC according to the rules of
     the mapping for which DESC is a descriptor, and returns the value
     it finds.  DESC must be obtained by a successful call to ‘wctrans’.

     This function is declared in ‘wctype.h’.

   For the generally available mappings, the ISO C standard defines
convenient shortcuts so that it is not necessary to call ‘wctrans’ for
them.

 -- Function: wint_t towlower (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     If WC is an upper-case letter, ‘towlower’ returns the corresponding
     lower-case letter.  If WC is not an upper-case letter, WC is
     returned unchanged.

     ‘towlower’ can be implemented using

          towctrans (wc, wctrans ("tolower"))

     This function is declared in ‘wctype.h’.

 -- Function: wint_t towupper (wint_t WC)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     If WC is a lower-case letter, ‘towupper’ returns the corresponding
     upper-case letter.  Otherwise WC is returned unchanged.

     ‘towupper’ can be implemented using

          towctrans (wc, wctrans ("toupper"))

     This function is declared in ‘wctype.h’.

   The same warnings given in the last section for the use of the wide
character classification functions apply here.  It is not possible to
simply cast a ‘char’ type value to a ‘wint_t’ and use it as an argument
to ‘towctrans’ calls.


File: libc.info,  Node: String and Array Utilities,  Next: Character Set Handling,  Prev: Character Handling,  Up: Top

5 String and Array Utilities
****************************

Operations on strings (null-terminated byte sequences) are an important
part of many programs.  The GNU C Library provides an extensive set of
string utility functions, including functions for copying,
concatenating, comparing, and searching strings.  Many of these
functions can also operate on arbitrary regions of storage; for example,
the ‘memcpy’ function can be used to copy the contents of any kind of
array.

   It’s fairly common for beginning C programmers to “reinvent the
wheel” by duplicating this functionality in their own code, but it pays
to become familiar with the library functions and to make use of them,
since this offers benefits in maintenance, efficiency, and portability.

   For instance, you could easily compare one string to another in two
lines of C code, but if you use the built-in ‘strcmp’ function, you’re
less likely to make a mistake.  And, since these library functions are
typically highly optimized, your program may run faster too.

* Menu:

* Representation of Strings::   Introduction to basic concepts.
* String/Array Conventions::    Whether to use a string function or an
				 arbitrary array function.
* String Length::               Determining the length of a string.
* Copying Strings and Arrays::  Functions to copy strings and arrays.
* Concatenating Strings::       Functions to concatenate strings while copying.
* Truncating Strings::          Functions to truncate strings while copying.
* String/Array Comparison::     Functions for byte-wise and character-wise
				 comparison.
* Collation Functions::         Functions for collating strings.
* Search Functions::            Searching for a specific element or substring.
* Finding Tokens in a String::  Splitting a string into tokens by looking
				 for delimiters.
* Erasing Sensitive Data::      Clearing memory which contains sensitive
                                 data, after it’s no longer needed.
* Shuffling Bytes::             Or how to flash-cook a string.
* Obfuscating Data::            Reversibly obscuring data from casual view.
* Encode Binary Data::          Encoding and Decoding of Binary Data.
* Argz and Envz Vectors::       Null-separated string vectors.


File: libc.info,  Node: Representation of Strings,  Next: String/Array Conventions,  Up: String and Array Utilities

5.1 Representation of Strings
=============================

This section is a quick summary of string concepts for beginning C
programmers.  It describes how strings are represented in C and some
common pitfalls.  If you are already familiar with this material, you
can skip this section.

   A "string" is a null-terminated array of bytes of type ‘char’,
including the terminating null byte.  String-valued variables are
usually declared to be pointers of type ‘char *’.  Such variables do not
include space for the text of a string; that has to be stored somewhere
else—in an array variable, a string constant, or dynamically allocated
memory (*note Memory Allocation::).  It’s up to you to store the address
of the chosen memory space into the pointer variable.  Alternatively you
can store a "null pointer" in the pointer variable.  The null pointer
does not point anywhere, so attempting to reference the string it points
to gets an error.

   A "multibyte character" is a sequence of one or more bytes that
represents a single character using the locale’s encoding scheme; a null
byte always represents the null character.  A "multibyte string" is a
string that consists entirely of multibyte characters.  In contrast, a
"wide string" is a null-terminated sequence of ‘wchar_t’ objects.  A
wide-string variable is usually declared to be a pointer of type
‘wchar_t *’, by analogy with string variables and ‘char *’.  *Note
Extended Char Intro::.

   By convention, the "null byte", ‘'\0'’, marks the end of a string and
the "null wide character", ‘L'\0'’, marks the end of a wide string.  For
example, in testing to see whether the ‘char *’ variable P points to a
null byte marking the end of a string, you can write ‘!*P’ or ‘*P ==
'\0'’.

   A null byte is quite different conceptually from a null pointer,
although both are represented by the integer constant ‘0’.

   A "string literal" appears in C program source as a multibyte string
between double-quote characters (‘"’).  If the initial double-quote
character is immediately preceded by a capital ‘L’ (ell) character (as
in ‘L"foo"’), it is a wide string literal.  String literals can also
contribute to "string concatenation": ‘"a" "b"’ is the same as ‘"ab"’.
For wide strings one can use either ‘L"a" L"b"’ or ‘L"a" "b"’.
Modification of string literals is not allowed by the GNU C compiler,
because literals are placed in read-only storage.

   Arrays that are declared ‘const’ cannot be modified either.  It’s
generally good style to declare non-modifiable string pointers to be of
type ‘const char *’, since this often allows the C compiler to detect
accidental modifications as well as providing some amount of
documentation about what your program intends to do with the string.

   The amount of memory allocated for a byte array may extend past the
null byte that marks the end of the string that the array contains.  In
this document, the term "allocated size" is always used to refer to the
total amount of memory allocated for an array, while the term "length"
refers to the number of bytes up to (but not including) the terminating
null byte.  Wide strings are similar, except their sizes and lengths
count wide characters, not bytes.

   A notorious source of program bugs is trying to put more bytes into a
string than fit in its allocated size.  When writing code that extends
strings or moves bytes into a pre-allocated array, you should be very
careful to keep track of the length of the text and make explicit checks
for overflowing the array.  Many of the library functions _do not_ do
this for you!  Remember also that you need to allocate an extra byte to
hold the null byte that marks the end of the string.

   Originally strings were sequences of bytes where each byte
represented a single character.  This is still true today if the strings
are encoded using a single-byte character encoding.  Things are
different if the strings are encoded using a multibyte encoding (for
more information on encodings see *note Extended Char Intro::).  There
is no difference in the programming interface for these two kind of
strings; the programmer has to be aware of this and interpret the byte
sequences accordingly.

   But since there is no separate interface taking care of these
differences the byte-based string functions are sometimes hard to use.
Since the count parameters of these functions specify bytes a call to
‘memcpy’ could cut a multibyte character in the middle and put an
incomplete (and therefore unusable) byte sequence in the target buffer.

   To avoid these problems later versions of the ISO C standard
introduce a second set of functions which are operating on "wide
characters" (*note Extended Char Intro::).  These functions don’t have
the problems the single-byte versions have since every wide character is
a legal, interpretable value.  This does not mean that cutting wide
strings at arbitrary points is without problems.  It normally is for
alphabet-based languages (except for non-normalized text) but languages
based on syllables still have the problem that more than one wide
character is necessary to complete a logical unit.  This is a higher
level problem which the C library functions are not designed to solve.
But it is at least good that no invalid byte sequences can be created.
Also, the higher level functions can also much more easily operate on
wide characters than on multibyte characters so that a common strategy
is to use wide characters internally whenever text is more than simply
copied.

   The remaining of this chapter will discuss the functions for handling
wide strings in parallel with the discussion of strings since there is
almost always an exact equivalent available.


File: libc.info,  Node: String/Array Conventions,  Next: String Length,  Prev: Representation of Strings,  Up: String and Array Utilities

5.2 String and Array Conventions
================================

This chapter describes both functions that work on arbitrary arrays or
blocks of memory, and functions that are specific to strings and wide
strings.

   Functions that operate on arbitrary blocks of memory have names
beginning with ‘mem’ and ‘wmem’ (such as ‘memcpy’ and ‘wmemcpy’) and
invariably take an argument which specifies the size (in bytes and wide
characters respectively) of the block of memory to operate on.  The
array arguments and return values for these functions have type ‘void *’
or ‘wchar_t’.  As a matter of style, the elements of the arrays used
with the ‘mem’ functions are referred to as “bytes”.  You can pass any
kind of pointer to these functions, and the ‘sizeof’ operator is useful
in computing the value for the size argument.  Parameters to the ‘wmem’
functions must be of type ‘wchar_t *’.  These functions are not really
usable with anything but arrays of this type.

   In contrast, functions that operate specifically on strings and wide
strings have names beginning with ‘str’ and ‘wcs’ respectively (such as
‘strcpy’ and ‘wcscpy’) and look for a terminating null byte or null wide
character instead of requiring an explicit size argument to be passed.
(Some of these functions accept a specified maximum length, but they
also check for premature termination.)  The array arguments and return
values for these functions have type ‘char *’ and ‘wchar_t *’
respectively, and the array elements are referred to as “bytes” and
“wide characters”.

   In many cases, there are both ‘mem’ and ‘str’/‘wcs’ versions of a
function.  The one that is more appropriate to use depends on the exact
situation.  When your program is manipulating arbitrary arrays or blocks
of storage, then you should always use the ‘mem’ functions.  On the
other hand, when you are manipulating strings it is usually more
convenient to use the ‘str’/‘wcs’ functions, unless you already know the
length of the string in advance.  The ‘wmem’ functions should be used
for wide character arrays with known size.

   Some of the memory and string functions take single characters as
arguments.  Since a value of type ‘char’ is automatically promoted into
a value of type ‘int’ when used as a parameter, the functions are
declared with ‘int’ as the type of the parameter in question.  In case
of the wide character functions the situation is similar: the parameter
type for a single wide character is ‘wint_t’ and not ‘wchar_t’.  This
would for many implementations not be necessary since ‘wchar_t’ is large
enough to not be automatically promoted, but since the ISO C standard
does not require such a choice of types the ‘wint_t’ type is used.


File: libc.info,  Node: String Length,  Next: Copying Strings and Arrays,  Prev: String/Array Conventions,  Up: String and Array Utilities

5.3 String Length
=================

You can get the length of a string using the ‘strlen’ function.  This
function is declared in the header file ‘string.h’.

 -- Function: size_t strlen (const char *S)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘strlen’ function returns the length of the string S in bytes.
     (In other words, it returns the offset of the terminating null byte
     within the array.)

     For example,
          strlen ("hello, world")
              ⇒ 12

     When applied to an array, the ‘strlen’ function returns the length
     of the string stored there, not its allocated size.  You can get
     the allocated size of the array that holds a string using the
     ‘sizeof’ operator:

          char string[32] = "hello, world";
          sizeof (string)
              ⇒ 32
          strlen (string)
              ⇒ 12

     But beware, this will not work unless STRING is the array itself,
     not a pointer to it.  For example:

          char string[32] = "hello, world";
          char *ptr = string;
          sizeof (string)
              ⇒ 32
          sizeof (ptr)
              ⇒ 4  /* (on a machine with 4 byte pointers) */

     This is an easy mistake to make when you are working with functions
     that take string arguments; those arguments are always pointers,
     not arrays.

     It must also be noted that for multibyte encoded strings the return
     value does not have to correspond to the number of characters in
     the string.  To get this value the string can be converted to wide
     characters and ‘wcslen’ can be used or something like the following
     code can be used:

          /* The input is in ‘string’.
             The length is expected in ‘n’.  */
          {
            mbstate_t t;
            char *scopy = string;
            /* In initial state.  */
            memset (&t, '\0', sizeof (t));
            /* Determine number of characters.  */
            n = mbsrtowcs (NULL, &scopy, strlen (scopy), &t);
          }

     This is cumbersome to do so if the number of characters (as opposed
     to bytes) is needed often it is better to work with wide
     characters.

   The wide character equivalent is declared in ‘wchar.h’.

 -- Function: size_t wcslen (const wchar_t *WS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘wcslen’ function is the wide character equivalent to ‘strlen’.
     The return value is the number of wide characters in the wide
     string pointed to by WS (this is also the offset of the terminating
     null wide character of WS).

     Since there are no multi wide character sequences making up one
     wide character the return value is not only the offset in the
     array, it is also the number of wide characters.

     This function was introduced in Amendment 1 to ISO C90.

 -- Function: size_t strnlen (const char *S, size_t MAXLEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     If the array S of size MAXLEN contains a null byte, the ‘strnlen’
     function returns the length of the string S in bytes.  Otherwise it
     returns MAXLEN.  Therefore this function is equivalent to ‘(strlen
     (S) < MAXLEN ? strlen (S) : MAXLEN)’ but it is more efficient and
     works even if S is not null-terminated so long as MAXLEN does not
     exceed the size of S’s array.

          char string[32] = "hello, world";
          strnlen (string, 32)
              ⇒ 12
          strnlen (string, 5)
              ⇒ 5

     This function is a GNU extension and is declared in ‘string.h’.

 -- Function: size_t wcsnlen (const wchar_t *WS, size_t MAXLEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘wcsnlen’ is the wide character equivalent to ‘strnlen’.  The
     MAXLEN parameter specifies the maximum number of wide characters.

     This function is a GNU extension and is declared in ‘wchar.h’.


File: libc.info,  Node: Copying Strings and Arrays,  Next: Concatenating Strings,  Prev: String Length,  Up: String and Array Utilities

5.4 Copying Strings and Arrays
==============================

You can use the functions described in this section to copy the contents
of strings, wide strings, and arrays.  The ‘str’ and ‘mem’ functions are
declared in ‘string.h’ while the ‘w’ functions are declared in
‘wchar.h’.

   A helpful way to remember the ordering of the arguments to the
functions in this section is that it corresponds to an assignment
expression, with the destination array specified to the left of the
source array.  Most of these functions return the address of the
destination array; a few return the address of the destination’s
terminating null, or of just past the destination.

   Most of these functions do not work properly if the source and
destination arrays overlap.  For example, if the beginning of the
destination array overlaps the end of the source array, the original
contents of that part of the source array may get overwritten before it
is copied.  Even worse, in the case of the string functions, the null
byte marking the end of the string may be lost, and the copy function
might get stuck in a loop trashing all the memory allocated to your
program.

   All functions that have problems copying between overlapping arrays
are explicitly identified in this manual.  In addition to functions in
this section, there are a few others like ‘sprintf’ (*note Formatted
Output Functions::) and ‘scanf’ (*note Formatted Input Functions::).

 -- Function: void * memcpy (void *restrict TO, const void *restrict
          FROM, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘memcpy’ function copies SIZE bytes from the object beginning
     at FROM into the object beginning at TO.  The behavior of this
     function is undefined if the two arrays TO and FROM overlap; use
     ‘memmove’ instead if overlapping is possible.

     The value returned by ‘memcpy’ is the value of TO.

     Here is an example of how you might use ‘memcpy’ to copy the
     contents of an array:

          struct foo *oldarray, *newarray;
          int arraysize;
          …
          memcpy (new, old, arraysize * sizeof (struct foo));

 -- Function: wchar_t * wmemcpy (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘wmemcpy’ function copies SIZE wide characters from the object
     beginning at WFROM into the object beginning at WTO.  The behavior
     of this function is undefined if the two arrays WTO and WFROM
     overlap; use ‘wmemmove’ instead if overlapping is possible.

     The following is a possible implementation of ‘wmemcpy’ but there
     are more optimizations possible.

          wchar_t *
          wmemcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,
                   size_t size)
          {
            return (wchar_t *) memcpy (wto, wfrom, size * sizeof (wchar_t));
          }

     The value returned by ‘wmemcpy’ is the value of WTO.

     This function was introduced in Amendment 1 to ISO C90.

 -- Function: void * mempcpy (void *restrict TO, const void *restrict
          FROM, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘mempcpy’ function is nearly identical to the ‘memcpy’
     function.  It copies SIZE bytes from the object beginning at ‘from’
     into the object pointed to by TO.  But instead of returning the
     value of TO it returns a pointer to the byte following the last
     written byte in the object beginning at TO.  I.e., the value is
     ‘((void *) ((char *) TO + SIZE))’.

     This function is useful in situations where a number of objects
     shall be copied to consecutive memory positions.

          void *
          combine (void *o1, size_t s1, void *o2, size_t s2)
          {
            void *result = malloc (s1 + s2);
            if (result != NULL)
              mempcpy (mempcpy (result, o1, s1), o2, s2);
            return result;
          }

     This function is a GNU extension.

 -- Function: wchar_t * wmempcpy (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘wmempcpy’ function is nearly identical to the ‘wmemcpy’
     function.  It copies SIZE wide characters from the object beginning
     at ‘wfrom’ into the object pointed to by WTO.  But instead of
     returning the value of WTO it returns a pointer to the wide
     character following the last written wide character in the object
     beginning at WTO.  I.e., the value is ‘WTO + SIZE’.

     This function is useful in situations where a number of objects
     shall be copied to consecutive memory positions.

     The following is a possible implementation of ‘wmemcpy’ but there
     are more optimizations possible.

          wchar_t *
          wmempcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,
                    size_t size)
          {
            return (wchar_t *) mempcpy (wto, wfrom, size * sizeof (wchar_t));
          }

     This function is a GNU extension.

 -- Function: void * memmove (void *TO, const void *FROM, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘memmove’ copies the SIZE bytes at FROM into the SIZE bytes at TO,
     even if those two blocks of space overlap.  In the case of overlap,
     ‘memmove’ is careful to copy the original values of the bytes in
     the block at FROM, including those bytes which also belong to the
     block at TO.

     The value returned by ‘memmove’ is the value of TO.

 -- Function: wchar_t * wmemmove (wchar_t *WTO, const wchar_t *WFROM,
          size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘wmemmove’ copies the SIZE wide characters at WFROM into the SIZE
     wide characters at WTO, even if those two blocks of space overlap.
     In the case of overlap, ‘wmemmove’ is careful to copy the original
     values of the wide characters in the block at WFROM, including
     those wide characters which also belong to the block at WTO.

     The following is a possible implementation of ‘wmemcpy’ but there
     are more optimizations possible.

          wchar_t *
          wmempcpy (wchar_t *restrict wto, const wchar_t *restrict wfrom,
                    size_t size)
          {
            return (wchar_t *) mempcpy (wto, wfrom, size * sizeof (wchar_t));
          }

     The value returned by ‘wmemmove’ is the value of WTO.

     This function is a GNU extension.

 -- Function: void * memccpy (void *restrict TO, const void *restrict
          FROM, int C, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function copies no more than SIZE bytes from FROM to TO,
     stopping if a byte matching C is found.  The return value is a
     pointer into TO one byte past where C was copied, or a null pointer
     if no byte matching C appeared in the first SIZE bytes of FROM.

 -- Function: void * memset (void *BLOCK, int C, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function copies the value of C (converted to an ‘unsigned
     char’) into each of the first SIZE bytes of the object beginning at
     BLOCK.  It returns the value of BLOCK.

 -- Function: wchar_t * wmemset (wchar_t *BLOCK, wchar_t WC, size_t
          SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function copies the value of WC into each of the first SIZE
     wide characters of the object beginning at BLOCK.  It returns the
     value of BLOCK.

 -- Function: char * strcpy (char *restrict TO, const char *restrict
          FROM)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This copies bytes from the string FROM (up to and including the
     terminating null byte) into the string TO.  Like ‘memcpy’, this
     function has undefined results if the strings overlap.  The return
     value is the value of TO.

 -- Function: wchar_t * wcscpy (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This copies wide characters from the wide string WFROM (up to and
     including the terminating null wide character) into the string WTO.
     Like ‘wmemcpy’, this function has undefined results if the strings
     overlap.  The return value is the value of WTO.

 -- Function: char * strdup (const char *S)

     Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem | *Note
     POSIX Safety Concepts::.

     This function copies the string S into a newly allocated string.
     The string is allocated using ‘malloc’; see *note Unconstrained
     Allocation::.  If ‘malloc’ cannot allocate space for the new
     string, ‘strdup’ returns a null pointer.  Otherwise it returns a
     pointer to the new string.

 -- Function: wchar_t * wcsdup (const wchar_t *WS)

     Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem | *Note
     POSIX Safety Concepts::.

     This function copies the wide string WS into a newly allocated
     string.  The string is allocated using ‘malloc’; see *note
     Unconstrained Allocation::.  If ‘malloc’ cannot allocate space for
     the new string, ‘wcsdup’ returns a null pointer.  Otherwise it
     returns a pointer to the new wide string.

     This function is a GNU extension.

 -- Function: char * stpcpy (char *restrict TO, const char *restrict
          FROM)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is like ‘strcpy’, except that it returns a pointer to
     the end of the string TO (that is, the address of the terminating
     null byte ‘to + strlen (from)’) rather than the beginning.

     For example, this program uses ‘stpcpy’ to concatenate ‘foo’ and
     ‘bar’ to produce ‘foobar’, which it then prints.


          #include <string.h>
          #include <stdio.h>

          int
          main (void)
          {
            char buffer[10];
            char *to = buffer;
            to = stpcpy (to, "foo");
            to = stpcpy (to, "bar");
            puts (buffer);
            return 0;
          }

     This function is part of POSIX.1-2008 and later editions, but was
     available in the GNU C Library and other systems as an extension
     long before it was standardized.

     Its behavior is undefined if the strings overlap.  The function is
     declared in ‘string.h’.

 -- Function: wchar_t * wcpcpy (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is like ‘wcscpy’, except that it returns a pointer to
     the end of the string WTO (that is, the address of the terminating
     null wide character ‘wto + wcslen (wfrom)’) rather than the
     beginning.

     This function is not part of ISO or POSIX but was found useful
     while developing the GNU C Library itself.

     The behavior of ‘wcpcpy’ is undefined if the strings overlap.

     ‘wcpcpy’ is a GNU extension and is declared in ‘wchar.h’.

 -- Macro: char * strdupa (const char *S)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro is similar to ‘strdup’ but allocates the new string
     using ‘alloca’ instead of ‘malloc’ (*note Variable Size
     Automatic::).  This means of course the returned string has the
     same limitations as any block of memory allocated using ‘alloca’.

     For obvious reasons ‘strdupa’ is implemented only as a macro; you
     cannot get the address of this function.  Despite this limitation
     it is a useful function.  The following code shows a situation
     where using ‘malloc’ would be a lot more expensive.


          #include <paths.h>
          #include <string.h>
          #include <stdio.h>

          const char path[] = _PATH_STDPATH;

          int
          main (void)
          {
            char *wr_path = strdupa (path);
            char *cp = strtok (wr_path, ":");

            while (cp != NULL)
              {
                puts (cp);
                cp = strtok (NULL, ":");
              }
            return 0;
          }

     Please note that calling ‘strtok’ using PATH directly is invalid.
     It is also not allowed to call ‘strdupa’ in the argument list of
     ‘strtok’ since ‘strdupa’ uses ‘alloca’ (*note Variable Size
     Automatic::) can interfere with the parameter passing.

     This function is only available if GNU CC is used.

 -- Function: void bcopy (const void *FROM, void *TO, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is a partially obsolete alternative for ‘memmove’, derived
     from BSD. Note that it is not quite equivalent to ‘memmove’,
     because the arguments are not in the same order and there is no
     return value.

 -- Function: void bzero (void *BLOCK, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is a partially obsolete alternative for ‘memset’, derived from
     BSD. Note that it is not as general as ‘memset’, because the only
     value it can store is zero.


File: libc.info,  Node: Concatenating Strings,  Next: Truncating Strings,  Prev: Copying Strings and Arrays,  Up: String and Array Utilities

5.5 Concatenating Strings
=========================

The functions described in this section concatenate the contents of a
string or wide string to another.  They follow the string-copying
functions in their conventions.  *Note Copying Strings and Arrays::.
‘strcat’ is declared in the header file ‘string.h’ while ‘wcscat’ is
declared in ‘wchar.h’.

 -- Function: char * strcat (char *restrict TO, const char *restrict
          FROM)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘strcat’ function is similar to ‘strcpy’, except that the bytes
     from FROM are concatenated or appended to the end of TO, instead of
     overwriting it.  That is, the first byte from FROM overwrites the
     null byte marking the end of TO.

     An equivalent definition for ‘strcat’ would be:

          char *
          strcat (char *restrict to, const char *restrict from)
          {
            strcpy (to + strlen (to), from);
            return to;
          }

     This function has undefined results if the strings overlap.

     As noted below, this function has significant performance issues.

 -- Function: wchar_t * wcscat (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘wcscat’ function is similar to ‘wcscpy’, except that the wide
     characters from WFROM are concatenated or appended to the end of
     WTO, instead of overwriting it.  That is, the first wide character
     from WFROM overwrites the null wide character marking the end of
     WTO.

     An equivalent definition for ‘wcscat’ would be:

          wchar_t *
          wcscat (wchar_t *wto, const wchar_t *wfrom)
          {
            wcscpy (wto + wcslen (wto), wfrom);
            return wto;
          }

     This function has undefined results if the strings overlap.

     As noted below, this function has significant performance issues.

   Programmers using the ‘strcat’ or ‘wcscat’ function (or the ‘strncat’
or ‘wcsncat’ functions defined in a later section, for that matter) can
easily be recognized as lazy and reckless.  In almost all situations the
lengths of the participating strings are known (it better should be
since how can one otherwise ensure the allocated size of the buffer is
sufficient?)  Or at least, one could know them if one keeps track of the
results of the various function calls.  But then it is very inefficient
to use ‘strcat’/‘wcscat’.  A lot of time is wasted finding the end of
the destination string so that the actual copying can start.  This is a
common example:

     /* This function concatenates arbitrarily many strings.  The last
        parameter must be ‘NULL’.  */
     char *
     concat (const char *str, …)
     {
       va_list ap, ap2;
       size_t total = 1;
       const char *s;
       char *result;

       va_start (ap, str);
       va_copy (ap2, ap);

       /* Determine how much space we need.  */
       for (s = str; s != NULL; s = va_arg (ap, const char *))
         total += strlen (s);

       va_end (ap);

       result = (char *) malloc (total);
       if (result != NULL)
         {
           result[0] = '\0';

           /* Copy the strings.  */
           for (s = str; s != NULL; s = va_arg (ap2, const char *))
             strcat (result, s);
         }

       va_end (ap2);

       return result;
     }

   This looks quite simple, especially the second loop where the strings
are actually copied.  But these innocent lines hide a major performance
penalty.  Just imagine that ten strings of 100 bytes each have to be
concatenated.  For the second string we search the already stored 100
bytes for the end of the string so that we can append the next string.
For all strings in total the comparisons necessary to find the end of
the intermediate results sums up to 5500!  If we combine the copying
with the search for the allocation we can write this function more
efficiently:

     char *
     concat (const char *str, …)
     {
       va_list ap;
       size_t allocated = 100;
       char *result = (char *) malloc (allocated);

       if (result != NULL)
         {
           char *newp;
           char *wp;
           const char *s;

           va_start (ap, str);

           wp = result;
           for (s = str; s != NULL; s = va_arg (ap, const char *))
             {
               size_t len = strlen (s);

               /* Resize the allocated memory if necessary.  */
               if (wp + len + 1 > result + allocated)
                 {
                   allocated = (allocated + len) * 2;
                   newp = (char *) realloc (result, allocated);
                   if (newp == NULL)
                     {
                       free (result);
                       return NULL;
                     }
                   wp = newp + (wp - result);
                   result = newp;
                 }

               wp = mempcpy (wp, s, len);
             }

           /* Terminate the result string.  */
           *wp++ = '\0';

           /* Resize memory to the optimal size.  */
           newp = realloc (result, wp - result);
           if (newp != NULL)
             result = newp;

           va_end (ap);
         }

       return result;
     }

   With a bit more knowledge about the input strings one could fine-tune
the memory allocation.  The difference we are pointing to here is that
we don’t use ‘strcat’ anymore.  We always keep track of the length of
the current intermediate result so we can save ourselves the search for
the end of the string and use ‘mempcpy’.  Please note that we also don’t
use ‘stpcpy’ which might seem more natural since we are handling
strings.  But this is not necessary since we already know the length of
the string and therefore can use the faster memory copying function.
The example would work for wide characters the same way.

   Whenever a programmer feels the need to use ‘strcat’ she or he should
think twice and look through the program to see whether the code cannot
be rewritten to take advantage of already calculated results.  Again: it
is almost always unnecessary to use ‘strcat’.


File: libc.info,  Node: Truncating Strings,  Next: String/Array Comparison,  Prev: Concatenating Strings,  Up: String and Array Utilities

5.6 Truncating Strings while Copying
====================================

The functions described in this section copy or concatenate the
possibly-truncated contents of a string or array to another, and
similarly for wide strings.  They follow the string-copying functions in
their header conventions.  *Note Copying Strings and Arrays::.  The
‘str’ functions are declared in the header file ‘string.h’ and the ‘wc’
functions are declared in the file ‘wchar.h’.

 -- Function: char * strncpy (char *restrict TO, const char *restrict
          FROM, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is similar to ‘strcpy’ but always copies exactly SIZE
     bytes into TO.

     If FROM does not contain a null byte in its first SIZE bytes,
     ‘strncpy’ copies just the first SIZE bytes.  In this case no null
     terminator is written into TO.

     Otherwise FROM must be a string with length less than SIZE.  In
     this case ‘strncpy’ copies all of FROM, followed by enough null
     bytes to add up to SIZE bytes in all.

     The behavior of ‘strncpy’ is undefined if the strings overlap.

     This function was designed for now-rarely-used arrays consisting of
     non-null bytes followed by zero or more null bytes.  It needs to
     set all SIZE bytes of the destination, even when SIZE is much
     greater than the length of FROM.  As noted below, this function is
     generally a poor choice for processing text.

 -- Function: wchar_t * wcsncpy (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is similar to ‘wcscpy’ but always copies exactly SIZE
     wide characters into WTO.

     If WFROM does not contain a null wide character in its first SIZE
     wide characters, then ‘wcsncpy’ copies just the first SIZE wide
     characters.  In this case no null terminator is written into WTO.

     Otherwise WFROM must be a wide string with length less than SIZE.
     In this case ‘wcsncpy’ copies all of WFROM, followed by enough null
     wide characters to add up to SIZE wide characters in all.

     The behavior of ‘wcsncpy’ is undefined if the strings overlap.

     This function is the wide-character counterpart of ‘strncpy’ and
     suffers from most of the problems that ‘strncpy’ does.  For
     example, as noted below, this function is generally a poor choice
     for processing text.

 -- Function: char * strndup (const char *S, size_t SIZE)

     Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem | *Note
     POSIX Safety Concepts::.

     This function is similar to ‘strdup’ but always copies at most SIZE
     bytes into the newly allocated string.

     If the length of S is more than SIZE, then ‘strndup’ copies just
     the first SIZE bytes and adds a closing null byte.  Otherwise all
     bytes are copied and the string is terminated.

     This function differs from ‘strncpy’ in that it always terminates
     the destination string.

     As noted below, this function is generally a poor choice for
     processing text.

     ‘strndup’ is a GNU extension.

 -- Macro: char * strndupa (const char *S, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is similar to ‘strndup’ but like ‘strdupa’ it
     allocates the new string using ‘alloca’ *note Variable Size
     Automatic::.  The same advantages and limitations of ‘strdupa’ are
     valid for ‘strndupa’, too.

     This function is implemented only as a macro, just like ‘strdupa’.
     Just as ‘strdupa’ this macro also must not be used inside the
     parameter list in a function call.

     As noted below, this function is generally a poor choice for
     processing text.

     ‘strndupa’ is only available if GNU CC is used.

 -- Function: char * stpncpy (char *restrict TO, const char *restrict
          FROM, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is similar to ‘stpcpy’ but copies always exactly SIZE
     bytes into TO.

     If the length of FROM is more than SIZE, then ‘stpncpy’ copies just
     the first SIZE bytes and returns a pointer to the byte directly
     following the one which was copied last.  Note that in this case
     there is no null terminator written into TO.

     If the length of FROM is less than SIZE, then ‘stpncpy’ copies all
     of FROM, followed by enough null bytes to add up to SIZE bytes in
     all.  This behavior is rarely useful, but it is implemented to be
     useful in contexts where this behavior of the ‘strncpy’ is used.
     ‘stpncpy’ returns a pointer to the _first_ written null byte.

     This function is not part of ISO or POSIX but was found useful
     while developing the GNU C Library itself.

     Its behavior is undefined if the strings overlap.  The function is
     declared in ‘string.h’.

     As noted below, this function is generally a poor choice for
     processing text.

 -- Function: wchar_t * wcpncpy (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is similar to ‘wcpcpy’ but copies always exactly
     WSIZE wide characters into WTO.

     If the length of WFROM is more than SIZE, then ‘wcpncpy’ copies
     just the first SIZE wide characters and returns a pointer to the
     wide character directly following the last non-null wide character
     which was copied last.  Note that in this case there is no null
     terminator written into WTO.

     If the length of WFROM is less than SIZE, then ‘wcpncpy’ copies all
     of WFROM, followed by enough null wide characters to add up to SIZE
     wide characters in all.  This behavior is rarely useful, but it is
     implemented to be useful in contexts where this behavior of the
     ‘wcsncpy’ is used.  ‘wcpncpy’ returns a pointer to the _first_
     written null wide character.

     This function is not part of ISO or POSIX but was found useful
     while developing the GNU C Library itself.

     Its behavior is undefined if the strings overlap.

     As noted below, this function is generally a poor choice for
     processing text.

     ‘wcpncpy’ is a GNU extension.

 -- Function: char * strncat (char *restrict TO, const char *restrict
          FROM, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is like ‘strcat’ except that not more than SIZE bytes
     from FROM are appended to the end of TO, and FROM need not be
     null-terminated.  A single null byte is also always appended to TO,
     so the total allocated size of TO must be at least ‘SIZE + 1’ bytes
     longer than its initial length.

     The ‘strncat’ function could be implemented like this:

          char *
          strncat (char *to, const char *from, size_t size)
          {
            size_t len = strlen (to);
            memcpy (to + len, from, strnlen (from, size));
            to[len + strnlen (from, size)] = '\0';
            return to;
          }

     The behavior of ‘strncat’ is undefined if the strings overlap.

     As a companion to ‘strncpy’, ‘strncat’ was designed for
     now-rarely-used arrays consisting of non-null bytes followed by
     zero or more null bytes.  As noted below, this function is
     generally a poor choice for processing text.  Also, this function
     has significant performance issues.  *Note Concatenating Strings::.

 -- Function: wchar_t * wcsncat (wchar_t *restrict WTO, const wchar_t
          *restrict WFROM, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is like ‘wcscat’ except that not more than SIZE wide
     characters from FROM are appended to the end of TO, and FROM need
     not be null-terminated.  A single null wide character is also
     always appended to TO, so the total allocated size of TO must be at
     least ‘wcsnlen (WFROM, SIZE) + 1’ wide characters longer than its
     initial length.

     The ‘wcsncat’ function could be implemented like this:

          wchar_t *
          wcsncat (wchar_t *restrict wto, const wchar_t *restrict wfrom,
                   size_t size)
          {
            size_t len = wcslen (wto);
            memcpy (wto + len, wfrom, wcsnlen (wfrom, size) * sizeof (wchar_t));
            wto[len + wcsnlen (wfrom, size)] = L'\0';
            return wto;
          }

     The behavior of ‘wcsncat’ is undefined if the strings overlap.

     As noted below, this function is generally a poor choice for
     processing text.  Also, this function has significant performance
     issues.  *Note Concatenating Strings::.

   Because these functions can abruptly truncate strings or wide
strings, they are generally poor choices for processing text.  When
coping or concatening multibyte strings, they can truncate within a
multibyte character so that the result is not a valid multibyte string.
When combining or concatenating multibyte or wide strings, they may
truncate the output after a combining character, resulting in a
corrupted grapheme.  They can cause bugs even when processing
single-byte strings: for example, when calculating an ASCII-only user
name, a truncated name can identify the wrong user.

   Although some buffer overruns can be prevented by manually replacing
calls to copying functions with calls to truncation functions, there are
often easier and safer automatic techniques that cause buffer overruns
to reliably terminate a program, such as GCC’s ‘-fcheck-pointer-bounds’
and ‘-fsanitize=address’ options.  *Note Options for Debugging Your
Program or GCC: (gcc)Debugging Options.  Because truncation functions
can mask application bugs that would otherwise be caught by the
automatic techniques, these functions should be used only when the
application’s underlying logic requires truncation.

   *Note:* GNU programs should not truncate strings or wide strings to
fit arbitrary size limits.  *Note Writing Robust Programs:
(standards)Semantics.  Instead of string-truncation functions, it is
usually better to use dynamic memory allocation (*note Unconstrained
Allocation::) and functions such as ‘strdup’ or ‘asprintf’ to construct
strings.


File: libc.info,  Node: String/Array Comparison,  Next: Collation Functions,  Prev: Truncating Strings,  Up: String and Array Utilities

5.7 String/Array Comparison
===========================

You can use the functions in this section to perform comparisons on the
contents of strings and arrays.  As well as checking for equality, these
functions can also be used as the ordering functions for sorting
operations.  *Note Searching and Sorting::, for an example of this.

   Unlike most comparison operations in C, the string comparison
functions return a nonzero value if the strings are _not_ equivalent
rather than if they are.  The sign of the value indicates the relative
ordering of the first part of the strings that are not equivalent: a
negative value indicates that the first string is “less” than the
second, while a positive value indicates that the first string is
“greater”.

   The most common use of these functions is to check only for equality.
This is canonically done with an expression like ‘! strcmp (s1, s2)’.

   All of these functions are declared in the header file ‘string.h’.

 -- Function: int memcmp (const void *A1, const void *A2, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The function ‘memcmp’ compares the SIZE bytes of memory beginning
     at A1 against the SIZE bytes of memory beginning at A2.  The value
     returned has the same sign as the difference between the first
     differing pair of bytes (interpreted as ‘unsigned char’ objects,
     then promoted to ‘int’).

     If the contents of the two blocks are equal, ‘memcmp’ returns ‘0’.

 -- Function: int wmemcmp (const wchar_t *A1, const wchar_t *A2, size_t
          SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The function ‘wmemcmp’ compares the SIZE wide characters beginning
     at A1 against the SIZE wide characters beginning at A2.  The value
     returned is smaller than or larger than zero depending on whether
     the first differing wide character is A1 is smaller or larger than
     the corresponding wide character in A2.

     If the contents of the two blocks are equal, ‘wmemcmp’ returns ‘0’.

   On arbitrary arrays, the ‘memcmp’ function is mostly useful for
testing equality.  It usually isn’t meaningful to do byte-wise ordering
comparisons on arrays of things other than bytes.  For example, a
byte-wise comparison on the bytes that make up floating-point numbers
isn’t likely to tell you anything about the relationship between the
values of the floating-point numbers.

   ‘wmemcmp’ is really only useful to compare arrays of type ‘wchar_t’
since the function looks at ‘sizeof (wchar_t)’ bytes at a time and this
number of bytes is system dependent.

   You should also be careful about using ‘memcmp’ to compare objects
that can contain “holes”, such as the padding inserted into structure
objects to enforce alignment requirements, extra space at the end of
unions, and extra bytes at the ends of strings whose length is less than
their allocated size.  The contents of these “holes” are indeterminate
and may cause strange behavior when performing byte-wise comparisons.
For more predictable results, perform an explicit component-wise
comparison.

   For example, given a structure type definition like:

     struct foo
       {
         unsigned char tag;
         union
           {
             double f;
             long i;
             char *p;
           } value;
       };

you are better off writing a specialized comparison function to compare
‘struct foo’ objects instead of comparing them with ‘memcmp’.

 -- Function: int strcmp (const char *S1, const char *S2)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘strcmp’ function compares the string S1 against S2, returning
     a value that has the same sign as the difference between the first
     differing pair of bytes (interpreted as ‘unsigned char’ objects,
     then promoted to ‘int’).

     If the two strings are equal, ‘strcmp’ returns ‘0’.

     A consequence of the ordering used by ‘strcmp’ is that if S1 is an
     initial substring of S2, then S1 is considered to be “less than”
     S2.

     ‘strcmp’ does not take sorting conventions of the language the
     strings are written in into account.  To get that one has to use
     ‘strcoll’.

 -- Function: int wcscmp (const wchar_t *WS1, const wchar_t *WS2)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘wcscmp’ function compares the wide string WS1 against WS2.
     The value returned is smaller than or larger than zero depending on
     whether the first differing wide character is WS1 is smaller or
     larger than the corresponding wide character in WS2.

     If the two strings are equal, ‘wcscmp’ returns ‘0’.

     A consequence of the ordering used by ‘wcscmp’ is that if WS1 is an
     initial substring of WS2, then WS1 is considered to be “less than”
     WS2.

     ‘wcscmp’ does not take sorting conventions of the language the
     strings are written in into account.  To get that one has to use
     ‘wcscoll’.

 -- Function: int strcasecmp (const char *S1, const char *S2)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     This function is like ‘strcmp’, except that differences in case are
     ignored, and its arguments must be multibyte strings.  How
     uppercase and lowercase characters are related is determined by the
     currently selected locale.  In the standard ‘"C"’ locale the
     characters Ä and ä do not match but in a locale which regards these
     characters as parts of the alphabet they do match.

     ‘strcasecmp’ is derived from BSD.

 -- Function: int wcscasecmp (const wchar_t *WS1, const wchar_t *WS2)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     This function is like ‘wcscmp’, except that differences in case are
     ignored.  How uppercase and lowercase characters are related is
     determined by the currently selected locale.  In the standard ‘"C"’
     locale the characters Ä and ä do not match but in a locale which
     regards these characters as parts of the alphabet they do match.

     ‘wcscasecmp’ is a GNU extension.

 -- Function: int strncmp (const char *S1, const char *S2, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is the similar to ‘strcmp’, except that no more than
     SIZE bytes are compared.  In other words, if the two strings are
     the same in their first SIZE bytes, the return value is zero.

 -- Function: int wcsncmp (const wchar_t *WS1, const wchar_t *WS2,
          size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function is similar to ‘wcscmp’, except that no more than SIZE
     wide characters are compared.  In other words, if the two strings
     are the same in their first SIZE wide characters, the return value
     is zero.

 -- Function: int strncasecmp (const char *S1, const char *S2, size_t N)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     This function is like ‘strncmp’, except that differences in case
     are ignored, and the compared parts of the arguments should consist
     of valid multibyte characters.  Like ‘strcasecmp’, it is locale
     dependent how uppercase and lowercase characters are related.

     ‘strncasecmp’ is a GNU extension.

 -- Function: int wcsncasecmp (const wchar_t *WS1, const wchar_t *S2,
          size_t N)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     This function is like ‘wcsncmp’, except that differences in case
     are ignored.  Like ‘wcscasecmp’, it is locale dependent how
     uppercase and lowercase characters are related.

     ‘wcsncasecmp’ is a GNU extension.

   Here are some examples showing the use of ‘strcmp’ and ‘strncmp’
(equivalent examples can be constructed for the wide character
functions).  These examples assume the use of the ASCII character set.
(If some other character set—say, EBCDIC—is used instead, then the
glyphs are associated with different numeric codes, and the return
values and ordering may differ.)

     strcmp ("hello", "hello")
         ⇒ 0    /* These two strings are the same. */
     strcmp ("hello", "Hello")
         ⇒ 32   /* Comparisons are case-sensitive. */
     strcmp ("hello", "world")
         ⇒ -15  /* The byte ‘'h'’ comes before ‘'w'’. */
     strcmp ("hello", "hello, world")
         ⇒ -44  /* Comparing a null byte against a comma. */
     strncmp ("hello", "hello, world", 5)
         ⇒ 0    /* The initial 5 bytes are the same. */
     strncmp ("hello, world", "hello, stupid world!!!", 5)
         ⇒ 0    /* The initial 5 bytes are the same. */

 -- Function: int strverscmp (const char *S1, const char *S2)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     The ‘strverscmp’ function compares the string S1 against S2,
     considering them as holding indices/version numbers.  The return
     value follows the same conventions as found in the ‘strcmp’
     function.  In fact, if S1 and S2 contain no digits, ‘strverscmp’
     behaves like ‘strcmp’ (in the sense that the sign of the result is
     the same).

     The comparison algorithm which the ‘strverscmp’ function implements
     differs slightly from other version-comparison algorithms.  The
     implementation is based on a finite-state machine, whose behavior
     is approximated below.

        • The input strings are each split into sequences of non-digits
          and digits.  These sequences can be empty at the beginning and
          end of the string.  Digits are determined by the ‘isdigit’
          function and are thus subject to the current locale.

        • Comparison starts with a (possibly empty) non-digit sequence.
          The first non-equal sequences of non-digits or digits
          determines the outcome of the comparison.

        • Corresponding non-digit sequences in both strings are compared
          lexicographically if their lengths are equal.  If the lengths
          differ, the shorter non-digit sequence is extended with the
          input string character immediately following it (which may be
          the null terminator), the other sequence is truncated to be of
          the same (extended) length, and these two sequences are
          compared lexicographically.  In the last case, the sequence
          comparison determines the result of the function because the
          extension character (or some character before it) is
          necessarily different from the character at the same offset in
          the other input string.

        • For two sequences of digits, the number of leading zeros is
          counted (which can be zero).  If the count differs, the string
          with more leading zeros in the digit sequence is considered
          smaller than the other string.

        • If the two sequences of digits have no leading zeros, they are
          compared as integers, that is, the string with the longer
          digit sequence is deemed larger, and if both sequences are of
          equal length, they are compared lexicographically.

        • If both digit sequences start with a zero and have an equal
          number of leading zeros, they are compared lexicographically
          if their lengths are the same.  If the lengths differ, the
          shorter sequence is extended with the following character in
          its input string, and the other sequence is truncated to the
          same length, and both sequences are compared lexicographically
          (similar to the non-digit sequence case above).

     The treatment of leading zeros and the tie-breaking extension
     characters (which in effect propagate across non-digit/digit
     sequence boundaries) differs from other version-comparison
     algorithms.

          strverscmp ("no digit", "no digit")
              ⇒ 0    /* same behavior as strcmp. */
          strverscmp ("item#99", "item#100")
              ⇒ <0   /* same prefix, but 99 < 100. */
          strverscmp ("alpha1", "alpha001")
              ⇒ >0   /* different number of leading zeros (0 and 2). */
          strverscmp ("part1_f012", "part1_f01")
              ⇒ >0   /* lexicographical comparison with leading zeros. */
          strverscmp ("foo.009", "foo.0")
              ⇒ <0   /* different number of leading zeros (2 and 1). */

     ‘strverscmp’ is a GNU extension.

 -- Function: int bcmp (const void *A1, const void *A2, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is an obsolete alias for ‘memcmp’, derived from BSD.


File: libc.info,  Node: Collation Functions,  Next: Search Functions,  Prev: String/Array Comparison,  Up: String and Array Utilities

5.8 Collation Functions
=======================

In some locales, the conventions for lexicographic ordering differ from
the strict numeric ordering of character codes.  For example, in Spanish
most glyphs with diacritical marks such as accents are not considered
distinct letters for the purposes of collation.  On the other hand, the
two-character sequence ‘ll’ is treated as a single letter that is
collated immediately after ‘l’.

   You can use the functions ‘strcoll’ and ‘strxfrm’ (declared in the
headers file ‘string.h’) and ‘wcscoll’ and ‘wcsxfrm’ (declared in the
headers file ‘wchar’) to compare strings using a collation ordering
appropriate for the current locale.  The locale used by these functions
in particular can be specified by setting the locale for the
‘LC_COLLATE’ category; see *note Locales::.

   In the standard C locale, the collation sequence for ‘strcoll’ is the
same as that for ‘strcmp’.  Similarly, ‘wcscoll’ and ‘wcscmp’ are the
same in this situation.

   Effectively, the way these functions work is by applying a mapping to
transform the characters in a multibyte string to a byte sequence that
represents the string’s position in the collating sequence of the
current locale.  Comparing two such byte sequences in a simple fashion
is equivalent to comparing the strings with the locale’s collating
sequence.

   The functions ‘strcoll’ and ‘wcscoll’ perform this translation
implicitly, in order to do one comparison.  By contrast, ‘strxfrm’ and
‘wcsxfrm’ perform the mapping explicitly.  If you are making multiple
comparisons using the same string or set of strings, it is likely to be
more efficient to use ‘strxfrm’ or ‘wcsxfrm’ to transform all the
strings just once, and subsequently compare the transformed strings with
‘strcmp’ or ‘wcscmp’.

 -- Function: int strcoll (const char *S1, const char *S2)

     Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem |
     *Note POSIX Safety Concepts::.

     The ‘strcoll’ function is similar to ‘strcmp’ but uses the
     collating sequence of the current locale for collation (the
     ‘LC_COLLATE’ locale).  The arguments are multibyte strings.

 -- Function: int wcscoll (const wchar_t *WS1, const wchar_t *WS2)

     Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem |
     *Note POSIX Safety Concepts::.

     The ‘wcscoll’ function is similar to ‘wcscmp’ but uses the
     collating sequence of the current locale for collation (the
     ‘LC_COLLATE’ locale).

   Here is an example of sorting an array of strings, using ‘strcoll’ to
compare them.  The actual sort algorithm is not written here; it comes
from ‘qsort’ (*note Array Sort Function::).  The job of the code shown
here is to say how to compare the strings while sorting them.  (Later on
in this section, we will show a way to do this more efficiently using
‘strxfrm’.)

     /* This is the comparison function used with ‘qsort’. */

     int
     compare_elements (const void *v1, const void *v2)
     {
       char * const *p1 = v1;
       char * const *p2 = v2;

       return strcoll (*p1, *p2);
     }

     /* This is the entry point—the function to sort
        strings using the locale’s collating sequence. */

     void
     sort_strings (char **array, int nstrings)
     {
       /* Sort ‘temp_array’ by comparing the strings. */
       qsort (array, nstrings,
              sizeof (char *), compare_elements);
     }

 -- Function: size_t strxfrm (char *restrict TO, const char *restrict
          FROM, size_t SIZE)

     Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem |
     *Note POSIX Safety Concepts::.

     The function ‘strxfrm’ transforms the multibyte string FROM using
     the collation transformation determined by the locale currently
     selected for collation, and stores the transformed string in the
     array TO.  Up to SIZE bytes (including a terminating null byte) are
     stored.

     The behavior is undefined if the strings TO and FROM overlap; see
     *note Copying Strings and Arrays::.

     The return value is the length of the entire transformed string.
     This value is not affected by the value of SIZE, but if it is
     greater or equal than SIZE, it means that the transformed string
     did not entirely fit in the array TO.  In this case, only as much
     of the string as actually fits was stored.  To get the whole
     transformed string, call ‘strxfrm’ again with a bigger output
     array.

     The transformed string may be longer than the original string, and
     it may also be shorter.

     If SIZE is zero, no bytes are stored in TO.  In this case,
     ‘strxfrm’ simply returns the number of bytes that would be the
     length of the transformed string.  This is useful for determining
     what size the allocated array should be.  It does not matter what
     TO is if SIZE is zero; TO may even be a null pointer.

 -- Function: size_t wcsxfrm (wchar_t *restrict WTO, const wchar_t
          *WFROM, size_t SIZE)

     Preliminary: | MT-Safe locale | AS-Unsafe heap | AC-Unsafe mem |
     *Note POSIX Safety Concepts::.

     The function ‘wcsxfrm’ transforms wide string WFROM using the
     collation transformation determined by the locale currently
     selected for collation, and stores the transformed string in the
     array WTO.  Up to SIZE wide characters (including a terminating
     null wide character) are stored.

     The behavior is undefined if the strings WTO and WFROM overlap; see
     *note Copying Strings and Arrays::.

     The return value is the length of the entire transformed wide
     string.  This value is not affected by the value of SIZE, but if it
     is greater or equal than SIZE, it means that the transformed wide
     string did not entirely fit in the array WTO.  In this case, only
     as much of the wide string as actually fits was stored.  To get the
     whole transformed wide string, call ‘wcsxfrm’ again with a bigger
     output array.

     The transformed wide string may be longer than the original wide
     string, and it may also be shorter.

     If SIZE is zero, no wide characters are stored in TO.  In this
     case, ‘wcsxfrm’ simply returns the number of wide characters that
     would be the length of the transformed wide string.  This is useful
     for determining what size the allocated array should be (remember
     to multiply with ‘sizeof (wchar_t)’).  It does not matter what WTO
     is if SIZE is zero; WTO may even be a null pointer.

   Here is an example of how you can use ‘strxfrm’ when you plan to do
many comparisons.  It does the same thing as the previous example, but
much faster, because it has to transform each string only once, no
matter how many times it is compared with other strings.  Even the time
needed to allocate and free storage is much less than the time we save,
when there are many strings.

     struct sorter { char *input; char *transformed; };

     /* This is the comparison function used with ‘qsort’
        to sort an array of ‘struct sorter’. */

     int
     compare_elements (const void *v1, const void *v2)
     {
       const struct sorter *p1 = v1;
       const struct sorter *p2 = v2;

       return strcmp (p1->transformed, p2->transformed);
     }

     /* This is the entry point—the function to sort
        strings using the locale’s collating sequence. */

     void
     sort_strings_fast (char **array, int nstrings)
     {
       struct sorter temp_array[nstrings];
       int i;

       /* Set up ‘temp_array’.  Each element contains
          one input string and its transformed string. */
       for (i = 0; i < nstrings; i++)
         {
           size_t length = strlen (array[i]) * 2;
           char *transformed;
           size_t transformed_length;

           temp_array[i].input = array[i];

           /* First try a buffer perhaps big enough.  */
           transformed = (char *) xmalloc (length);

           /* Transform ‘array[i]’.  */
           transformed_length = strxfrm (transformed, array[i], length);

           /* If the buffer was not large enough, resize it
              and try again.  */
           if (transformed_length >= length)
             {
               /* Allocate the needed space. +1 for terminating
                  ‘'\0'’ byte.  */
               transformed = (char *) xrealloc (transformed,
                                                transformed_length + 1);

               /* The return value is not interesting because we know
                  how long the transformed string is.  */
               (void) strxfrm (transformed, array[i],
                               transformed_length + 1);
             }

           temp_array[i].transformed = transformed;
         }

       /* Sort ‘temp_array’ by comparing transformed strings. */
       qsort (temp_array, nstrings,
              sizeof (struct sorter), compare_elements);

       /* Put the elements back in the permanent array
          in their sorted order. */
       for (i = 0; i < nstrings; i++)
         array[i] = temp_array[i].input;

       /* Free the strings we allocated. */
       for (i = 0; i < nstrings; i++)
         free (temp_array[i].transformed);
     }

   The interesting part of this code for the wide character version
would look like this:

     void
     sort_strings_fast (wchar_t **array, int nstrings)
     {
       …
           /* Transform ‘array[i]’.  */
           transformed_length = wcsxfrm (transformed, array[i], length);

           /* If the buffer was not large enough, resize it
              and try again.  */
           if (transformed_length >= length)
             {
               /* Allocate the needed space. +1 for terminating
                  ‘L'\0'’ wide character.  */
               transformed = (wchar_t *) xrealloc (transformed,
                                                   (transformed_length + 1)
                                                   * sizeof (wchar_t));

               /* The return value is not interesting because we know
                  how long the transformed string is.  */
               (void) wcsxfrm (transformed, array[i],
                               transformed_length + 1);
             }
       …

Note the additional multiplication with ‘sizeof (wchar_t)’ in the
‘realloc’ call.

   *Compatibility Note:* The string collation functions are a new
feature of ISO C90.  Older C dialects have no equivalent feature.  The
wide character versions were introduced in Amendment 1 to ISO C90.


File: libc.info,  Node: Search Functions,  Next: Finding Tokens in a String,  Prev: Collation Functions,  Up: String and Array Utilities

5.9 Search Functions
====================

This section describes library functions which perform various kinds of
searching operations on strings and arrays.  These functions are
declared in the header file ‘string.h’.

 -- Function: void * memchr (const void *BLOCK, int C, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function finds the first occurrence of the byte C (converted
     to an ‘unsigned char’) in the initial SIZE bytes of the object
     beginning at BLOCK.  The return value is a pointer to the located
     byte, or a null pointer if no match was found.

 -- Function: wchar_t * wmemchr (const wchar_t *BLOCK, wchar_t WC,
          size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function finds the first occurrence of the wide character WC
     in the initial SIZE wide characters of the object beginning at
     BLOCK.  The return value is a pointer to the located wide
     character, or a null pointer if no match was found.

 -- Function: void * rawmemchr (const void *BLOCK, int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Often the ‘memchr’ function is used with the knowledge that the
     byte C is available in the memory block specified by the
     parameters.  But this means that the SIZE parameter is not really
     needed and that the tests performed with it at runtime (to check
     whether the end of the block is reached) are not needed.

     The ‘rawmemchr’ function exists for just this situation which is
     surprisingly frequent.  The interface is similar to ‘memchr’ except
     that the SIZE parameter is missing.  The function will look beyond
     the end of the block pointed to by BLOCK in case the programmer
     made an error in assuming that the byte C is present in the block.
     In this case the result is unspecified.  Otherwise the return value
     is a pointer to the located byte.

     This function is of special interest when looking for the end of a
     string.  Since all strings are terminated by a null byte a call
     like

             rawmemchr (str, '\0')

     will never go beyond the end of the string.

     This function is a GNU extension.

 -- Function: void * memrchr (const void *BLOCK, int C, size_t SIZE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The function ‘memrchr’ is like ‘memchr’, except that it searches
     backwards from the end of the block defined by BLOCK and SIZE
     (instead of forwards from the front).

     This function is a GNU extension.

 -- Function: char * strchr (const char *STRING, int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘strchr’ function finds the first occurrence of the byte C
     (converted to a ‘char’) in the string beginning at STRING.  The
     return value is a pointer to the located byte, or a null pointer if
     no match was found.

     For example,
          strchr ("hello, world", 'l')
              ⇒ "llo, world"
          strchr ("hello, world", '?')
              ⇒ NULL

     The terminating null byte is considered to be part of the string,
     so you can use this function get a pointer to the end of a string
     by specifying zero as the value of the C argument.

     When ‘strchr’ returns a null pointer, it does not let you know the
     position of the terminating null byte it has found.  If you need
     that information, it is better (but less portable) to use
     ‘strchrnul’ than to search for it a second time.

 -- Function: wchar_t * wcschr (const wchar_t *WSTRING, int WC)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘wcschr’ function finds the first occurrence of the wide
     character WC in the wide string beginning at WSTRING.  The return
     value is a pointer to the located wide character, or a null pointer
     if no match was found.

     The terminating null wide character is considered to be part of the
     wide string, so you can use this function get a pointer to the end
     of a wide string by specifying a null wide character as the value
     of the WC argument.  It would be better (but less portable) to use
     ‘wcschrnul’ in this case, though.

 -- Function: char * strchrnul (const char *STRING, int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘strchrnul’ is the same as ‘strchr’ except that if it does not find
     the byte, it returns a pointer to string’s terminating null byte
     rather than a null pointer.

     This function is a GNU extension.

 -- Function: wchar_t * wcschrnul (const wchar_t *WSTRING, wchar_t WC)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘wcschrnul’ is the same as ‘wcschr’ except that if it does not find
     the wide character, it returns a pointer to the wide string’s
     terminating null wide character rather than a null pointer.

     This function is a GNU extension.

   One useful, but unusual, use of the ‘strchr’ function is when one
wants to have a pointer pointing to the null byte terminating a string.
This is often written in this way:

       s += strlen (s);

This is almost optimal but the addition operation duplicated a bit of
the work already done in the ‘strlen’ function.  A better solution is
this:

       s = strchr (s, '\0');

   There is no restriction on the second parameter of ‘strchr’ so it
could very well also be zero.  Those readers thinking very hard about
this might now point out that the ‘strchr’ function is more expensive
than the ‘strlen’ function since we have two abort criteria.  This is
right.  But in the GNU C Library the implementation of ‘strchr’ is
optimized in a special way so that ‘strchr’ actually is faster.

 -- Function: char * strrchr (const char *STRING, int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The function ‘strrchr’ is like ‘strchr’, except that it searches
     backwards from the end of the string STRING (instead of forwards
     from the front).

     For example,
          strrchr ("hello, world", 'l')
              ⇒ "ld"

 -- Function: wchar_t * wcsrchr (const wchar_t *WSTRING, wchar_t C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The function ‘wcsrchr’ is like ‘wcschr’, except that it searches
     backwards from the end of the string WSTRING (instead of forwards
     from the front).

 -- Function: char * strstr (const char *HAYSTACK, const char *NEEDLE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is like ‘strchr’, except that it searches HAYSTACK for a
     substring NEEDLE rather than just a single byte.  It returns a
     pointer into the string HAYSTACK that is the first byte of the
     substring, or a null pointer if no match was found.  If NEEDLE is
     an empty string, the function returns HAYSTACK.

     For example,
          strstr ("hello, world", "l")
              ⇒ "llo, world"
          strstr ("hello, world", "wo")
              ⇒ "world"

 -- Function: wchar_t * wcsstr (const wchar_t *HAYSTACK, const wchar_t
          *NEEDLE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is like ‘wcschr’, except that it searches HAYSTACK for a
     substring NEEDLE rather than just a single wide character.  It
     returns a pointer into the string HAYSTACK that is the first wide
     character of the substring, or a null pointer if no match was
     found.  If NEEDLE is an empty string, the function returns
     HAYSTACK.

 -- Function: wchar_t * wcswcs (const wchar_t *HAYSTACK, const wchar_t
          *NEEDLE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘wcswcs’ is a deprecated alias for ‘wcsstr’.  This is the name
     originally used in the X/Open Portability Guide before the Amendment 1
     to ISO C90 was published.

 -- Function: char * strcasestr (const char *HAYSTACK, const char
          *NEEDLE)

     Preliminary: | MT-Safe locale | AS-Safe | AC-Safe | *Note POSIX
     Safety Concepts::.

     This is like ‘strstr’, except that it ignores case in searching for
     the substring.  Like ‘strcasecmp’, it is locale dependent how
     uppercase and lowercase characters are related, and arguments are
     multibyte strings.

     For example,
          strcasestr ("hello, world", "L")
              ⇒ "llo, world"
          strcasestr ("hello, World", "wo")
              ⇒ "World"

 -- Function: void * memmem (const void *HAYSTACK, size_t HAYSTACK-LEN,
          const void *NEEDLE, size_t NEEDLE-LEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is like ‘strstr’, but NEEDLE and HAYSTACK are byte arrays
     rather than strings.  NEEDLE-LEN is the length of NEEDLE and
     HAYSTACK-LEN is the length of HAYSTACK.

     This function is a GNU extension.

 -- Function: size_t strspn (const char *STRING, const char *SKIPSET)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘strspn’ (“string span”) function returns the length of the
     initial substring of STRING that consists entirely of bytes that
     are members of the set specified by the string SKIPSET.  The order
     of the bytes in SKIPSET is not important.

     For example,
          strspn ("hello, world", "abcdefghijklmnopqrstuvwxyz")
              ⇒ 5

     In a multibyte string, characters consisting of more than one byte
     are not treated as single entities.  Each byte is treated
     separately.  The function is not locale-dependent.

 -- Function: size_t wcsspn (const wchar_t *WSTRING, const wchar_t
          *SKIPSET)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘wcsspn’ (“wide character string span”) function returns the
     length of the initial substring of WSTRING that consists entirely
     of wide characters that are members of the set specified by the
     string SKIPSET.  The order of the wide characters in SKIPSET is not
     important.

 -- Function: size_t strcspn (const char *STRING, const char *STOPSET)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘strcspn’ (“string complement span”) function returns the
     length of the initial substring of STRING that consists entirely of
     bytes that are _not_ members of the set specified by the string
     STOPSET.  (In other words, it returns the offset of the first byte
     in STRING that is a member of the set STOPSET.)

     For example,
          strcspn ("hello, world", " \t\n,.;!?")
              ⇒ 5

     In a multibyte string, characters consisting of more than one byte
     are not treated as a single entities.  Each byte is treated
     separately.  The function is not locale-dependent.

 -- Function: size_t wcscspn (const wchar_t *WSTRING, const wchar_t
          *STOPSET)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘wcscspn’ (“wide character string complement span”) function
     returns the length of the initial substring of WSTRING that
     consists entirely of wide characters that are _not_ members of the
     set specified by the string STOPSET.  (In other words, it returns
     the offset of the first wide character in STRING that is a member
     of the set STOPSET.)

 -- Function: char * strpbrk (const char *STRING, const char *STOPSET)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘strpbrk’ (“string pointer break”) function is related to
     ‘strcspn’, except that it returns a pointer to the first byte in
     STRING that is a member of the set STOPSET instead of the length of
     the initial substring.  It returns a null pointer if no such byte
     from STOPSET is found.

     For example,

          strpbrk ("hello, world", " \t\n,.;!?")
              ⇒ ", world"

     In a multibyte string, characters consisting of more than one byte
     are not treated as single entities.  Each byte is treated
     separately.  The function is not locale-dependent.

 -- Function: wchar_t * wcspbrk (const wchar_t *WSTRING, const wchar_t
          *STOPSET)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘wcspbrk’ (“wide character string pointer break”) function is
     related to ‘wcscspn’, except that it returns a pointer to the first
     wide character in WSTRING that is a member of the set STOPSET
     instead of the length of the initial substring.  It returns a null
     pointer if no such wide character from STOPSET is found.

5.9.1 Compatibility String Search Functions
-------------------------------------------

 -- Function: char * index (const char *STRING, int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘index’ is another name for ‘strchr’; they are exactly the same.
     New code should always use ‘strchr’ since this name is defined in ISO C
     while ‘index’ is a BSD invention which never was available on System V
     derived systems.

 -- Function: char * rindex (const char *STRING, int C)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘rindex’ is another name for ‘strrchr’; they are exactly the same.
     New code should always use ‘strrchr’ since this name is defined in ISO C
     while ‘rindex’ is a BSD invention which never was available on System V
     derived systems.


File: libc.info,  Node: Finding Tokens in a String,  Next: Erasing Sensitive Data,  Prev: Search Functions,  Up: String and Array Utilities

5.10 Finding Tokens in a String
===============================

It’s fairly common for programs to have a need to do some simple kinds
of lexical analysis and parsing, such as splitting a command string up
into tokens.  You can do this with the ‘strtok’ function, declared in
the header file ‘string.h’.

 -- Function: char * strtok (char *restrict NEWSTRING, const char
          *restrict DELIMITERS)

     Preliminary: | MT-Unsafe race:strtok | AS-Unsafe | AC-Safe | *Note
     POSIX Safety Concepts::.

     A string can be split into tokens by making a series of calls to
     the function ‘strtok’.

     The string to be split up is passed as the NEWSTRING argument on
     the first call only.  The ‘strtok’ function uses this to set up
     some internal state information.  Subsequent calls to get
     additional tokens from the same string are indicated by passing a
     null pointer as the NEWSTRING argument.  Calling ‘strtok’ with
     another non-null NEWSTRING argument reinitializes the state
     information.  It is guaranteed that no other library function ever
     calls ‘strtok’ behind your back (which would mess up this internal
     state information).

     The DELIMITERS argument is a string that specifies a set of
     delimiters that may surround the token being extracted.  All the
     initial bytes that are members of this set are discarded.  The
     first byte that is _not_ a member of this set of delimiters marks
     the beginning of the next token.  The end of the token is found by
     looking for the next byte that is a member of the delimiter set.
     This byte in the original string NEWSTRING is overwritten by a null
     byte, and the pointer to the beginning of the token in NEWSTRING is
     returned.

     On the next call to ‘strtok’, the searching begins at the next byte
     beyond the one that marked the end of the previous token.  Note
     that the set of delimiters DELIMITERS do not have to be the same on
     every call in a series of calls to ‘strtok’.

     If the end of the string NEWSTRING is reached, or if the remainder
     of string consists only of delimiter bytes, ‘strtok’ returns a null
     pointer.

     In a multibyte string, characters consisting of more than one byte
     are not treated as single entities.  Each byte is treated
     separately.  The function is not locale-dependent.

 -- Function: wchar_t * wcstok (wchar_t *NEWSTRING, const wchar_t
          *DELIMITERS, wchar_t **SAVE_PTR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     A string can be split into tokens by making a series of calls to
     the function ‘wcstok’.

     The string to be split up is passed as the NEWSTRING argument on
     the first call only.  The ‘wcstok’ function uses this to set up
     some internal state information.  Subsequent calls to get
     additional tokens from the same wide string are indicated by
     passing a null pointer as the NEWSTRING argument, which causes the
     pointer previously stored in SAVE_PTR to be used instead.

     The DELIMITERS argument is a wide string that specifies a set of
     delimiters that may surround the token being extracted.  All the
     initial wide characters that are members of this set are discarded.
     The first wide character that is _not_ a member of this set of
     delimiters marks the beginning of the next token.  The end of the
     token is found by looking for the next wide character that is a
     member of the delimiter set.  This wide character in the original
     wide string NEWSTRING is overwritten by a null wide character, the
     pointer past the overwritten wide character is saved in SAVE_PTR,
     and the pointer to the beginning of the token in NEWSTRING is
     returned.

     On the next call to ‘wcstok’, the searching begins at the next wide
     character beyond the one that marked the end of the previous token.
     Note that the set of delimiters DELIMITERS do not have to be the
     same on every call in a series of calls to ‘wcstok’.

     If the end of the wide string NEWSTRING is reached, or if the
     remainder of string consists only of delimiter wide characters,
     ‘wcstok’ returns a null pointer.

   *Warning:* Since ‘strtok’ and ‘wcstok’ alter the string they is
parsing, you should always copy the string to a temporary buffer before
parsing it with ‘strtok’/‘wcstok’ (*note Copying Strings and Arrays::).
If you allow ‘strtok’ or ‘wcstok’ to modify a string that came from
another part of your program, you are asking for trouble; that string
might be used for other purposes after ‘strtok’ or ‘wcstok’ has modified
it, and it would not have the expected value.

   The string that you are operating on might even be a constant.  Then
when ‘strtok’ or ‘wcstok’ tries to modify it, your program will get a
fatal signal for writing in read-only memory.  *Note Program Error
Signals::.  Even if the operation of ‘strtok’ or ‘wcstok’ would not
require a modification of the string (e.g., if there is exactly one
token) the string can (and in the GNU C Library case will) be modified.

   This is a special case of a general principle: if a part of a program
does not have as its purpose the modification of a certain data
structure, then it is error-prone to modify the data structure
temporarily.

   The function ‘strtok’ is not reentrant, whereas ‘wcstok’ is.  *Note
Nonreentrancy::, for a discussion of where and why reentrancy is
important.

   Here is a simple example showing the use of ‘strtok’.

     #include <string.h>
     #include <stddef.h>

     …

     const char string[] = "words separated by spaces -- and, punctuation!";
     const char delimiters[] = " .,;:!-";
     char *token, *cp;

     …

     cp = strdupa (string);                /* Make writable copy.  */
     token = strtok (cp, delimiters);      /* token => "words" */
     token = strtok (NULL, delimiters);    /* token => "separated" */
     token = strtok (NULL, delimiters);    /* token => "by" */
     token = strtok (NULL, delimiters);    /* token => "spaces" */
     token = strtok (NULL, delimiters);    /* token => "and" */
     token = strtok (NULL, delimiters);    /* token => "punctuation" */
     token = strtok (NULL, delimiters);    /* token => NULL */

   The GNU C Library contains two more functions for tokenizing a string
which overcome the limitation of non-reentrancy.  They are not available
available for wide strings.

 -- Function: char * strtok_r (char *NEWSTRING, const char *DELIMITERS,
          char **SAVE_PTR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Just like ‘strtok’, this function splits the string into several
     tokens which can be accessed by successive calls to ‘strtok_r’.
     The difference is that, as in ‘wcstok’, the information about the
     next token is stored in the space pointed to by the third argument,
     SAVE_PTR, which is a pointer to a string pointer.  Calling
     ‘strtok_r’ with a null pointer for NEWSTRING and leaving SAVE_PTR
     between the calls unchanged does the job without hindering
     reentrancy.

     This function is defined in POSIX.1 and can be found on many
     systems which support multi-threading.

 -- Function: char * strsep (char **STRING_PTR, const char *DELIMITER)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function has a similar functionality as ‘strtok_r’ with the
     NEWSTRING argument replaced by the SAVE_PTR argument.  The
     initialization of the moving pointer has to be done by the user.
     Successive calls to ‘strsep’ move the pointer along the tokens
     separated by DELIMITER, returning the address of the next token and
     updating STRING_PTR to point to the beginning of the next token.

     One difference between ‘strsep’ and ‘strtok_r’ is that if the input
     string contains more than one byte from DELIMITER in a row ‘strsep’
     returns an empty string for each pair of bytes from DELIMITER.
     This means that a program normally should test for ‘strsep’
     returning an empty string before processing it.

     This function was introduced in 4.3BSD and therefore is widely
     available.

   Here is how the above example looks like when ‘strsep’ is used.

     #include <string.h>
     #include <stddef.h>

     …

     const char string[] = "words separated by spaces -- and, punctuation!";
     const char delimiters[] = " .,;:!-";
     char *running;
     char *token;

     …

     running = strdupa (string);
     token = strsep (&running, delimiters);    /* token => "words" */
     token = strsep (&running, delimiters);    /* token => "separated" */
     token = strsep (&running, delimiters);    /* token => "by" */
     token = strsep (&running, delimiters);    /* token => "spaces" */
     token = strsep (&running, delimiters);    /* token => "" */
     token = strsep (&running, delimiters);    /* token => "" */
     token = strsep (&running, delimiters);    /* token => "" */
     token = strsep (&running, delimiters);    /* token => "and" */
     token = strsep (&running, delimiters);    /* token => "" */
     token = strsep (&running, delimiters);    /* token => "punctuation" */
     token = strsep (&running, delimiters);    /* token => "" */
     token = strsep (&running, delimiters);    /* token => NULL */

 -- Function: char * basename (const char *FILENAME)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The GNU version of the ‘basename’ function returns the last
     component of the path in FILENAME.  This function is the preferred
     usage, since it does not modify the argument, FILENAME, and
     respects trailing slashes.  The prototype for ‘basename’ can be
     found in ‘string.h’.  Note, this function is overridden by the XPG
     version, if ‘libgen.h’ is included.

     Example of using GNU ‘basename’:

          #include <string.h>

          int
          main (int argc, char *argv[])
          {
            char *prog = basename (argv[0]);

            if (argc < 2)
              {
                fprintf (stderr, "Usage %s <arg>\n", prog);
                exit (1);
              }

            …
          }

     *Portability Note:* This function may produce different results on
     different systems.

 -- Function: char * basename (char *PATH)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This is the standard XPG defined ‘basename’.  It is similar in
     spirit to the GNU version, but may modify the PATH by removing
     trailing ’/’ bytes.  If the PATH is made up entirely of ’/’ bytes,
     then "/" will be returned.  Also, if PATH is ‘NULL’ or an empty
     string, then "."  is returned.  The prototype for the XPG version
     can be found in ‘libgen.h’.

     Example of using XPG ‘basename’:

          #include <libgen.h>

          int
          main (int argc, char *argv[])
          {
            char *prog;
            char *path = strdupa (argv[0]);

            prog = basename (path);

            if (argc < 2)
              {
                fprintf (stderr, "Usage %s <arg>\n", prog);
                exit (1);
              }

            …

          }

 -- Function: char * dirname (char *PATH)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘dirname’ function is the compliment to the XPG version of
     ‘basename’.  It returns the parent directory of the file specified
     by PATH.  If PATH is ‘NULL’, an empty string, or contains no ’/’
     bytes, then "."  is returned.  The prototype for this function can
     be found in ‘libgen.h’.


File: libc.info,  Node: Erasing Sensitive Data,  Next: Shuffling Bytes,  Prev: Finding Tokens in a String,  Up: String and Array Utilities

5.11 Erasing Sensitive Data
===========================

Sensitive data, such as cryptographic keys, should be erased from memory
after use, to reduce the risk that a bug will expose it to the outside
world.  However, compiler optimizations may determine that an erasure
operation is “unnecessary,” and remove it from the generated code,
because no _correct_ program could access the variable or heap object
containing the sensitive data after it’s deallocated.  Since erasure is
a precaution against bugs, this optimization is inappropriate.

   The function ‘explicit_bzero’ erases a block of memory, and
guarantees that the compiler will not remove the erasure as
“unnecessary.”

     #include <string.h>

     extern void encrypt (const char *key, const char *in,
                          char *out, size_t n);
     extern void genkey (const char *phrase, char *key);

     void encrypt_with_phrase (const char *phrase, const char *in,
                               char *out, size_t n)
     {
       char key[16];
       genkey (phrase, key);
       encrypt (key, in, out, n);
       explicit_bzero (key, 16);
     }

In this example, if ‘memset’, ‘bzero’, or a hand-written loop had been
used, the compiler might remove them as “unnecessary.”

   *Warning:* ‘explicit_bzero’ does not guarantee that sensitive data is
_completely_ erased from the computer’s memory.  There may be copies in
temporary storage areas, such as registers and “scratch” stack space;
since these are invisible to the source code, a library function cannot
erase them.

   Also, ‘explicit_bzero’ only operates on RAM. If a sensitive data
object never needs to have its address taken other than to call
‘explicit_bzero’, it might be stored entirely in CPU registers _until_
the call to ‘explicit_bzero’.  Then it will be copied into RAM, the copy
will be erased, and the original will remain intact.  Data in RAM is
more likely to be exposed by a bug than data in registers, so this
creates a brief window where the data is at greater risk of exposure
than it would have been if the program didn’t try to erase it at all.

   Declaring sensitive variables as ‘volatile’ will make both the above
problems _worse_; a ‘volatile’ variable will be stored in memory for its
entire lifetime, and the compiler will make _more_ copies of it than it
would otherwise have.  Attempting to erase a normal variable “by hand”
through a ‘volatile’-qualified pointer doesn’t work at all—because the
variable itself is not ‘volatile’, some compilers will ignore the
qualification on the pointer and remove the erasure anyway.

   Having said all that, in most situations, using ‘explicit_bzero’ is
better than not using it.  At present, the only way to do a more
thorough job is to write the entire sensitive operation in assembly
language.  We anticipate that future compilers will recognize calls to
‘explicit_bzero’ and take appropriate steps to erase all the copies of
the affected data, whereever they may be.

 -- Function: void explicit_bzero (void *BLOCK, size_t LEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘explicit_bzero’ writes zero into LEN bytes of memory beginning at
     BLOCK, just as ‘bzero’ would.  The zeroes are always written, even
     if the compiler could determine that this is “unnecessary” because
     no correct program could read them back.

     *Note:* The _only_ optimization that ‘explicit_bzero’ disables is
     removal of “unnecessary” writes to memory.  The compiler can
     perform all the other optimizations that it could for a call to
     ‘memset’.  For instance, it may replace the function call with
     inline memory writes, and it may assume that BLOCK cannot be a null
     pointer.

     *Portability Note:* This function first appeared in OpenBSD 5.5 and
     has not been standardized.  Other systems may provide the same
     functionality under a different name, such as ‘explicit_memset’,
     ‘memset_s’, or ‘SecureZeroMemory’.

     The GNU C Library declares this function in ‘string.h’, but on
     other systems it may be in ‘strings.h’ instead.


File: libc.info,  Node: Shuffling Bytes,  Next: Obfuscating Data,  Prev: Erasing Sensitive Data,  Up: String and Array Utilities

5.12 Shuffling Bytes
====================

The function below addresses the perennial programming quandary: “How do
I take good data in string form and painlessly turn it into garbage?”
This is not a difficult thing to code for oneself, but the authors of
the GNU C Library wish to make it as convenient as possible.

   To _erase_ data, use ‘explicit_bzero’ (*note Erasing Sensitive
Data::); to obfuscate it reversibly, use ‘memfrob’ (*note Obfuscating
Data::).

 -- Function: char * strfry (char *STRING)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘strfry’ performs an in-place shuffle on STRING.  Each character is
     swapped to a position selected at random, within the portion of the
     string starting with the character’s original position.  (This is
     the Fisher-Yates algorithm for unbiased shuffling.)

     Calling ‘strfry’ will not disturb any of the random number
     generators that have global state (*note Pseudo-Random Numbers::).

     The return value of ‘strfry’ is always STRING.

     *Portability Note:* This function is unique to the GNU C Library.
     It is declared in ‘string.h’.


File: libc.info,  Node: Obfuscating Data,  Next: Encode Binary Data,  Prev: Shuffling Bytes,  Up: String and Array Utilities

5.13 Obfuscating Data
=====================

The ‘memfrob’ function reversibly obfuscates an array of binary data.
This is not true encryption; the obfuscated data still bears a clear
relationship to the original, and no secret key is required to undo the
obfuscation.  It is analogous to the “Rot13” cipher used on Usenet for
obscuring offensive jokes, spoilers for works of fiction, and so on, but
it can be applied to arbitrary binary data.

   Programs that need true encryption—a transformation that completely
obscures the original and cannot be reversed without knowledge of a
secret key—should use a dedicated cryptography library, such as
libgcrypt.

   Programs that need to _destroy_ data should use ‘explicit_bzero’
(*note Erasing Sensitive Data::), or possibly ‘strfry’ (*note Shuffling
Bytes::).

 -- Function: void * memfrob (void *MEM, size_t LENGTH)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The function ‘memfrob’ obfuscates LENGTH bytes of data beginning at
     MEM, in place.  Each byte is bitwise xor-ed with the binary pattern
     00101010 (hexadecimal 0x2A). The return value is always MEM.

     ‘memfrob’ a second time on the same data returns it to its original
     state.

     *Portability Note:* This function is unique to the GNU C Library.
     It is declared in ‘string.h’.


File: libc.info,  Node: Encode Binary Data,  Next: Argz and Envz Vectors,  Prev: Obfuscating Data,  Up: String and Array Utilities

5.14 Encode Binary Data
=======================

To store or transfer binary data in environments which only support text
one has to encode the binary data by mapping the input bytes to bytes in
the range allowed for storing or transferring.  SVID systems (and
nowadays XPG compliant systems) provide minimal support for this task.

 -- Function: char * l64a (long int N)

     Preliminary: | MT-Unsafe race:l64a | AS-Unsafe | AC-Safe | *Note
     POSIX Safety Concepts::.

     This function encodes a 32-bit input value using bytes from the
     basic character set.  It returns a pointer to a 7 byte buffer which
     contains an encoded version of N.  To encode a series of bytes the
     user must copy the returned string to a destination buffer.  It
     returns the empty string if N is zero, which is somewhat bizarre
     but mandated by the standard.
     *Warning:* Since a static buffer is used this function should not
     be used in multi-threaded programs.  There is no thread-safe
     alternative to this function in the C library.
     *Compatibility Note:* The XPG standard states that the return value
     of ‘l64a’ is undefined if N is negative.  In the GNU
     implementation, ‘l64a’ treats its argument as unsigned, so it will
     return a sensible encoding for any nonzero N; however, portable
     programs should not rely on this.

     To encode a large buffer ‘l64a’ must be called in a loop, once for
     each 32-bit word of the buffer.  For example, one could do
     something like this:

          char *
          encode (const void *buf, size_t len)
          {
            /* We know in advance how long the buffer has to be. */
            unsigned char *in = (unsigned char *) buf;
            char *out = malloc (6 + ((len + 3) / 4) * 6 + 1);
            char *cp = out, *p;

            /* Encode the length. */
            /* Using ‘htonl’ is necessary so that the data can be
               decoded even on machines with different byte order.
               ‘l64a’ can return a string shorter than 6 bytes, so 
               we pad it with encoding of 0 ('.') at the end by 
               hand. */

            p = stpcpy (cp, l64a (htonl (len)));
            cp = mempcpy (p, "......", 6 - (p - cp));

            while (len > 3)
              {
                unsigned long int n = *in++;
                n = (n << 8) | *in++;
                n = (n << 8) | *in++;
                n = (n << 8) | *in++;
                len -= 4;
                p = stpcpy (cp, l64a (htonl (n)));
                cp = mempcpy (p, "......", 6 - (p - cp));
              }
            if (len > 0)
              {
                unsigned long int n = *in++;
                if (--len > 0)
                  {
                    n = (n << 8) | *in++;
                    if (--len > 0)
                      n = (n << 8) | *in;
                  }
                cp = stpcpy (cp, l64a (htonl (n)));
              }
            *cp = '\0';
            return out;
          }

     It is strange that the library does not provide the complete
     functionality needed but so be it.

   To decode data produced with ‘l64a’ the following function should be
used.

 -- Function: long int a64l (const char *STRING)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The parameter STRING should contain a string which was produced by
     a call to ‘l64a’.  The function processes at least 6 bytes of this
     string, and decodes the bytes it finds according to the table
     below.  It stops decoding when it finds a byte not in the table,
     rather like ‘atoi’; if you have a buffer which has been broken into
     lines, you must be careful to skip over the end-of-line bytes.

     The decoded number is returned as a ‘long int’ value.

   The ‘l64a’ and ‘a64l’ functions use a base 64 encoding, in which each
byte of an encoded string represents six bits of an input word.  These
symbols are used for the base 64 digits:

        0     1     2     3     4     5     6     7
0       ‘.’   ‘/’   ‘0’   ‘1’   ‘2’   ‘3’   ‘4’   ‘5’
8       ‘6’   ‘7’   ‘8’   ‘9’   ‘A’   ‘B’   ‘C’   ‘D’
16      ‘E’   ‘F’   ‘G’   ‘H’   ‘I’   ‘J’   ‘K’   ‘L’
24      ‘M’   ‘N’   ‘O’   ‘P’   ‘Q’   ‘R’   ‘S’   ‘T’
32      ‘U’   ‘V’   ‘W’   ‘X’   ‘Y’   ‘Z’   ‘a’   ‘b’
40      ‘c’   ‘d’   ‘e’   ‘f’   ‘g’   ‘h’   ‘i’   ‘j’
48      ‘k’   ‘l’   ‘m’   ‘n’   ‘o’   ‘p’   ‘q’   ‘r’
56      ‘s’   ‘t’   ‘u’   ‘v’   ‘w’   ‘x’   ‘y’   ‘z’

   This encoding scheme is not standard.  There are some other encoding
methods which are much more widely used (UU encoding, MIME encoding).
Generally, it is better to use one of these encodings.

