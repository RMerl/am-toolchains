This is libc.info, produced by makeinfo version 5.2 from libc.texinfo.

This file documents the GNU C Library.

   This is ‘The GNU C Library Reference Manual’, for version 2.30
(Buildroot).

   Copyright © 1993–2019 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being “Free Software Needs Free Documentation” and
“GNU Lesser General Public License”, the Front-Cover texts being “A GNU
Manual”, and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License".

   (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom.”
INFO-DIR-SECTION Software libraries
START-INFO-DIR-ENTRY
* Libc: (libc).                 C library.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION GNU C library functions and macros
START-INFO-DIR-ENTRY
* ALTWERASE: (libc)Local Modes.
* ARGP_ERR_UNKNOWN: (libc)Argp Parser Functions.
* ARG_MAX: (libc)General Limits.
* BC_BASE_MAX: (libc)Utility Limits.
* BC_DIM_MAX: (libc)Utility Limits.
* BC_SCALE_MAX: (libc)Utility Limits.
* BC_STRING_MAX: (libc)Utility Limits.
* BRKINT: (libc)Input Modes.
* BUFSIZ: (libc)Controlling Buffering.
* CCTS_OFLOW: (libc)Control Modes.
* CHAR_BIT: (libc)Width of Type.
* CHILD_MAX: (libc)General Limits.
* CIGNORE: (libc)Control Modes.
* CLK_TCK: (libc)Processor Time.
* CLOCAL: (libc)Control Modes.
* CLOCKS_PER_SEC: (libc)CPU Time.
* COLL_WEIGHTS_MAX: (libc)Utility Limits.
* CPU_CLR: (libc)CPU Affinity.
* CPU_ISSET: (libc)CPU Affinity.
* CPU_SET: (libc)CPU Affinity.
* CPU_SETSIZE: (libc)CPU Affinity.
* CPU_ZERO: (libc)CPU Affinity.
* CREAD: (libc)Control Modes.
* CRTS_IFLOW: (libc)Control Modes.
* CS5: (libc)Control Modes.
* CS6: (libc)Control Modes.
* CS7: (libc)Control Modes.
* CS8: (libc)Control Modes.
* CSIZE: (libc)Control Modes.
* CSTOPB: (libc)Control Modes.
* DTTOIF: (libc)Directory Entries.
* E2BIG: (libc)Error Codes.
* EACCES: (libc)Error Codes.
* EADDRINUSE: (libc)Error Codes.
* EADDRNOTAVAIL: (libc)Error Codes.
* EADV: (libc)Error Codes.
* EAFNOSUPPORT: (libc)Error Codes.
* EAGAIN: (libc)Error Codes.
* EALREADY: (libc)Error Codes.
* EAUTH: (libc)Error Codes.
* EBACKGROUND: (libc)Error Codes.
* EBADE: (libc)Error Codes.
* EBADF: (libc)Error Codes.
* EBADFD: (libc)Error Codes.
* EBADMSG: (libc)Error Codes.
* EBADR: (libc)Error Codes.
* EBADRPC: (libc)Error Codes.
* EBADRQC: (libc)Error Codes.
* EBADSLT: (libc)Error Codes.
* EBFONT: (libc)Error Codes.
* EBUSY: (libc)Error Codes.
* ECANCELED: (libc)Error Codes.
* ECHILD: (libc)Error Codes.
* ECHO: (libc)Local Modes.
* ECHOCTL: (libc)Local Modes.
* ECHOE: (libc)Local Modes.
* ECHOK: (libc)Local Modes.
* ECHOKE: (libc)Local Modes.
* ECHONL: (libc)Local Modes.
* ECHOPRT: (libc)Local Modes.
* ECHRNG: (libc)Error Codes.
* ECOMM: (libc)Error Codes.
* ECONNABORTED: (libc)Error Codes.
* ECONNREFUSED: (libc)Error Codes.
* ECONNRESET: (libc)Error Codes.
* ED: (libc)Error Codes.
* EDEADLK: (libc)Error Codes.
* EDEADLOCK: (libc)Error Codes.
* EDESTADDRREQ: (libc)Error Codes.
* EDIED: (libc)Error Codes.
* EDOM: (libc)Error Codes.
* EDOTDOT: (libc)Error Codes.
* EDQUOT: (libc)Error Codes.
* EEXIST: (libc)Error Codes.
* EFAULT: (libc)Error Codes.
* EFBIG: (libc)Error Codes.
* EFTYPE: (libc)Error Codes.
* EGRATUITOUS: (libc)Error Codes.
* EGREGIOUS: (libc)Error Codes.
* EHOSTDOWN: (libc)Error Codes.
* EHOSTUNREACH: (libc)Error Codes.
* EHWPOISON: (libc)Error Codes.
* EIDRM: (libc)Error Codes.
* EIEIO: (libc)Error Codes.
* EILSEQ: (libc)Error Codes.
* EINPROGRESS: (libc)Error Codes.
* EINTR: (libc)Error Codes.
* EINVAL: (libc)Error Codes.
* EIO: (libc)Error Codes.
* EISCONN: (libc)Error Codes.
* EISDIR: (libc)Error Codes.
* EISNAM: (libc)Error Codes.
* EKEYEXPIRED: (libc)Error Codes.
* EKEYREJECTED: (libc)Error Codes.
* EKEYREVOKED: (libc)Error Codes.
* EL2HLT: (libc)Error Codes.
* EL2NSYNC: (libc)Error Codes.
* EL3HLT: (libc)Error Codes.
* EL3RST: (libc)Error Codes.
* ELIBACC: (libc)Error Codes.
* ELIBBAD: (libc)Error Codes.
* ELIBEXEC: (libc)Error Codes.
* ELIBMAX: (libc)Error Codes.
* ELIBSCN: (libc)Error Codes.
* ELNRNG: (libc)Error Codes.
* ELOOP: (libc)Error Codes.
* EMEDIUMTYPE: (libc)Error Codes.
* EMFILE: (libc)Error Codes.
* EMLINK: (libc)Error Codes.
* EMSGSIZE: (libc)Error Codes.
* EMULTIHOP: (libc)Error Codes.
* ENAMETOOLONG: (libc)Error Codes.
* ENAVAIL: (libc)Error Codes.
* ENEEDAUTH: (libc)Error Codes.
* ENETDOWN: (libc)Error Codes.
* ENETRESET: (libc)Error Codes.
* ENETUNREACH: (libc)Error Codes.
* ENFILE: (libc)Error Codes.
* ENOANO: (libc)Error Codes.
* ENOBUFS: (libc)Error Codes.
* ENOCSI: (libc)Error Codes.
* ENODATA: (libc)Error Codes.
* ENODEV: (libc)Error Codes.
* ENOENT: (libc)Error Codes.
* ENOEXEC: (libc)Error Codes.
* ENOKEY: (libc)Error Codes.
* ENOLCK: (libc)Error Codes.
* ENOLINK: (libc)Error Codes.
* ENOMEDIUM: (libc)Error Codes.
* ENOMEM: (libc)Error Codes.
* ENOMSG: (libc)Error Codes.
* ENONET: (libc)Error Codes.
* ENOPKG: (libc)Error Codes.
* ENOPROTOOPT: (libc)Error Codes.
* ENOSPC: (libc)Error Codes.
* ENOSR: (libc)Error Codes.
* ENOSTR: (libc)Error Codes.
* ENOSYS: (libc)Error Codes.
* ENOTBLK: (libc)Error Codes.
* ENOTCONN: (libc)Error Codes.
* ENOTDIR: (libc)Error Codes.
* ENOTEMPTY: (libc)Error Codes.
* ENOTNAM: (libc)Error Codes.
* ENOTRECOVERABLE: (libc)Error Codes.
* ENOTSOCK: (libc)Error Codes.
* ENOTSUP: (libc)Error Codes.
* ENOTTY: (libc)Error Codes.
* ENOTUNIQ: (libc)Error Codes.
* ENXIO: (libc)Error Codes.
* EOF: (libc)EOF and Errors.
* EOPNOTSUPP: (libc)Error Codes.
* EOVERFLOW: (libc)Error Codes.
* EOWNERDEAD: (libc)Error Codes.
* EPERM: (libc)Error Codes.
* EPFNOSUPPORT: (libc)Error Codes.
* EPIPE: (libc)Error Codes.
* EPROCLIM: (libc)Error Codes.
* EPROCUNAVAIL: (libc)Error Codes.
* EPROGMISMATCH: (libc)Error Codes.
* EPROGUNAVAIL: (libc)Error Codes.
* EPROTO: (libc)Error Codes.
* EPROTONOSUPPORT: (libc)Error Codes.
* EPROTOTYPE: (libc)Error Codes.
* EQUIV_CLASS_MAX: (libc)Utility Limits.
* ERANGE: (libc)Error Codes.
* EREMCHG: (libc)Error Codes.
* EREMOTE: (libc)Error Codes.
* EREMOTEIO: (libc)Error Codes.
* ERESTART: (libc)Error Codes.
* ERFKILL: (libc)Error Codes.
* EROFS: (libc)Error Codes.
* ERPCMISMATCH: (libc)Error Codes.
* ESHUTDOWN: (libc)Error Codes.
* ESOCKTNOSUPPORT: (libc)Error Codes.
* ESPIPE: (libc)Error Codes.
* ESRCH: (libc)Error Codes.
* ESRMNT: (libc)Error Codes.
* ESTALE: (libc)Error Codes.
* ESTRPIPE: (libc)Error Codes.
* ETIME: (libc)Error Codes.
* ETIMEDOUT: (libc)Error Codes.
* ETOOMANYREFS: (libc)Error Codes.
* ETXTBSY: (libc)Error Codes.
* EUCLEAN: (libc)Error Codes.
* EUNATCH: (libc)Error Codes.
* EUSERS: (libc)Error Codes.
* EWOULDBLOCK: (libc)Error Codes.
* EXDEV: (libc)Error Codes.
* EXFULL: (libc)Error Codes.
* EXIT_FAILURE: (libc)Exit Status.
* EXIT_SUCCESS: (libc)Exit Status.
* EXPR_NEST_MAX: (libc)Utility Limits.
* FD_CLOEXEC: (libc)Descriptor Flags.
* FD_CLR: (libc)Waiting for I/O.
* FD_ISSET: (libc)Waiting for I/O.
* FD_SET: (libc)Waiting for I/O.
* FD_SETSIZE: (libc)Waiting for I/O.
* FD_ZERO: (libc)Waiting for I/O.
* FE_SNANS_ALWAYS_SIGNAL: (libc)Infinity and NaN.
* FILENAME_MAX: (libc)Limits for Files.
* FLUSHO: (libc)Local Modes.
* FOPEN_MAX: (libc)Opening Streams.
* FP_ILOGB0: (libc)Exponents and Logarithms.
* FP_ILOGBNAN: (libc)Exponents and Logarithms.
* FP_LLOGB0: (libc)Exponents and Logarithms.
* FP_LLOGBNAN: (libc)Exponents and Logarithms.
* F_DUPFD: (libc)Duplicating Descriptors.
* F_GETFD: (libc)Descriptor Flags.
* F_GETFL: (libc)Getting File Status Flags.
* F_GETLK: (libc)File Locks.
* F_GETOWN: (libc)Interrupt Input.
* F_OFD_GETLK: (libc)Open File Description Locks.
* F_OFD_SETLK: (libc)Open File Description Locks.
* F_OFD_SETLKW: (libc)Open File Description Locks.
* F_OK: (libc)Testing File Access.
* F_SETFD: (libc)Descriptor Flags.
* F_SETFL: (libc)Getting File Status Flags.
* F_SETLK: (libc)File Locks.
* F_SETLKW: (libc)File Locks.
* F_SETOWN: (libc)Interrupt Input.
* HUGE_VAL: (libc)Math Error Reporting.
* HUGE_VALF: (libc)Math Error Reporting.
* HUGE_VALL: (libc)Math Error Reporting.
* HUGE_VAL_FN: (libc)Math Error Reporting.
* HUGE_VAL_FNx: (libc)Math Error Reporting.
* HUPCL: (libc)Control Modes.
* I: (libc)Complex Numbers.
* ICANON: (libc)Local Modes.
* ICRNL: (libc)Input Modes.
* IEXTEN: (libc)Local Modes.
* IFNAMSIZ: (libc)Interface Naming.
* IFTODT: (libc)Directory Entries.
* IGNBRK: (libc)Input Modes.
* IGNCR: (libc)Input Modes.
* IGNPAR: (libc)Input Modes.
* IMAXBEL: (libc)Input Modes.
* INADDR_ANY: (libc)Host Address Data Type.
* INADDR_BROADCAST: (libc)Host Address Data Type.
* INADDR_LOOPBACK: (libc)Host Address Data Type.
* INADDR_NONE: (libc)Host Address Data Type.
* INFINITY: (libc)Infinity and NaN.
* INLCR: (libc)Input Modes.
* INPCK: (libc)Input Modes.
* IPPORT_RESERVED: (libc)Ports.
* IPPORT_USERRESERVED: (libc)Ports.
* ISIG: (libc)Local Modes.
* ISTRIP: (libc)Input Modes.
* IXANY: (libc)Input Modes.
* IXOFF: (libc)Input Modes.
* IXON: (libc)Input Modes.
* LINE_MAX: (libc)Utility Limits.
* LINK_MAX: (libc)Limits for Files.
* L_ctermid: (libc)Identifying the Terminal.
* L_cuserid: (libc)Who Logged In.
* L_tmpnam: (libc)Temporary Files.
* MAXNAMLEN: (libc)Limits for Files.
* MAXSYMLINKS: (libc)Symbolic Links.
* MAX_CANON: (libc)Limits for Files.
* MAX_INPUT: (libc)Limits for Files.
* MB_CUR_MAX: (libc)Selecting the Conversion.
* MB_LEN_MAX: (libc)Selecting the Conversion.
* MDMBUF: (libc)Control Modes.
* MSG_DONTROUTE: (libc)Socket Data Options.
* MSG_OOB: (libc)Socket Data Options.
* MSG_PEEK: (libc)Socket Data Options.
* NAME_MAX: (libc)Limits for Files.
* NAN: (libc)Infinity and NaN.
* NCCS: (libc)Mode Data Types.
* NGROUPS_MAX: (libc)General Limits.
* NOFLSH: (libc)Local Modes.
* NOKERNINFO: (libc)Local Modes.
* NSIG: (libc)Standard Signals.
* NULL: (libc)Null Pointer Constant.
* ONLCR: (libc)Output Modes.
* ONOEOT: (libc)Output Modes.
* OPEN_MAX: (libc)General Limits.
* OPOST: (libc)Output Modes.
* OXTABS: (libc)Output Modes.
* O_ACCMODE: (libc)Access Modes.
* O_APPEND: (libc)Operating Modes.
* O_ASYNC: (libc)Operating Modes.
* O_CREAT: (libc)Open-time Flags.
* O_DIRECTORY: (libc)Open-time Flags.
* O_EXCL: (libc)Open-time Flags.
* O_EXEC: (libc)Access Modes.
* O_EXLOCK: (libc)Open-time Flags.
* O_FSYNC: (libc)Operating Modes.
* O_IGNORE_CTTY: (libc)Open-time Flags.
* O_NDELAY: (libc)Operating Modes.
* O_NOATIME: (libc)Operating Modes.
* O_NOCTTY: (libc)Open-time Flags.
* O_NOLINK: (libc)Open-time Flags.
* O_NONBLOCK: (libc)Open-time Flags.
* O_NONBLOCK: (libc)Operating Modes.
* O_NOTRANS: (libc)Open-time Flags.
* O_RDONLY: (libc)Access Modes.
* O_RDWR: (libc)Access Modes.
* O_READ: (libc)Access Modes.
* O_SHLOCK: (libc)Open-time Flags.
* O_SYNC: (libc)Operating Modes.
* O_TMPFILE: (libc)Open-time Flags.
* O_TRUNC: (libc)Open-time Flags.
* O_WRITE: (libc)Access Modes.
* O_WRONLY: (libc)Access Modes.
* PARENB: (libc)Control Modes.
* PARMRK: (libc)Input Modes.
* PARODD: (libc)Control Modes.
* PATH_MAX: (libc)Limits for Files.
* PA_FLAG_MASK: (libc)Parsing a Template String.
* PENDIN: (libc)Local Modes.
* PF_FILE: (libc)Local Namespace Details.
* PF_INET6: (libc)Internet Namespace.
* PF_INET: (libc)Internet Namespace.
* PF_LOCAL: (libc)Local Namespace Details.
* PF_UNIX: (libc)Local Namespace Details.
* PIPE_BUF: (libc)Limits for Files.
* P_tmpdir: (libc)Temporary Files.
* RAND_MAX: (libc)ISO Random.
* RE_DUP_MAX: (libc)General Limits.
* RLIM_INFINITY: (libc)Limits on Resources.
* R_OK: (libc)Testing File Access.
* SA_NOCLDSTOP: (libc)Flags for Sigaction.
* SA_ONSTACK: (libc)Flags for Sigaction.
* SA_RESTART: (libc)Flags for Sigaction.
* SEEK_CUR: (libc)File Positioning.
* SEEK_END: (libc)File Positioning.
* SEEK_SET: (libc)File Positioning.
* SIGABRT: (libc)Program Error Signals.
* SIGALRM: (libc)Alarm Signals.
* SIGBUS: (libc)Program Error Signals.
* SIGCHLD: (libc)Job Control Signals.
* SIGCLD: (libc)Job Control Signals.
* SIGCONT: (libc)Job Control Signals.
* SIGEMT: (libc)Program Error Signals.
* SIGFPE: (libc)Program Error Signals.
* SIGHUP: (libc)Termination Signals.
* SIGILL: (libc)Program Error Signals.
* SIGINFO: (libc)Miscellaneous Signals.
* SIGINT: (libc)Termination Signals.
* SIGIO: (libc)Asynchronous I/O Signals.
* SIGIOT: (libc)Program Error Signals.
* SIGKILL: (libc)Termination Signals.
* SIGLOST: (libc)Operation Error Signals.
* SIGPIPE: (libc)Operation Error Signals.
* SIGPOLL: (libc)Asynchronous I/O Signals.
* SIGPROF: (libc)Alarm Signals.
* SIGQUIT: (libc)Termination Signals.
* SIGSEGV: (libc)Program Error Signals.
* SIGSTOP: (libc)Job Control Signals.
* SIGSYS: (libc)Program Error Signals.
* SIGTERM: (libc)Termination Signals.
* SIGTRAP: (libc)Program Error Signals.
* SIGTSTP: (libc)Job Control Signals.
* SIGTTIN: (libc)Job Control Signals.
* SIGTTOU: (libc)Job Control Signals.
* SIGURG: (libc)Asynchronous I/O Signals.
* SIGUSR1: (libc)Miscellaneous Signals.
* SIGUSR2: (libc)Miscellaneous Signals.
* SIGVTALRM: (libc)Alarm Signals.
* SIGWINCH: (libc)Miscellaneous Signals.
* SIGXCPU: (libc)Operation Error Signals.
* SIGXFSZ: (libc)Operation Error Signals.
* SIG_ERR: (libc)Basic Signal Handling.
* SNAN: (libc)Infinity and NaN.
* SNANF: (libc)Infinity and NaN.
* SNANFN: (libc)Infinity and NaN.
* SNANFNx: (libc)Infinity and NaN.
* SNANL: (libc)Infinity and NaN.
* SOCK_DGRAM: (libc)Communication Styles.
* SOCK_RAW: (libc)Communication Styles.
* SOCK_RDM: (libc)Communication Styles.
* SOCK_SEQPACKET: (libc)Communication Styles.
* SOCK_STREAM: (libc)Communication Styles.
* SOL_SOCKET: (libc)Socket-Level Options.
* SSIZE_MAX: (libc)General Limits.
* STREAM_MAX: (libc)General Limits.
* SUN_LEN: (libc)Local Namespace Details.
* S_IFMT: (libc)Testing File Type.
* S_ISBLK: (libc)Testing File Type.
* S_ISCHR: (libc)Testing File Type.
* S_ISDIR: (libc)Testing File Type.
* S_ISFIFO: (libc)Testing File Type.
* S_ISLNK: (libc)Testing File Type.
* S_ISREG: (libc)Testing File Type.
* S_ISSOCK: (libc)Testing File Type.
* S_TYPEISMQ: (libc)Testing File Type.
* S_TYPEISSEM: (libc)Testing File Type.
* S_TYPEISSHM: (libc)Testing File Type.
* TMP_MAX: (libc)Temporary Files.
* TOSTOP: (libc)Local Modes.
* TZNAME_MAX: (libc)General Limits.
* VDISCARD: (libc)Other Special.
* VDSUSP: (libc)Signal Characters.
* VEOF: (libc)Editing Characters.
* VEOL2: (libc)Editing Characters.
* VEOL: (libc)Editing Characters.
* VERASE: (libc)Editing Characters.
* VINTR: (libc)Signal Characters.
* VKILL: (libc)Editing Characters.
* VLNEXT: (libc)Other Special.
* VMIN: (libc)Noncanonical Input.
* VQUIT: (libc)Signal Characters.
* VREPRINT: (libc)Editing Characters.
* VSTART: (libc)Start/Stop Characters.
* VSTATUS: (libc)Other Special.
* VSTOP: (libc)Start/Stop Characters.
* VSUSP: (libc)Signal Characters.
* VTIME: (libc)Noncanonical Input.
* VWERASE: (libc)Editing Characters.
* WCHAR_MAX: (libc)Extended Char Intro.
* WCHAR_MIN: (libc)Extended Char Intro.
* WCOREDUMP: (libc)Process Completion Status.
* WEOF: (libc)EOF and Errors.
* WEOF: (libc)Extended Char Intro.
* WEXITSTATUS: (libc)Process Completion Status.
* WIFEXITED: (libc)Process Completion Status.
* WIFSIGNALED: (libc)Process Completion Status.
* WIFSTOPPED: (libc)Process Completion Status.
* WSTOPSIG: (libc)Process Completion Status.
* WTERMSIG: (libc)Process Completion Status.
* W_OK: (libc)Testing File Access.
* X_OK: (libc)Testing File Access.
* _Complex_I: (libc)Complex Numbers.
* _Exit: (libc)Termination Internals.
* _IOFBF: (libc)Controlling Buffering.
* _IOLBF: (libc)Controlling Buffering.
* _IONBF: (libc)Controlling Buffering.
* _Imaginary_I: (libc)Complex Numbers.
* _PATH_UTMP: (libc)Manipulating the Database.
* _PATH_WTMP: (libc)Manipulating the Database.
* _POSIX2_C_DEV: (libc)System Options.
* _POSIX2_C_VERSION: (libc)Version Supported.
* _POSIX2_FORT_DEV: (libc)System Options.
* _POSIX2_FORT_RUN: (libc)System Options.
* _POSIX2_LOCALEDEF: (libc)System Options.
* _POSIX2_SW_DEV: (libc)System Options.
* _POSIX_CHOWN_RESTRICTED: (libc)Options for Files.
* _POSIX_JOB_CONTROL: (libc)System Options.
* _POSIX_NO_TRUNC: (libc)Options for Files.
* _POSIX_SAVED_IDS: (libc)System Options.
* _POSIX_VDISABLE: (libc)Options for Files.
* _POSIX_VERSION: (libc)Version Supported.
* __fbufsize: (libc)Controlling Buffering.
* __flbf: (libc)Controlling Buffering.
* __fpending: (libc)Controlling Buffering.
* __fpurge: (libc)Flushing Buffers.
* __freadable: (libc)Opening Streams.
* __freading: (libc)Opening Streams.
* __fsetlocking: (libc)Streams and Threads.
* __fwritable: (libc)Opening Streams.
* __fwriting: (libc)Opening Streams.
* __gconv_end_fct: (libc)glibc iconv Implementation.
* __gconv_fct: (libc)glibc iconv Implementation.
* __gconv_init_fct: (libc)glibc iconv Implementation.
* __ppc_get_timebase: (libc)PowerPC.
* __ppc_get_timebase_freq: (libc)PowerPC.
* __ppc_mdoio: (libc)PowerPC.
* __ppc_mdoom: (libc)PowerPC.
* __ppc_set_ppr_low: (libc)PowerPC.
* __ppc_set_ppr_med: (libc)PowerPC.
* __ppc_set_ppr_med_high: (libc)PowerPC.
* __ppc_set_ppr_med_low: (libc)PowerPC.
* __ppc_set_ppr_very_low: (libc)PowerPC.
* __ppc_yield: (libc)PowerPC.
* __riscv_flush_icache: (libc)RISC-V.
* __va_copy: (libc)Argument Macros.
* _exit: (libc)Termination Internals.
* _flushlbf: (libc)Flushing Buffers.
* _tolower: (libc)Case Conversion.
* _toupper: (libc)Case Conversion.
* a64l: (libc)Encode Binary Data.
* abort: (libc)Aborting a Program.
* abs: (libc)Absolute Value.
* accept: (libc)Accepting Connections.
* access: (libc)Testing File Access.
* acos: (libc)Inverse Trig Functions.
* acosf: (libc)Inverse Trig Functions.
* acosfN: (libc)Inverse Trig Functions.
* acosfNx: (libc)Inverse Trig Functions.
* acosh: (libc)Hyperbolic Functions.
* acoshf: (libc)Hyperbolic Functions.
* acoshfN: (libc)Hyperbolic Functions.
* acoshfNx: (libc)Hyperbolic Functions.
* acoshl: (libc)Hyperbolic Functions.
* acosl: (libc)Inverse Trig Functions.
* addmntent: (libc)mtab.
* addseverity: (libc)Adding Severity Classes.
* adjtime: (libc)High-Resolution Calendar.
* adjtimex: (libc)High-Resolution Calendar.
* aio_cancel64: (libc)Cancel AIO Operations.
* aio_cancel: (libc)Cancel AIO Operations.
* aio_error64: (libc)Status of AIO Operations.
* aio_error: (libc)Status of AIO Operations.
* aio_fsync64: (libc)Synchronizing AIO Operations.
* aio_fsync: (libc)Synchronizing AIO Operations.
* aio_init: (libc)Configuration of AIO.
* aio_read64: (libc)Asynchronous Reads/Writes.
* aio_read: (libc)Asynchronous Reads/Writes.
* aio_return64: (libc)Status of AIO Operations.
* aio_return: (libc)Status of AIO Operations.
* aio_suspend64: (libc)Synchronizing AIO Operations.
* aio_suspend: (libc)Synchronizing AIO Operations.
* aio_write64: (libc)Asynchronous Reads/Writes.
* aio_write: (libc)Asynchronous Reads/Writes.
* alarm: (libc)Setting an Alarm.
* aligned_alloc: (libc)Aligned Memory Blocks.
* alloca: (libc)Variable Size Automatic.
* alphasort64: (libc)Scanning Directory Content.
* alphasort: (libc)Scanning Directory Content.
* argp_error: (libc)Argp Helper Functions.
* argp_failure: (libc)Argp Helper Functions.
* argp_help: (libc)Argp Help.
* argp_parse: (libc)Argp.
* argp_state_help: (libc)Argp Helper Functions.
* argp_usage: (libc)Argp Helper Functions.
* argz_add: (libc)Argz Functions.
* argz_add_sep: (libc)Argz Functions.
* argz_append: (libc)Argz Functions.
* argz_count: (libc)Argz Functions.
* argz_create: (libc)Argz Functions.
* argz_create_sep: (libc)Argz Functions.
* argz_delete: (libc)Argz Functions.
* argz_extract: (libc)Argz Functions.
* argz_insert: (libc)Argz Functions.
* argz_next: (libc)Argz Functions.
* argz_replace: (libc)Argz Functions.
* argz_stringify: (libc)Argz Functions.
* asctime: (libc)Formatting Calendar Time.
* asctime_r: (libc)Formatting Calendar Time.
* asin: (libc)Inverse Trig Functions.
* asinf: (libc)Inverse Trig Functions.
* asinfN: (libc)Inverse Trig Functions.
* asinfNx: (libc)Inverse Trig Functions.
* asinh: (libc)Hyperbolic Functions.
* asinhf: (libc)Hyperbolic Functions.
* asinhfN: (libc)Hyperbolic Functions.
* asinhfNx: (libc)Hyperbolic Functions.
* asinhl: (libc)Hyperbolic Functions.
* asinl: (libc)Inverse Trig Functions.
* asprintf: (libc)Dynamic Output.
* assert: (libc)Consistency Checking.
* assert_perror: (libc)Consistency Checking.
* atan2: (libc)Inverse Trig Functions.
* atan2f: (libc)Inverse Trig Functions.
* atan2fN: (libc)Inverse Trig Functions.
* atan2fNx: (libc)Inverse Trig Functions.
* atan2l: (libc)Inverse Trig Functions.
* atan: (libc)Inverse Trig Functions.
* atanf: (libc)Inverse Trig Functions.
* atanfN: (libc)Inverse Trig Functions.
* atanfNx: (libc)Inverse Trig Functions.
* atanh: (libc)Hyperbolic Functions.
* atanhf: (libc)Hyperbolic Functions.
* atanhfN: (libc)Hyperbolic Functions.
* atanhfNx: (libc)Hyperbolic Functions.
* atanhl: (libc)Hyperbolic Functions.
* atanl: (libc)Inverse Trig Functions.
* atexit: (libc)Cleanups on Exit.
* atof: (libc)Parsing of Floats.
* atoi: (libc)Parsing of Integers.
* atol: (libc)Parsing of Integers.
* atoll: (libc)Parsing of Integers.
* backtrace: (libc)Backtraces.
* backtrace_symbols: (libc)Backtraces.
* backtrace_symbols_fd: (libc)Backtraces.
* basename: (libc)Finding Tokens in a String.
* basename: (libc)Finding Tokens in a String.
* bcmp: (libc)String/Array Comparison.
* bcopy: (libc)Copying Strings and Arrays.
* bind: (libc)Setting Address.
* bind_textdomain_codeset: (libc)Charset conversion in gettext.
* bindtextdomain: (libc)Locating gettext catalog.
* brk: (libc)Resizing the Data Segment.
* bsearch: (libc)Array Search Function.
* btowc: (libc)Converting a Character.
* bzero: (libc)Copying Strings and Arrays.
* cabs: (libc)Absolute Value.
* cabsf: (libc)Absolute Value.
* cabsfN: (libc)Absolute Value.
* cabsfNx: (libc)Absolute Value.
* cabsl: (libc)Absolute Value.
* cacos: (libc)Inverse Trig Functions.
* cacosf: (libc)Inverse Trig Functions.
* cacosfN: (libc)Inverse Trig Functions.
* cacosfNx: (libc)Inverse Trig Functions.
* cacosh: (libc)Hyperbolic Functions.
* cacoshf: (libc)Hyperbolic Functions.
* cacoshfN: (libc)Hyperbolic Functions.
* cacoshfNx: (libc)Hyperbolic Functions.
* cacoshl: (libc)Hyperbolic Functions.
* cacosl: (libc)Inverse Trig Functions.
* call_once: (libc)Call Once.
* calloc: (libc)Allocating Cleared Space.
* canonicalize: (libc)FP Bit Twiddling.
* canonicalize_file_name: (libc)Symbolic Links.
* canonicalizef: (libc)FP Bit Twiddling.
* canonicalizefN: (libc)FP Bit Twiddling.
* canonicalizefNx: (libc)FP Bit Twiddling.
* canonicalizel: (libc)FP Bit Twiddling.
* carg: (libc)Operations on Complex.
* cargf: (libc)Operations on Complex.
* cargfN: (libc)Operations on Complex.
* cargfNx: (libc)Operations on Complex.
* cargl: (libc)Operations on Complex.
* casin: (libc)Inverse Trig Functions.
* casinf: (libc)Inverse Trig Functions.
* casinfN: (libc)Inverse Trig Functions.
* casinfNx: (libc)Inverse Trig Functions.
* casinh: (libc)Hyperbolic Functions.
* casinhf: (libc)Hyperbolic Functions.
* casinhfN: (libc)Hyperbolic Functions.
* casinhfNx: (libc)Hyperbolic Functions.
* casinhl: (libc)Hyperbolic Functions.
* casinl: (libc)Inverse Trig Functions.
* catan: (libc)Inverse Trig Functions.
* catanf: (libc)Inverse Trig Functions.
* catanfN: (libc)Inverse Trig Functions.
* catanfNx: (libc)Inverse Trig Functions.
* catanh: (libc)Hyperbolic Functions.
* catanhf: (libc)Hyperbolic Functions.
* catanhfN: (libc)Hyperbolic Functions.
* catanhfNx: (libc)Hyperbolic Functions.
* catanhl: (libc)Hyperbolic Functions.
* catanl: (libc)Inverse Trig Functions.
* catclose: (libc)The catgets Functions.
* catgets: (libc)The catgets Functions.
* catopen: (libc)The catgets Functions.
* cbrt: (libc)Exponents and Logarithms.
* cbrtf: (libc)Exponents and Logarithms.
* cbrtfN: (libc)Exponents and Logarithms.
* cbrtfNx: (libc)Exponents and Logarithms.
* cbrtl: (libc)Exponents and Logarithms.
* ccos: (libc)Trig Functions.
* ccosf: (libc)Trig Functions.
* ccosfN: (libc)Trig Functions.
* ccosfNx: (libc)Trig Functions.
* ccosh: (libc)Hyperbolic Functions.
* ccoshf: (libc)Hyperbolic Functions.
* ccoshfN: (libc)Hyperbolic Functions.
* ccoshfNx: (libc)Hyperbolic Functions.
* ccoshl: (libc)Hyperbolic Functions.
* ccosl: (libc)Trig Functions.
* ceil: (libc)Rounding Functions.
* ceilf: (libc)Rounding Functions.
* ceilfN: (libc)Rounding Functions.
* ceilfNx: (libc)Rounding Functions.
* ceill: (libc)Rounding Functions.
* cexp: (libc)Exponents and Logarithms.
* cexpf: (libc)Exponents and Logarithms.
* cexpfN: (libc)Exponents and Logarithms.
* cexpfNx: (libc)Exponents and Logarithms.
* cexpl: (libc)Exponents and Logarithms.
* cfgetispeed: (libc)Line Speed.
* cfgetospeed: (libc)Line Speed.
* cfmakeraw: (libc)Noncanonical Input.
* cfsetispeed: (libc)Line Speed.
* cfsetospeed: (libc)Line Speed.
* cfsetspeed: (libc)Line Speed.
* chdir: (libc)Working Directory.
* chmod: (libc)Setting Permissions.
* chown: (libc)File Owner.
* cimag: (libc)Operations on Complex.
* cimagf: (libc)Operations on Complex.
* cimagfN: (libc)Operations on Complex.
* cimagfNx: (libc)Operations on Complex.
* cimagl: (libc)Operations on Complex.
* clearenv: (libc)Environment Access.
* clearerr: (libc)Error Recovery.
* clearerr_unlocked: (libc)Error Recovery.
* clock: (libc)CPU Time.
* clog10: (libc)Exponents and Logarithms.
* clog10f: (libc)Exponents and Logarithms.
* clog10fN: (libc)Exponents and Logarithms.
* clog10fNx: (libc)Exponents and Logarithms.
* clog10l: (libc)Exponents and Logarithms.
* clog: (libc)Exponents and Logarithms.
* clogf: (libc)Exponents and Logarithms.
* clogfN: (libc)Exponents and Logarithms.
* clogfNx: (libc)Exponents and Logarithms.
* clogl: (libc)Exponents and Logarithms.
* close: (libc)Opening and Closing Files.
* closedir: (libc)Reading/Closing Directory.
* closelog: (libc)closelog.
* cnd_broadcast: (libc)ISO C Condition Variables.
* cnd_destroy: (libc)ISO C Condition Variables.
* cnd_init: (libc)ISO C Condition Variables.
* cnd_signal: (libc)ISO C Condition Variables.
* cnd_timedwait: (libc)ISO C Condition Variables.
* cnd_wait: (libc)ISO C Condition Variables.
* confstr: (libc)String Parameters.
* conj: (libc)Operations on Complex.
* conjf: (libc)Operations on Complex.
* conjfN: (libc)Operations on Complex.
* conjfNx: (libc)Operations on Complex.
* conjl: (libc)Operations on Complex.
* connect: (libc)Connecting.
* copy_file_range: (libc)Copying File Data.
* copysign: (libc)FP Bit Twiddling.
* copysignf: (libc)FP Bit Twiddling.
* copysignfN: (libc)FP Bit Twiddling.
* copysignfNx: (libc)FP Bit Twiddling.
* copysignl: (libc)FP Bit Twiddling.
* cos: (libc)Trig Functions.
* cosf: (libc)Trig Functions.
* cosfN: (libc)Trig Functions.
* cosfNx: (libc)Trig Functions.
* cosh: (libc)Hyperbolic Functions.
* coshf: (libc)Hyperbolic Functions.
* coshfN: (libc)Hyperbolic Functions.
* coshfNx: (libc)Hyperbolic Functions.
* coshl: (libc)Hyperbolic Functions.
* cosl: (libc)Trig Functions.
* cpow: (libc)Exponents and Logarithms.
* cpowf: (libc)Exponents and Logarithms.
* cpowfN: (libc)Exponents and Logarithms.
* cpowfNx: (libc)Exponents and Logarithms.
* cpowl: (libc)Exponents and Logarithms.
* cproj: (libc)Operations on Complex.
* cprojf: (libc)Operations on Complex.
* cprojfN: (libc)Operations on Complex.
* cprojfNx: (libc)Operations on Complex.
* cprojl: (libc)Operations on Complex.
* creal: (libc)Operations on Complex.
* crealf: (libc)Operations on Complex.
* crealfN: (libc)Operations on Complex.
* crealfNx: (libc)Operations on Complex.
* creall: (libc)Operations on Complex.
* creat64: (libc)Opening and Closing Files.
* creat: (libc)Opening and Closing Files.
* crypt: (libc)Passphrase Storage.
* crypt_r: (libc)Passphrase Storage.
* csin: (libc)Trig Functions.
* csinf: (libc)Trig Functions.
* csinfN: (libc)Trig Functions.
* csinfNx: (libc)Trig Functions.
* csinh: (libc)Hyperbolic Functions.
* csinhf: (libc)Hyperbolic Functions.
* csinhfN: (libc)Hyperbolic Functions.
* csinhfNx: (libc)Hyperbolic Functions.
* csinhl: (libc)Hyperbolic Functions.
* csinl: (libc)Trig Functions.
* csqrt: (libc)Exponents and Logarithms.
* csqrtf: (libc)Exponents and Logarithms.
* csqrtfN: (libc)Exponents and Logarithms.
* csqrtfNx: (libc)Exponents and Logarithms.
* csqrtl: (libc)Exponents and Logarithms.
* ctan: (libc)Trig Functions.
* ctanf: (libc)Trig Functions.
* ctanfN: (libc)Trig Functions.
* ctanfNx: (libc)Trig Functions.
* ctanh: (libc)Hyperbolic Functions.
* ctanhf: (libc)Hyperbolic Functions.
* ctanhfN: (libc)Hyperbolic Functions.
* ctanhfNx: (libc)Hyperbolic Functions.
* ctanhl: (libc)Hyperbolic Functions.
* ctanl: (libc)Trig Functions.
* ctermid: (libc)Identifying the Terminal.
* ctime: (libc)Formatting Calendar Time.
* ctime_r: (libc)Formatting Calendar Time.
* cuserid: (libc)Who Logged In.
* daddl: (libc)Misc FP Arithmetic.
* dcgettext: (libc)Translation with gettext.
* dcngettext: (libc)Advanced gettext functions.
* ddivl: (libc)Misc FP Arithmetic.
* dgettext: (libc)Translation with gettext.
* difftime: (libc)Elapsed Time.
* dirfd: (libc)Opening a Directory.
* dirname: (libc)Finding Tokens in a String.
* div: (libc)Integer Division.
* dmull: (libc)Misc FP Arithmetic.
* dngettext: (libc)Advanced gettext functions.
* drand48: (libc)SVID Random.
* drand48_r: (libc)SVID Random.
* drem: (libc)Remainder Functions.
* dremf: (libc)Remainder Functions.
* dreml: (libc)Remainder Functions.
* dsubl: (libc)Misc FP Arithmetic.
* dup2: (libc)Duplicating Descriptors.
* dup: (libc)Duplicating Descriptors.
* ecvt: (libc)System V Number Conversion.
* ecvt_r: (libc)System V Number Conversion.
* endfsent: (libc)fstab.
* endgrent: (libc)Scanning All Groups.
* endhostent: (libc)Host Names.
* endmntent: (libc)mtab.
* endnetent: (libc)Networks Database.
* endnetgrent: (libc)Lookup Netgroup.
* endprotoent: (libc)Protocols Database.
* endpwent: (libc)Scanning All Users.
* endservent: (libc)Services Database.
* endutent: (libc)Manipulating the Database.
* endutxent: (libc)XPG Functions.
* envz_add: (libc)Envz Functions.
* envz_entry: (libc)Envz Functions.
* envz_get: (libc)Envz Functions.
* envz_merge: (libc)Envz Functions.
* envz_remove: (libc)Envz Functions.
* envz_strip: (libc)Envz Functions.
* erand48: (libc)SVID Random.
* erand48_r: (libc)SVID Random.
* erf: (libc)Special Functions.
* erfc: (libc)Special Functions.
* erfcf: (libc)Special Functions.
* erfcfN: (libc)Special Functions.
* erfcfNx: (libc)Special Functions.
* erfcl: (libc)Special Functions.
* erff: (libc)Special Functions.
* erffN: (libc)Special Functions.
* erffNx: (libc)Special Functions.
* erfl: (libc)Special Functions.
* err: (libc)Error Messages.
* errno: (libc)Checking for Errors.
* error: (libc)Error Messages.
* error_at_line: (libc)Error Messages.
* errx: (libc)Error Messages.
* execl: (libc)Executing a File.
* execle: (libc)Executing a File.
* execlp: (libc)Executing a File.
* execv: (libc)Executing a File.
* execve: (libc)Executing a File.
* execvp: (libc)Executing a File.
* exit: (libc)Normal Termination.
* exp10: (libc)Exponents and Logarithms.
* exp10f: (libc)Exponents and Logarithms.
* exp10fN: (libc)Exponents and Logarithms.
* exp10fNx: (libc)Exponents and Logarithms.
* exp10l: (libc)Exponents and Logarithms.
* exp2: (libc)Exponents and Logarithms.
* exp2f: (libc)Exponents and Logarithms.
* exp2fN: (libc)Exponents and Logarithms.
* exp2fNx: (libc)Exponents and Logarithms.
* exp2l: (libc)Exponents and Logarithms.
* exp: (libc)Exponents and Logarithms.
* expf: (libc)Exponents and Logarithms.
* expfN: (libc)Exponents and Logarithms.
* expfNx: (libc)Exponents and Logarithms.
* expl: (libc)Exponents and Logarithms.
* explicit_bzero: (libc)Erasing Sensitive Data.
* expm1: (libc)Exponents and Logarithms.
* expm1f: (libc)Exponents and Logarithms.
* expm1fN: (libc)Exponents and Logarithms.
* expm1fNx: (libc)Exponents and Logarithms.
* expm1l: (libc)Exponents and Logarithms.
* fMaddfN: (libc)Misc FP Arithmetic.
* fMaddfNx: (libc)Misc FP Arithmetic.
* fMdivfN: (libc)Misc FP Arithmetic.
* fMdivfNx: (libc)Misc FP Arithmetic.
* fMmulfN: (libc)Misc FP Arithmetic.
* fMmulfNx: (libc)Misc FP Arithmetic.
* fMsubfN: (libc)Misc FP Arithmetic.
* fMsubfNx: (libc)Misc FP Arithmetic.
* fMxaddfN: (libc)Misc FP Arithmetic.
* fMxaddfNx: (libc)Misc FP Arithmetic.
* fMxdivfN: (libc)Misc FP Arithmetic.
* fMxdivfNx: (libc)Misc FP Arithmetic.
* fMxmulfN: (libc)Misc FP Arithmetic.
* fMxmulfNx: (libc)Misc FP Arithmetic.
* fMxsubfN: (libc)Misc FP Arithmetic.
* fMxsubfNx: (libc)Misc FP Arithmetic.
* fabs: (libc)Absolute Value.
* fabsf: (libc)Absolute Value.
* fabsfN: (libc)Absolute Value.
* fabsfNx: (libc)Absolute Value.
* fabsl: (libc)Absolute Value.
* fadd: (libc)Misc FP Arithmetic.
* faddl: (libc)Misc FP Arithmetic.
* fchdir: (libc)Working Directory.
* fchmod: (libc)Setting Permissions.
* fchown: (libc)File Owner.
* fclose: (libc)Closing Streams.
* fcloseall: (libc)Closing Streams.
* fcntl: (libc)Control Operations.
* fcvt: (libc)System V Number Conversion.
* fcvt_r: (libc)System V Number Conversion.
* fdatasync: (libc)Synchronizing I/O.
* fdim: (libc)Misc FP Arithmetic.
* fdimf: (libc)Misc FP Arithmetic.
* fdimfN: (libc)Misc FP Arithmetic.
* fdimfNx: (libc)Misc FP Arithmetic.
* fdiml: (libc)Misc FP Arithmetic.
* fdiv: (libc)Misc FP Arithmetic.
* fdivl: (libc)Misc FP Arithmetic.
* fdopen: (libc)Descriptors and Streams.
* fdopendir: (libc)Opening a Directory.
* feclearexcept: (libc)Status bit operations.
* fedisableexcept: (libc)Control Functions.
* feenableexcept: (libc)Control Functions.
* fegetenv: (libc)Control Functions.
* fegetexcept: (libc)Control Functions.
* fegetexceptflag: (libc)Status bit operations.
* fegetmode: (libc)Control Functions.
* fegetround: (libc)Rounding.
* feholdexcept: (libc)Control Functions.
* feof: (libc)EOF and Errors.
* feof_unlocked: (libc)EOF and Errors.
* feraiseexcept: (libc)Status bit operations.
* ferror: (libc)EOF and Errors.
* ferror_unlocked: (libc)EOF and Errors.
* fesetenv: (libc)Control Functions.
* fesetexcept: (libc)Status bit operations.
* fesetexceptflag: (libc)Status bit operations.
* fesetmode: (libc)Control Functions.
* fesetround: (libc)Rounding.
* fetestexcept: (libc)Status bit operations.
* fetestexceptflag: (libc)Status bit operations.
* feupdateenv: (libc)Control Functions.
* fflush: (libc)Flushing Buffers.
* fflush_unlocked: (libc)Flushing Buffers.
* fgetc: (libc)Character Input.
* fgetc_unlocked: (libc)Character Input.
* fgetgrent: (libc)Scanning All Groups.
* fgetgrent_r: (libc)Scanning All Groups.
* fgetpos64: (libc)Portable Positioning.
* fgetpos: (libc)Portable Positioning.
* fgetpwent: (libc)Scanning All Users.
* fgetpwent_r: (libc)Scanning All Users.
* fgets: (libc)Line Input.
* fgets_unlocked: (libc)Line Input.
* fgetwc: (libc)Character Input.
* fgetwc_unlocked: (libc)Character Input.
* fgetws: (libc)Line Input.
* fgetws_unlocked: (libc)Line Input.
* fileno: (libc)Descriptors and Streams.
* fileno_unlocked: (libc)Descriptors and Streams.
* finite: (libc)Floating Point Classes.
* finitef: (libc)Floating Point Classes.
* finitel: (libc)Floating Point Classes.
* flockfile: (libc)Streams and Threads.
* floor: (libc)Rounding Functions.
* floorf: (libc)Rounding Functions.
* floorfN: (libc)Rounding Functions.
* floorfNx: (libc)Rounding Functions.
* floorl: (libc)Rounding Functions.
* fma: (libc)Misc FP Arithmetic.
* fmaf: (libc)Misc FP Arithmetic.
* fmafN: (libc)Misc FP Arithmetic.
* fmafNx: (libc)Misc FP Arithmetic.
* fmal: (libc)Misc FP Arithmetic.
* fmax: (libc)Misc FP Arithmetic.
* fmaxf: (libc)Misc FP Arithmetic.
* fmaxfN: (libc)Misc FP Arithmetic.
* fmaxfNx: (libc)Misc FP Arithmetic.
* fmaxl: (libc)Misc FP Arithmetic.
* fmaxmag: (libc)Misc FP Arithmetic.
* fmaxmagf: (libc)Misc FP Arithmetic.
* fmaxmagfN: (libc)Misc FP Arithmetic.
* fmaxmagfNx: (libc)Misc FP Arithmetic.
* fmaxmagl: (libc)Misc FP Arithmetic.
* fmemopen: (libc)String Streams.
* fmin: (libc)Misc FP Arithmetic.
* fminf: (libc)Misc FP Arithmetic.
* fminfN: (libc)Misc FP Arithmetic.
* fminfNx: (libc)Misc FP Arithmetic.
* fminl: (libc)Misc FP Arithmetic.
* fminmag: (libc)Misc FP Arithmetic.
* fminmagf: (libc)Misc FP Arithmetic.
* fminmagfN: (libc)Misc FP Arithmetic.
* fminmagfNx: (libc)Misc FP Arithmetic.
* fminmagl: (libc)Misc FP Arithmetic.
* fmod: (libc)Remainder Functions.
* fmodf: (libc)Remainder Functions.
* fmodfN: (libc)Remainder Functions.
* fmodfNx: (libc)Remainder Functions.
* fmodl: (libc)Remainder Functions.
* fmtmsg: (libc)Printing Formatted Messages.
* fmul: (libc)Misc FP Arithmetic.
* fmull: (libc)Misc FP Arithmetic.
* fnmatch: (libc)Wildcard Matching.
* fopen64: (libc)Opening Streams.
* fopen: (libc)Opening Streams.
* fopencookie: (libc)Streams and Cookies.
* fork: (libc)Creating a Process.
* forkpty: (libc)Pseudo-Terminal Pairs.
* fpathconf: (libc)Pathconf.
* fpclassify: (libc)Floating Point Classes.
* fprintf: (libc)Formatted Output Functions.
* fputc: (libc)Simple Output.
* fputc_unlocked: (libc)Simple Output.
* fputs: (libc)Simple Output.
* fputs_unlocked: (libc)Simple Output.
* fputwc: (libc)Simple Output.
* fputwc_unlocked: (libc)Simple Output.
* fputws: (libc)Simple Output.
* fputws_unlocked: (libc)Simple Output.
* fread: (libc)Block Input/Output.
* fread_unlocked: (libc)Block Input/Output.
* free: (libc)Freeing after Malloc.
* freopen64: (libc)Opening Streams.
* freopen: (libc)Opening Streams.
* frexp: (libc)Normalization Functions.
* frexpf: (libc)Normalization Functions.
* frexpfN: (libc)Normalization Functions.
* frexpfNx: (libc)Normalization Functions.
* frexpl: (libc)Normalization Functions.
* fromfp: (libc)Rounding Functions.
* fromfpf: (libc)Rounding Functions.
* fromfpfN: (libc)Rounding Functions.
* fromfpfNx: (libc)Rounding Functions.
* fromfpl: (libc)Rounding Functions.
* fromfpx: (libc)Rounding Functions.
* fromfpxf: (libc)Rounding Functions.
* fromfpxfN: (libc)Rounding Functions.
* fromfpxfNx: (libc)Rounding Functions.
* fromfpxl: (libc)Rounding Functions.
* fscanf: (libc)Formatted Input Functions.
* fseek: (libc)File Positioning.
* fseeko64: (libc)File Positioning.
* fseeko: (libc)File Positioning.
* fsetpos64: (libc)Portable Positioning.
* fsetpos: (libc)Portable Positioning.
* fstat64: (libc)Reading Attributes.
* fstat: (libc)Reading Attributes.
* fsub: (libc)Misc FP Arithmetic.
* fsubl: (libc)Misc FP Arithmetic.
* fsync: (libc)Synchronizing I/O.
* ftell: (libc)File Positioning.
* ftello64: (libc)File Positioning.
* ftello: (libc)File Positioning.
* ftruncate64: (libc)File Size.
* ftruncate: (libc)File Size.
* ftrylockfile: (libc)Streams and Threads.
* ftw64: (libc)Working with Directory Trees.
* ftw: (libc)Working with Directory Trees.
* funlockfile: (libc)Streams and Threads.
* futimes: (libc)File Times.
* fwide: (libc)Streams and I18N.
* fwprintf: (libc)Formatted Output Functions.
* fwrite: (libc)Block Input/Output.
* fwrite_unlocked: (libc)Block Input/Output.
* fwscanf: (libc)Formatted Input Functions.
* gamma: (libc)Special Functions.
* gammaf: (libc)Special Functions.
* gammal: (libc)Special Functions.
* gcvt: (libc)System V Number Conversion.
* get_avphys_pages: (libc)Query Memory Parameters.
* get_current_dir_name: (libc)Working Directory.
* get_nprocs: (libc)Processor Resources.
* get_nprocs_conf: (libc)Processor Resources.
* get_phys_pages: (libc)Query Memory Parameters.
* getauxval: (libc)Auxiliary Vector.
* getc: (libc)Character Input.
* getc_unlocked: (libc)Character Input.
* getchar: (libc)Character Input.
* getchar_unlocked: (libc)Character Input.
* getcontext: (libc)System V contexts.
* getcpu: (libc)CPU Affinity.
* getcwd: (libc)Working Directory.
* getdate: (libc)General Time String Parsing.
* getdate_r: (libc)General Time String Parsing.
* getdelim: (libc)Line Input.
* getdents64: (libc)Low-level Directory Access.
* getdomainnname: (libc)Host Identification.
* getegid: (libc)Reading Persona.
* getentropy: (libc)Unpredictable Bytes.
* getenv: (libc)Environment Access.
* geteuid: (libc)Reading Persona.
* getfsent: (libc)fstab.
* getfsfile: (libc)fstab.
* getfsspec: (libc)fstab.
* getgid: (libc)Reading Persona.
* getgrent: (libc)Scanning All Groups.
* getgrent_r: (libc)Scanning All Groups.
* getgrgid: (libc)Lookup Group.
* getgrgid_r: (libc)Lookup Group.
* getgrnam: (libc)Lookup Group.
* getgrnam_r: (libc)Lookup Group.
* getgrouplist: (libc)Setting Groups.
* getgroups: (libc)Reading Persona.
* gethostbyaddr: (libc)Host Names.
* gethostbyaddr_r: (libc)Host Names.
* gethostbyname2: (libc)Host Names.
* gethostbyname2_r: (libc)Host Names.
* gethostbyname: (libc)Host Names.
* gethostbyname_r: (libc)Host Names.
* gethostent: (libc)Host Names.
* gethostid: (libc)Host Identification.
* gethostname: (libc)Host Identification.
* getitimer: (libc)Setting an Alarm.
* getline: (libc)Line Input.
* getloadavg: (libc)Processor Resources.
* getlogin: (libc)Who Logged In.
* getmntent: (libc)mtab.
* getmntent_r: (libc)mtab.
* getnetbyaddr: (libc)Networks Database.
* getnetbyname: (libc)Networks Database.
* getnetent: (libc)Networks Database.
* getnetgrent: (libc)Lookup Netgroup.
* getnetgrent_r: (libc)Lookup Netgroup.
* getopt: (libc)Using Getopt.
* getopt_long: (libc)Getopt Long Options.
* getopt_long_only: (libc)Getopt Long Options.
* getpagesize: (libc)Query Memory Parameters.
* getpass: (libc)getpass.
* getpayload: (libc)FP Bit Twiddling.
* getpayloadf: (libc)FP Bit Twiddling.
* getpayloadfN: (libc)FP Bit Twiddling.
* getpayloadfNx: (libc)FP Bit Twiddling.
* getpayloadl: (libc)FP Bit Twiddling.
* getpeername: (libc)Who is Connected.
* getpgid: (libc)Process Group Functions.
* getpgrp: (libc)Process Group Functions.
* getpid: (libc)Process Identification.
* getppid: (libc)Process Identification.
* getpriority: (libc)Traditional Scheduling Functions.
* getprotobyname: (libc)Protocols Database.
* getprotobynumber: (libc)Protocols Database.
* getprotoent: (libc)Protocols Database.
* getpt: (libc)Allocation.
* getpwent: (libc)Scanning All Users.
* getpwent_r: (libc)Scanning All Users.
* getpwnam: (libc)Lookup User.
* getpwnam_r: (libc)Lookup User.
* getpwuid: (libc)Lookup User.
* getpwuid_r: (libc)Lookup User.
* getrandom: (libc)Unpredictable Bytes.
* getrlimit64: (libc)Limits on Resources.
* getrlimit: (libc)Limits on Resources.
* getrusage: (libc)Resource Usage.
* gets: (libc)Line Input.
* getservbyname: (libc)Services Database.
* getservbyport: (libc)Services Database.
* getservent: (libc)Services Database.
* getsid: (libc)Process Group Functions.
* getsockname: (libc)Reading Address.
* getsockopt: (libc)Socket Option Functions.
* getsubopt: (libc)Suboptions.
* gettext: (libc)Translation with gettext.
* gettid: (libc)Process Identification.
* gettimeofday: (libc)High-Resolution Calendar.
* getuid: (libc)Reading Persona.
* getumask: (libc)Setting Permissions.
* getutent: (libc)Manipulating the Database.
* getutent_r: (libc)Manipulating the Database.
* getutid: (libc)Manipulating the Database.
* getutid_r: (libc)Manipulating the Database.
* getutline: (libc)Manipulating the Database.
* getutline_r: (libc)Manipulating the Database.
* getutmp: (libc)XPG Functions.
* getutmpx: (libc)XPG Functions.
* getutxent: (libc)XPG Functions.
* getutxid: (libc)XPG Functions.
* getutxline: (libc)XPG Functions.
* getw: (libc)Character Input.
* getwc: (libc)Character Input.
* getwc_unlocked: (libc)Character Input.
* getwchar: (libc)Character Input.
* getwchar_unlocked: (libc)Character Input.
* getwd: (libc)Working Directory.
* glob64: (libc)Calling Glob.
* glob: (libc)Calling Glob.
* globfree64: (libc)More Flags for Globbing.
* globfree: (libc)More Flags for Globbing.
* gmtime: (libc)Broken-down Time.
* gmtime_r: (libc)Broken-down Time.
* grantpt: (libc)Allocation.
* gsignal: (libc)Signaling Yourself.
* gtty: (libc)BSD Terminal Modes.
* hasmntopt: (libc)mtab.
* hcreate: (libc)Hash Search Function.
* hcreate_r: (libc)Hash Search Function.
* hdestroy: (libc)Hash Search Function.
* hdestroy_r: (libc)Hash Search Function.
* hsearch: (libc)Hash Search Function.
* hsearch_r: (libc)Hash Search Function.
* htonl: (libc)Byte Order.
* htons: (libc)Byte Order.
* hypot: (libc)Exponents and Logarithms.
* hypotf: (libc)Exponents and Logarithms.
* hypotfN: (libc)Exponents and Logarithms.
* hypotfNx: (libc)Exponents and Logarithms.
* hypotl: (libc)Exponents and Logarithms.
* iconv: (libc)Generic Conversion Interface.
* iconv_close: (libc)Generic Conversion Interface.
* iconv_open: (libc)Generic Conversion Interface.
* if_freenameindex: (libc)Interface Naming.
* if_indextoname: (libc)Interface Naming.
* if_nameindex: (libc)Interface Naming.
* if_nametoindex: (libc)Interface Naming.
* ilogb: (libc)Exponents and Logarithms.
* ilogbf: (libc)Exponents and Logarithms.
* ilogbfN: (libc)Exponents and Logarithms.
* ilogbfNx: (libc)Exponents and Logarithms.
* ilogbl: (libc)Exponents and Logarithms.
* imaxabs: (libc)Absolute Value.
* imaxdiv: (libc)Integer Division.
* in6addr_any: (libc)Host Address Data Type.
* in6addr_loopback: (libc)Host Address Data Type.
* index: (libc)Search Functions.
* inet_addr: (libc)Host Address Functions.
* inet_aton: (libc)Host Address Functions.
* inet_lnaof: (libc)Host Address Functions.
* inet_makeaddr: (libc)Host Address Functions.
* inet_netof: (libc)Host Address Functions.
* inet_network: (libc)Host Address Functions.
* inet_ntoa: (libc)Host Address Functions.
* inet_ntop: (libc)Host Address Functions.
* inet_pton: (libc)Host Address Functions.
* initgroups: (libc)Setting Groups.
* initstate: (libc)BSD Random.
* initstate_r: (libc)BSD Random.
* innetgr: (libc)Netgroup Membership.
* ioctl: (libc)IOCTLs.
* isalnum: (libc)Classification of Characters.
* isalpha: (libc)Classification of Characters.
* isascii: (libc)Classification of Characters.
* isatty: (libc)Is It a Terminal.
* isblank: (libc)Classification of Characters.
* iscanonical: (libc)Floating Point Classes.
* iscntrl: (libc)Classification of Characters.
* isdigit: (libc)Classification of Characters.
* iseqsig: (libc)FP Comparison Functions.
* isfinite: (libc)Floating Point Classes.
* isgraph: (libc)Classification of Characters.
* isgreater: (libc)FP Comparison Functions.
* isgreaterequal: (libc)FP Comparison Functions.
* isinf: (libc)Floating Point Classes.
* isinff: (libc)Floating Point Classes.
* isinfl: (libc)Floating Point Classes.
* isless: (libc)FP Comparison Functions.
* islessequal: (libc)FP Comparison Functions.
* islessgreater: (libc)FP Comparison Functions.
* islower: (libc)Classification of Characters.
* isnan: (libc)Floating Point Classes.
* isnan: (libc)Floating Point Classes.
* isnanf: (libc)Floating Point Classes.
* isnanl: (libc)Floating Point Classes.
* isnormal: (libc)Floating Point Classes.
* isprint: (libc)Classification of Characters.
* ispunct: (libc)Classification of Characters.
* issignaling: (libc)Floating Point Classes.
* isspace: (libc)Classification of Characters.
* issubnormal: (libc)Floating Point Classes.
* isunordered: (libc)FP Comparison Functions.
* isupper: (libc)Classification of Characters.
* iswalnum: (libc)Classification of Wide Characters.
* iswalpha: (libc)Classification of Wide Characters.
* iswblank: (libc)Classification of Wide Characters.
* iswcntrl: (libc)Classification of Wide Characters.
* iswctype: (libc)Classification of Wide Characters.
* iswdigit: (libc)Classification of Wide Characters.
* iswgraph: (libc)Classification of Wide Characters.
* iswlower: (libc)Classification of Wide Characters.
* iswprint: (libc)Classification of Wide Characters.
* iswpunct: (libc)Classification of Wide Characters.
* iswspace: (libc)Classification of Wide Characters.
* iswupper: (libc)Classification of Wide Characters.
* iswxdigit: (libc)Classification of Wide Characters.
* isxdigit: (libc)Classification of Characters.
* iszero: (libc)Floating Point Classes.
* j0: (libc)Special Functions.
* j0f: (libc)Special Functions.
* j0fN: (libc)Special Functions.
* j0fNx: (libc)Special Functions.
* j0l: (libc)Special Functions.
* j1: (libc)Special Functions.
* j1f: (libc)Special Functions.
* j1fN: (libc)Special Functions.
* j1fNx: (libc)Special Functions.
* j1l: (libc)Special Functions.
* jn: (libc)Special Functions.
* jnf: (libc)Special Functions.
* jnfN: (libc)Special Functions.
* jnfNx: (libc)Special Functions.
* jnl: (libc)Special Functions.
* jrand48: (libc)SVID Random.
* jrand48_r: (libc)SVID Random.
* kill: (libc)Signaling Another Process.
* killpg: (libc)Signaling Another Process.
* l64a: (libc)Encode Binary Data.
* labs: (libc)Absolute Value.
* lcong48: (libc)SVID Random.
* lcong48_r: (libc)SVID Random.
* ldexp: (libc)Normalization Functions.
* ldexpf: (libc)Normalization Functions.
* ldexpfN: (libc)Normalization Functions.
* ldexpfNx: (libc)Normalization Functions.
* ldexpl: (libc)Normalization Functions.
* ldiv: (libc)Integer Division.
* lfind: (libc)Array Search Function.
* lgamma: (libc)Special Functions.
* lgamma_r: (libc)Special Functions.
* lgammaf: (libc)Special Functions.
* lgammafN: (libc)Special Functions.
* lgammafN_r: (libc)Special Functions.
* lgammafNx: (libc)Special Functions.
* lgammafNx_r: (libc)Special Functions.
* lgammaf_r: (libc)Special Functions.
* lgammal: (libc)Special Functions.
* lgammal_r: (libc)Special Functions.
* link: (libc)Hard Links.
* linkat: (libc)Hard Links.
* lio_listio64: (libc)Asynchronous Reads/Writes.
* lio_listio: (libc)Asynchronous Reads/Writes.
* listen: (libc)Listening.
* llabs: (libc)Absolute Value.
* lldiv: (libc)Integer Division.
* llogb: (libc)Exponents and Logarithms.
* llogbf: (libc)Exponents and Logarithms.
* llogbfN: (libc)Exponents and Logarithms.
* llogbfNx: (libc)Exponents and Logarithms.
* llogbl: (libc)Exponents and Logarithms.
* llrint: (libc)Rounding Functions.
* llrintf: (libc)Rounding Functions.
* llrintfN: (libc)Rounding Functions.
* llrintfNx: (libc)Rounding Functions.
* llrintl: (libc)Rounding Functions.
* llround: (libc)Rounding Functions.
* llroundf: (libc)Rounding Functions.
* llroundfN: (libc)Rounding Functions.
* llroundfNx: (libc)Rounding Functions.
* llroundl: (libc)Rounding Functions.
* localeconv: (libc)The Lame Way to Locale Data.
* localtime: (libc)Broken-down Time.
* localtime_r: (libc)Broken-down Time.
* log10: (libc)Exponents and Logarithms.
* log10f: (libc)Exponents and Logarithms.
* log10fN: (libc)Exponents and Logarithms.
* log10fNx: (libc)Exponents and Logarithms.
* log10l: (libc)Exponents and Logarithms.
* log1p: (libc)Exponents and Logarithms.
* log1pf: (libc)Exponents and Logarithms.
* log1pfN: (libc)Exponents and Logarithms.
* log1pfNx: (libc)Exponents and Logarithms.
* log1pl: (libc)Exponents and Logarithms.
* log2: (libc)Exponents and Logarithms.
* log2f: (libc)Exponents and Logarithms.
* log2fN: (libc)Exponents and Logarithms.
* log2fNx: (libc)Exponents and Logarithms.
* log2l: (libc)Exponents and Logarithms.
* log: (libc)Exponents and Logarithms.
* logb: (libc)Exponents and Logarithms.
* logbf: (libc)Exponents and Logarithms.
* logbfN: (libc)Exponents and Logarithms.
* logbfNx: (libc)Exponents and Logarithms.
* logbl: (libc)Exponents and Logarithms.
* logf: (libc)Exponents and Logarithms.
* logfN: (libc)Exponents and Logarithms.
* logfNx: (libc)Exponents and Logarithms.
* login: (libc)Logging In and Out.
* login_tty: (libc)Logging In and Out.
* logl: (libc)Exponents and Logarithms.
* logout: (libc)Logging In and Out.
* logwtmp: (libc)Logging In and Out.
* longjmp: (libc)Non-Local Details.
* lrand48: (libc)SVID Random.
* lrand48_r: (libc)SVID Random.
* lrint: (libc)Rounding Functions.
* lrintf: (libc)Rounding Functions.
* lrintfN: (libc)Rounding Functions.
* lrintfNx: (libc)Rounding Functions.
* lrintl: (libc)Rounding Functions.
* lround: (libc)Rounding Functions.
* lroundf: (libc)Rounding Functions.
* lroundfN: (libc)Rounding Functions.
* lroundfNx: (libc)Rounding Functions.
* lroundl: (libc)Rounding Functions.
* lsearch: (libc)Array Search Function.
* lseek64: (libc)File Position Primitive.
* lseek: (libc)File Position Primitive.
* lstat64: (libc)Reading Attributes.
* lstat: (libc)Reading Attributes.
* lutimes: (libc)File Times.
* madvise: (libc)Memory-mapped I/O.
* makecontext: (libc)System V contexts.
* mallinfo: (libc)Statistics of Malloc.
* malloc: (libc)Basic Allocation.
* mallopt: (libc)Malloc Tunable Parameters.
* mblen: (libc)Non-reentrant Character Conversion.
* mbrlen: (libc)Converting a Character.
* mbrtowc: (libc)Converting a Character.
* mbsinit: (libc)Keeping the state.
* mbsnrtowcs: (libc)Converting Strings.
* mbsrtowcs: (libc)Converting Strings.
* mbstowcs: (libc)Non-reentrant String Conversion.
* mbtowc: (libc)Non-reentrant Character Conversion.
* mcheck: (libc)Heap Consistency Checking.
* memalign: (libc)Aligned Memory Blocks.
* memccpy: (libc)Copying Strings and Arrays.
* memchr: (libc)Search Functions.
* memcmp: (libc)String/Array Comparison.
* memcpy: (libc)Copying Strings and Arrays.
* memfd_create: (libc)Memory-mapped I/O.
* memfrob: (libc)Obfuscating Data.
* memmem: (libc)Search Functions.
* memmove: (libc)Copying Strings and Arrays.
* mempcpy: (libc)Copying Strings and Arrays.
* memrchr: (libc)Search Functions.
* memset: (libc)Copying Strings and Arrays.
* mkdir: (libc)Creating Directories.
* mkdtemp: (libc)Temporary Files.
* mkfifo: (libc)FIFO Special Files.
* mknod: (libc)Making Special Files.
* mkstemp: (libc)Temporary Files.
* mktemp: (libc)Temporary Files.
* mktime: (libc)Broken-down Time.
* mlock2: (libc)Page Lock Functions.
* mlock: (libc)Page Lock Functions.
* mlockall: (libc)Page Lock Functions.
* mmap64: (libc)Memory-mapped I/O.
* mmap: (libc)Memory-mapped I/O.
* modf: (libc)Rounding Functions.
* modff: (libc)Rounding Functions.
* modffN: (libc)Rounding Functions.
* modffNx: (libc)Rounding Functions.
* modfl: (libc)Rounding Functions.
* mount: (libc)Mount-Unmount-Remount.
* mprobe: (libc)Heap Consistency Checking.
* mprotect: (libc)Memory Protection.
* mrand48: (libc)SVID Random.
* mrand48_r: (libc)SVID Random.
* mremap: (libc)Memory-mapped I/O.
* msync: (libc)Memory-mapped I/O.
* mtrace: (libc)Tracing malloc.
* mtx_destroy: (libc)ISO C Mutexes.
* mtx_init: (libc)ISO C Mutexes.
* mtx_lock: (libc)ISO C Mutexes.
* mtx_timedlock: (libc)ISO C Mutexes.
* mtx_trylock: (libc)ISO C Mutexes.
* mtx_unlock: (libc)ISO C Mutexes.
* munlock: (libc)Page Lock Functions.
* munlockall: (libc)Page Lock Functions.
* munmap: (libc)Memory-mapped I/O.
* muntrace: (libc)Tracing malloc.
* nan: (libc)FP Bit Twiddling.
* nanf: (libc)FP Bit Twiddling.
* nanfN: (libc)FP Bit Twiddling.
* nanfNx: (libc)FP Bit Twiddling.
* nanl: (libc)FP Bit Twiddling.
* nanosleep: (libc)Sleeping.
* nearbyint: (libc)Rounding Functions.
* nearbyintf: (libc)Rounding Functions.
* nearbyintfN: (libc)Rounding Functions.
* nearbyintfNx: (libc)Rounding Functions.
* nearbyintl: (libc)Rounding Functions.
* nextafter: (libc)FP Bit Twiddling.
* nextafterf: (libc)FP Bit Twiddling.
* nextafterfN: (libc)FP Bit Twiddling.
* nextafterfNx: (libc)FP Bit Twiddling.
* nextafterl: (libc)FP Bit Twiddling.
* nextdown: (libc)FP Bit Twiddling.
* nextdownf: (libc)FP Bit Twiddling.
* nextdownfN: (libc)FP Bit Twiddling.
* nextdownfNx: (libc)FP Bit Twiddling.
* nextdownl: (libc)FP Bit Twiddling.
* nexttoward: (libc)FP Bit Twiddling.
* nexttowardf: (libc)FP Bit Twiddling.
* nexttowardl: (libc)FP Bit Twiddling.
* nextup: (libc)FP Bit Twiddling.
* nextupf: (libc)FP Bit Twiddling.
* nextupfN: (libc)FP Bit Twiddling.
* nextupfNx: (libc)FP Bit Twiddling.
* nextupl: (libc)FP Bit Twiddling.
* nftw64: (libc)Working with Directory Trees.
* nftw: (libc)Working with Directory Trees.
* ngettext: (libc)Advanced gettext functions.
* nice: (libc)Traditional Scheduling Functions.
* nl_langinfo: (libc)The Elegant and Fast Way.
* nrand48: (libc)SVID Random.
* nrand48_r: (libc)SVID Random.
* ntohl: (libc)Byte Order.
* ntohs: (libc)Byte Order.
* ntp_adjtime: (libc)High Accuracy Clock.
* ntp_gettime: (libc)High Accuracy Clock.
* obstack_1grow: (libc)Growing Objects.
* obstack_1grow_fast: (libc)Extra Fast Growing.
* obstack_alignment_mask: (libc)Obstacks Data Alignment.
* obstack_alloc: (libc)Allocation in an Obstack.
* obstack_base: (libc)Status of an Obstack.
* obstack_blank: (libc)Growing Objects.
* obstack_blank_fast: (libc)Extra Fast Growing.
* obstack_chunk_size: (libc)Obstack Chunks.
* obstack_copy0: (libc)Allocation in an Obstack.
* obstack_copy: (libc)Allocation in an Obstack.
* obstack_finish: (libc)Growing Objects.
* obstack_free: (libc)Freeing Obstack Objects.
* obstack_grow0: (libc)Growing Objects.
* obstack_grow: (libc)Growing Objects.
* obstack_init: (libc)Preparing for Obstacks.
* obstack_int_grow: (libc)Growing Objects.
* obstack_int_grow_fast: (libc)Extra Fast Growing.
* obstack_next_free: (libc)Status of an Obstack.
* obstack_object_size: (libc)Growing Objects.
* obstack_object_size: (libc)Status of an Obstack.
* obstack_printf: (libc)Dynamic Output.
* obstack_ptr_grow: (libc)Growing Objects.
* obstack_ptr_grow_fast: (libc)Extra Fast Growing.
* obstack_room: (libc)Extra Fast Growing.
* obstack_vprintf: (libc)Variable Arguments Output.
* offsetof: (libc)Structure Measurement.
* on_exit: (libc)Cleanups on Exit.
* open64: (libc)Opening and Closing Files.
* open: (libc)Opening and Closing Files.
* open_memstream: (libc)String Streams.
* opendir: (libc)Opening a Directory.
* openlog: (libc)openlog.
* openpty: (libc)Pseudo-Terminal Pairs.
* parse_printf_format: (libc)Parsing a Template String.
* pathconf: (libc)Pathconf.
* pause: (libc)Using Pause.
* pclose: (libc)Pipe to a Subprocess.
* perror: (libc)Error Messages.
* pipe: (libc)Creating a Pipe.
* pkey_alloc: (libc)Memory Protection.
* pkey_free: (libc)Memory Protection.
* pkey_get: (libc)Memory Protection.
* pkey_mprotect: (libc)Memory Protection.
* pkey_set: (libc)Memory Protection.
* popen: (libc)Pipe to a Subprocess.
* posix_fallocate64: (libc)Storage Allocation.
* posix_fallocate: (libc)Storage Allocation.
* posix_memalign: (libc)Aligned Memory Blocks.
* pow: (libc)Exponents and Logarithms.
* powf: (libc)Exponents and Logarithms.
* powfN: (libc)Exponents and Logarithms.
* powfNx: (libc)Exponents and Logarithms.
* powl: (libc)Exponents and Logarithms.
* pread64: (libc)I/O Primitives.
* pread: (libc)I/O Primitives.
* preadv2: (libc)Scatter-Gather.
* preadv64: (libc)Scatter-Gather.
* preadv64v2: (libc)Scatter-Gather.
* preadv: (libc)Scatter-Gather.
* printf: (libc)Formatted Output Functions.
* printf_size: (libc)Predefined Printf Handlers.
* printf_size_info: (libc)Predefined Printf Handlers.
* psignal: (libc)Signal Messages.
* pthread_cond_clockwait: (libc)Default Thread Attributes.
* pthread_getattr_default_np: (libc)Default Thread Attributes.
* pthread_getspecific: (libc)Thread-specific Data.
* pthread_key_create: (libc)Thread-specific Data.
* pthread_key_delete: (libc)Thread-specific Data.
* pthread_rwlock_clockrdlock: (libc)Default Thread Attributes.
* pthread_rwlock_clockwrlock: (libc)Default Thread Attributes.
* pthread_setattr_default_np: (libc)Default Thread Attributes.
* pthread_setspecific: (libc)Thread-specific Data.
* ptsname: (libc)Allocation.
* ptsname_r: (libc)Allocation.
* putc: (libc)Simple Output.
* putc_unlocked: (libc)Simple Output.
* putchar: (libc)Simple Output.
* putchar_unlocked: (libc)Simple Output.
* putenv: (libc)Environment Access.
* putpwent: (libc)Writing a User Entry.
* puts: (libc)Simple Output.
* pututline: (libc)Manipulating the Database.
* pututxline: (libc)XPG Functions.
* putw: (libc)Simple Output.
* putwc: (libc)Simple Output.
* putwc_unlocked: (libc)Simple Output.
* putwchar: (libc)Simple Output.
* putwchar_unlocked: (libc)Simple Output.
* pwrite64: (libc)I/O Primitives.
* pwrite: (libc)I/O Primitives.
* pwritev2: (libc)Scatter-Gather.
* pwritev64: (libc)Scatter-Gather.
* pwritev64v2: (libc)Scatter-Gather.
* pwritev: (libc)Scatter-Gather.
* qecvt: (libc)System V Number Conversion.
* qecvt_r: (libc)System V Number Conversion.
* qfcvt: (libc)System V Number Conversion.
* qfcvt_r: (libc)System V Number Conversion.
* qgcvt: (libc)System V Number Conversion.
* qsort: (libc)Array Sort Function.
* raise: (libc)Signaling Yourself.
* rand: (libc)ISO Random.
* rand_r: (libc)ISO Random.
* random: (libc)BSD Random.
* random_r: (libc)BSD Random.
* rawmemchr: (libc)Search Functions.
* read: (libc)I/O Primitives.
* readdir64: (libc)Reading/Closing Directory.
* readdir64_r: (libc)Reading/Closing Directory.
* readdir: (libc)Reading/Closing Directory.
* readdir_r: (libc)Reading/Closing Directory.
* readlink: (libc)Symbolic Links.
* readv: (libc)Scatter-Gather.
* realloc: (libc)Changing Block Size.
* reallocarray: (libc)Changing Block Size.
* realpath: (libc)Symbolic Links.
* recv: (libc)Receiving Data.
* recvfrom: (libc)Receiving Datagrams.
* recvmsg: (libc)Receiving Datagrams.
* regcomp: (libc)POSIX Regexp Compilation.
* regerror: (libc)Regexp Cleanup.
* regexec: (libc)Matching POSIX Regexps.
* regfree: (libc)Regexp Cleanup.
* register_printf_function: (libc)Registering New Conversions.
* remainder: (libc)Remainder Functions.
* remainderf: (libc)Remainder Functions.
* remainderfN: (libc)Remainder Functions.
* remainderfNx: (libc)Remainder Functions.
* remainderl: (libc)Remainder Functions.
* remove: (libc)Deleting Files.
* rename: (libc)Renaming Files.
* rewind: (libc)File Positioning.
* rewinddir: (libc)Random Access Directory.
* rindex: (libc)Search Functions.
* rint: (libc)Rounding Functions.
* rintf: (libc)Rounding Functions.
* rintfN: (libc)Rounding Functions.
* rintfNx: (libc)Rounding Functions.
* rintl: (libc)Rounding Functions.
* rmdir: (libc)Deleting Files.
* round: (libc)Rounding Functions.
* roundeven: (libc)Rounding Functions.
* roundevenf: (libc)Rounding Functions.
* roundevenfN: (libc)Rounding Functions.
* roundevenfNx: (libc)Rounding Functions.
* roundevenl: (libc)Rounding Functions.
* roundf: (libc)Rounding Functions.
* roundfN: (libc)Rounding Functions.
* roundfNx: (libc)Rounding Functions.
* roundl: (libc)Rounding Functions.
* rpmatch: (libc)Yes-or-No Questions.
* sbrk: (libc)Resizing the Data Segment.
* scalb: (libc)Normalization Functions.
* scalbf: (libc)Normalization Functions.
* scalbl: (libc)Normalization Functions.
* scalbln: (libc)Normalization Functions.
* scalblnf: (libc)Normalization Functions.
* scalblnfN: (libc)Normalization Functions.
* scalblnfNx: (libc)Normalization Functions.
* scalblnl: (libc)Normalization Functions.
* scalbn: (libc)Normalization Functions.
* scalbnf: (libc)Normalization Functions.
* scalbnfN: (libc)Normalization Functions.
* scalbnfNx: (libc)Normalization Functions.
* scalbnl: (libc)Normalization Functions.
* scandir64: (libc)Scanning Directory Content.
* scandir: (libc)Scanning Directory Content.
* scanf: (libc)Formatted Input Functions.
* sched_get_priority_max: (libc)Basic Scheduling Functions.
* sched_get_priority_min: (libc)Basic Scheduling Functions.
* sched_getaffinity: (libc)CPU Affinity.
* sched_getparam: (libc)Basic Scheduling Functions.
* sched_getscheduler: (libc)Basic Scheduling Functions.
* sched_rr_get_interval: (libc)Basic Scheduling Functions.
* sched_setaffinity: (libc)CPU Affinity.
* sched_setparam: (libc)Basic Scheduling Functions.
* sched_setscheduler: (libc)Basic Scheduling Functions.
* sched_yield: (libc)Basic Scheduling Functions.
* secure_getenv: (libc)Environment Access.
* seed48: (libc)SVID Random.
* seed48_r: (libc)SVID Random.
* seekdir: (libc)Random Access Directory.
* select: (libc)Waiting for I/O.
* sem_clockwait: (libc)Default Thread Attributes.
* sem_close: (libc)Semaphores.
* sem_destroy: (libc)Semaphores.
* sem_getvalue: (libc)Semaphores.
* sem_init: (libc)Semaphores.
* sem_open: (libc)Semaphores.
* sem_post: (libc)Semaphores.
* sem_timedwait: (libc)Semaphores.
* sem_trywait: (libc)Semaphores.
* sem_unlink: (libc)Semaphores.
* sem_wait: (libc)Semaphores.
* semctl: (libc)Semaphores.
* semget: (libc)Semaphores.
* semop: (libc)Semaphores.
* semtimedop: (libc)Semaphores.
* send: (libc)Sending Data.
* sendmsg: (libc)Receiving Datagrams.
* sendto: (libc)Sending Datagrams.
* setbuf: (libc)Controlling Buffering.
* setbuffer: (libc)Controlling Buffering.
* setcontext: (libc)System V contexts.
* setdomainname: (libc)Host Identification.
* setegid: (libc)Setting Groups.
* setenv: (libc)Environment Access.
* seteuid: (libc)Setting User ID.
* setfsent: (libc)fstab.
* setgid: (libc)Setting Groups.
* setgrent: (libc)Scanning All Groups.
* setgroups: (libc)Setting Groups.
* sethostent: (libc)Host Names.
* sethostid: (libc)Host Identification.
* sethostname: (libc)Host Identification.
* setitimer: (libc)Setting an Alarm.
* setjmp: (libc)Non-Local Details.
* setlinebuf: (libc)Controlling Buffering.
* setlocale: (libc)Setting the Locale.
* setlogmask: (libc)setlogmask.
* setmntent: (libc)mtab.
* setnetent: (libc)Networks Database.
* setnetgrent: (libc)Lookup Netgroup.
* setpayload: (libc)FP Bit Twiddling.
* setpayloadf: (libc)FP Bit Twiddling.
* setpayloadfN: (libc)FP Bit Twiddling.
* setpayloadfNx: (libc)FP Bit Twiddling.
* setpayloadl: (libc)FP Bit Twiddling.
* setpayloadsig: (libc)FP Bit Twiddling.
* setpayloadsigf: (libc)FP Bit Twiddling.
* setpayloadsigfN: (libc)FP Bit Twiddling.
* setpayloadsigfNx: (libc)FP Bit Twiddling.
* setpayloadsigl: (libc)FP Bit Twiddling.
* setpgid: (libc)Process Group Functions.
* setpgrp: (libc)Process Group Functions.
* setpriority: (libc)Traditional Scheduling Functions.
* setprotoent: (libc)Protocols Database.
* setpwent: (libc)Scanning All Users.
* setregid: (libc)Setting Groups.
* setreuid: (libc)Setting User ID.
* setrlimit64: (libc)Limits on Resources.
* setrlimit: (libc)Limits on Resources.
* setservent: (libc)Services Database.
* setsid: (libc)Process Group Functions.
* setsockopt: (libc)Socket Option Functions.
* setstate: (libc)BSD Random.
* setstate_r: (libc)BSD Random.
* settimeofday: (libc)High-Resolution Calendar.
* setuid: (libc)Setting User ID.
* setutent: (libc)Manipulating the Database.
* setutxent: (libc)XPG Functions.
* setvbuf: (libc)Controlling Buffering.
* shm_open: (libc)Memory-mapped I/O.
* shm_unlink: (libc)Memory-mapped I/O.
* shutdown: (libc)Closing a Socket.
* sigaction: (libc)Advanced Signal Handling.
* sigaddset: (libc)Signal Sets.
* sigaltstack: (libc)Signal Stack.
* sigblock: (libc)BSD Signal Handling.
* sigdelset: (libc)Signal Sets.
* sigemptyset: (libc)Signal Sets.
* sigfillset: (libc)Signal Sets.
* siginterrupt: (libc)BSD Signal Handling.
* sigismember: (libc)Signal Sets.
* siglongjmp: (libc)Non-Local Exits and Signals.
* sigmask: (libc)BSD Signal Handling.
* signal: (libc)Basic Signal Handling.
* signbit: (libc)FP Bit Twiddling.
* significand: (libc)Normalization Functions.
* significandf: (libc)Normalization Functions.
* significandl: (libc)Normalization Functions.
* sigpause: (libc)BSD Signal Handling.
* sigpending: (libc)Checking for Pending Signals.
* sigprocmask: (libc)Process Signal Mask.
* sigsetjmp: (libc)Non-Local Exits and Signals.
* sigsetmask: (libc)BSD Signal Handling.
* sigstack: (libc)Signal Stack.
* sigsuspend: (libc)Sigsuspend.
* sin: (libc)Trig Functions.
* sincos: (libc)Trig Functions.
* sincosf: (libc)Trig Functions.
* sincosfN: (libc)Trig Functions.
* sincosfNx: (libc)Trig Functions.
* sincosl: (libc)Trig Functions.
* sinf: (libc)Trig Functions.
* sinfN: (libc)Trig Functions.
* sinfNx: (libc)Trig Functions.
* sinh: (libc)Hyperbolic Functions.
* sinhf: (libc)Hyperbolic Functions.
* sinhfN: (libc)Hyperbolic Functions.
* sinhfNx: (libc)Hyperbolic Functions.
* sinhl: (libc)Hyperbolic Functions.
* sinl: (libc)Trig Functions.
* sleep: (libc)Sleeping.
* snprintf: (libc)Formatted Output Functions.
* socket: (libc)Creating a Socket.
* socketpair: (libc)Socket Pairs.
* sprintf: (libc)Formatted Output Functions.
* sqrt: (libc)Exponents and Logarithms.
* sqrtf: (libc)Exponents and Logarithms.
* sqrtfN: (libc)Exponents and Logarithms.
* sqrtfNx: (libc)Exponents and Logarithms.
* sqrtl: (libc)Exponents and Logarithms.
* srand48: (libc)SVID Random.
* srand48_r: (libc)SVID Random.
* srand: (libc)ISO Random.
* srandom: (libc)BSD Random.
* srandom_r: (libc)BSD Random.
* sscanf: (libc)Formatted Input Functions.
* ssignal: (libc)Basic Signal Handling.
* stat64: (libc)Reading Attributes.
* stat: (libc)Reading Attributes.
* stime: (libc)Simple Calendar Time.
* stpcpy: (libc)Copying Strings and Arrays.
* stpncpy: (libc)Truncating Strings.
* strcasecmp: (libc)String/Array Comparison.
* strcasestr: (libc)Search Functions.
* strcat: (libc)Concatenating Strings.
* strchr: (libc)Search Functions.
* strchrnul: (libc)Search Functions.
* strcmp: (libc)String/Array Comparison.
* strcoll: (libc)Collation Functions.
* strcpy: (libc)Copying Strings and Arrays.
* strcspn: (libc)Search Functions.
* strdup: (libc)Copying Strings and Arrays.
* strdupa: (libc)Copying Strings and Arrays.
* strerror: (libc)Error Messages.
* strerror_r: (libc)Error Messages.
* strfmon: (libc)Formatting Numbers.
* strfromd: (libc)Printing of Floats.
* strfromf: (libc)Printing of Floats.
* strfromfN: (libc)Printing of Floats.
* strfromfNx: (libc)Printing of Floats.
* strfroml: (libc)Printing of Floats.
* strfry: (libc)Shuffling Bytes.
* strftime: (libc)Formatting Calendar Time.
* strlen: (libc)String Length.
* strncasecmp: (libc)String/Array Comparison.
* strncat: (libc)Truncating Strings.
* strncmp: (libc)String/Array Comparison.
* strncpy: (libc)Truncating Strings.
* strndup: (libc)Truncating Strings.
* strndupa: (libc)Truncating Strings.
* strnlen: (libc)String Length.
* strpbrk: (libc)Search Functions.
* strptime: (libc)Low-Level Time String Parsing.
* strrchr: (libc)Search Functions.
* strsep: (libc)Finding Tokens in a String.
* strsignal: (libc)Signal Messages.
* strspn: (libc)Search Functions.
* strstr: (libc)Search Functions.
* strtod: (libc)Parsing of Floats.
* strtof: (libc)Parsing of Floats.
* strtofN: (libc)Parsing of Floats.
* strtofNx: (libc)Parsing of Floats.
* strtoimax: (libc)Parsing of Integers.
* strtok: (libc)Finding Tokens in a String.
* strtok_r: (libc)Finding Tokens in a String.
* strtol: (libc)Parsing of Integers.
* strtold: (libc)Parsing of Floats.
* strtoll: (libc)Parsing of Integers.
* strtoq: (libc)Parsing of Integers.
* strtoul: (libc)Parsing of Integers.
* strtoull: (libc)Parsing of Integers.
* strtoumax: (libc)Parsing of Integers.
* strtouq: (libc)Parsing of Integers.
* strverscmp: (libc)String/Array Comparison.
* strxfrm: (libc)Collation Functions.
* stty: (libc)BSD Terminal Modes.
* swapcontext: (libc)System V contexts.
* swprintf: (libc)Formatted Output Functions.
* swscanf: (libc)Formatted Input Functions.
* symlink: (libc)Symbolic Links.
* sync: (libc)Synchronizing I/O.
* syscall: (libc)System Calls.
* sysconf: (libc)Sysconf Definition.
* sysctl: (libc)System Parameters.
* syslog: (libc)syslog; vsyslog.
* system: (libc)Running a Command.
* sysv_signal: (libc)Basic Signal Handling.
* tan: (libc)Trig Functions.
* tanf: (libc)Trig Functions.
* tanfN: (libc)Trig Functions.
* tanfNx: (libc)Trig Functions.
* tanh: (libc)Hyperbolic Functions.
* tanhf: (libc)Hyperbolic Functions.
* tanhfN: (libc)Hyperbolic Functions.
* tanhfNx: (libc)Hyperbolic Functions.
* tanhl: (libc)Hyperbolic Functions.
* tanl: (libc)Trig Functions.
* tcdrain: (libc)Line Control.
* tcflow: (libc)Line Control.
* tcflush: (libc)Line Control.
* tcgetattr: (libc)Mode Functions.
* tcgetpgrp: (libc)Terminal Access Functions.
* tcgetsid: (libc)Terminal Access Functions.
* tcsendbreak: (libc)Line Control.
* tcsetattr: (libc)Mode Functions.
* tcsetpgrp: (libc)Terminal Access Functions.
* tdelete: (libc)Tree Search Function.
* tdestroy: (libc)Tree Search Function.
* telldir: (libc)Random Access Directory.
* tempnam: (libc)Temporary Files.
* textdomain: (libc)Locating gettext catalog.
* tfind: (libc)Tree Search Function.
* tgamma: (libc)Special Functions.
* tgammaf: (libc)Special Functions.
* tgammafN: (libc)Special Functions.
* tgammafNx: (libc)Special Functions.
* tgammal: (libc)Special Functions.
* tgkill: (libc)Signaling Another Process.
* thrd_create: (libc)ISO C Thread Management.
* thrd_current: (libc)ISO C Thread Management.
* thrd_detach: (libc)ISO C Thread Management.
* thrd_equal: (libc)ISO C Thread Management.
* thrd_exit: (libc)ISO C Thread Management.
* thrd_join: (libc)ISO C Thread Management.
* thrd_sleep: (libc)ISO C Thread Management.
* thrd_yield: (libc)ISO C Thread Management.
* time: (libc)Simple Calendar Time.
* timegm: (libc)Broken-down Time.
* timelocal: (libc)Broken-down Time.
* times: (libc)Processor Time.
* tmpfile64: (libc)Temporary Files.
* tmpfile: (libc)Temporary Files.
* tmpnam: (libc)Temporary Files.
* tmpnam_r: (libc)Temporary Files.
* toascii: (libc)Case Conversion.
* tolower: (libc)Case Conversion.
* totalorder: (libc)FP Comparison Functions.
* totalorderf: (libc)FP Comparison Functions.
* totalorderfN: (libc)FP Comparison Functions.
* totalorderfNx: (libc)FP Comparison Functions.
* totalorderl: (libc)FP Comparison Functions.
* totalordermag: (libc)FP Comparison Functions.
* totalordermagf: (libc)FP Comparison Functions.
* totalordermagfN: (libc)FP Comparison Functions.
* totalordermagfNx: (libc)FP Comparison Functions.
* totalordermagl: (libc)FP Comparison Functions.
* toupper: (libc)Case Conversion.
* towctrans: (libc)Wide Character Case Conversion.
* towlower: (libc)Wide Character Case Conversion.
* towupper: (libc)Wide Character Case Conversion.
* trunc: (libc)Rounding Functions.
* truncate64: (libc)File Size.
* truncate: (libc)File Size.
* truncf: (libc)Rounding Functions.
* truncfN: (libc)Rounding Functions.
* truncfNx: (libc)Rounding Functions.
* truncl: (libc)Rounding Functions.
* tsearch: (libc)Tree Search Function.
* tss_create: (libc)ISO C Thread-local Storage.
* tss_delete: (libc)ISO C Thread-local Storage.
* tss_get: (libc)ISO C Thread-local Storage.
* tss_set: (libc)ISO C Thread-local Storage.
* ttyname: (libc)Is It a Terminal.
* ttyname_r: (libc)Is It a Terminal.
* twalk: (libc)Tree Search Function.
* twalk_r: (libc)Tree Search Function.
* tzset: (libc)Time Zone Functions.
* ufromfp: (libc)Rounding Functions.
* ufromfpf: (libc)Rounding Functions.
* ufromfpfN: (libc)Rounding Functions.
* ufromfpfNx: (libc)Rounding Functions.
* ufromfpl: (libc)Rounding Functions.
* ufromfpx: (libc)Rounding Functions.
* ufromfpxf: (libc)Rounding Functions.
* ufromfpxfN: (libc)Rounding Functions.
* ufromfpxfNx: (libc)Rounding Functions.
* ufromfpxl: (libc)Rounding Functions.
* ulimit: (libc)Limits on Resources.
* umask: (libc)Setting Permissions.
* umount2: (libc)Mount-Unmount-Remount.
* umount: (libc)Mount-Unmount-Remount.
* uname: (libc)Platform Type.
* ungetc: (libc)How Unread.
* ungetwc: (libc)How Unread.
* unlink: (libc)Deleting Files.
* unlockpt: (libc)Allocation.
* unsetenv: (libc)Environment Access.
* updwtmp: (libc)Manipulating the Database.
* utime: (libc)File Times.
* utimes: (libc)File Times.
* utmpname: (libc)Manipulating the Database.
* utmpxname: (libc)XPG Functions.
* va_arg: (libc)Argument Macros.
* va_copy: (libc)Argument Macros.
* va_end: (libc)Argument Macros.
* va_start: (libc)Argument Macros.
* valloc: (libc)Aligned Memory Blocks.
* vasprintf: (libc)Variable Arguments Output.
* verr: (libc)Error Messages.
* verrx: (libc)Error Messages.
* versionsort64: (libc)Scanning Directory Content.
* versionsort: (libc)Scanning Directory Content.
* vfork: (libc)Creating a Process.
* vfprintf: (libc)Variable Arguments Output.
* vfscanf: (libc)Variable Arguments Input.
* vfwprintf: (libc)Variable Arguments Output.
* vfwscanf: (libc)Variable Arguments Input.
* vlimit: (libc)Limits on Resources.
* vprintf: (libc)Variable Arguments Output.
* vscanf: (libc)Variable Arguments Input.
* vsnprintf: (libc)Variable Arguments Output.
* vsprintf: (libc)Variable Arguments Output.
* vsscanf: (libc)Variable Arguments Input.
* vswprintf: (libc)Variable Arguments Output.
* vswscanf: (libc)Variable Arguments Input.
* vsyslog: (libc)syslog; vsyslog.
* vtimes: (libc)Resource Usage.
* vwarn: (libc)Error Messages.
* vwarnx: (libc)Error Messages.
* vwprintf: (libc)Variable Arguments Output.
* vwscanf: (libc)Variable Arguments Input.
* wait3: (libc)BSD Wait Functions.
* wait4: (libc)Process Completion.
* wait: (libc)Process Completion.
* waitpid: (libc)Process Completion.
* warn: (libc)Error Messages.
* warnx: (libc)Error Messages.
* wcpcpy: (libc)Copying Strings and Arrays.
* wcpncpy: (libc)Truncating Strings.
* wcrtomb: (libc)Converting a Character.
* wcscasecmp: (libc)String/Array Comparison.
* wcscat: (libc)Concatenating Strings.
* wcschr: (libc)Search Functions.
* wcschrnul: (libc)Search Functions.
* wcscmp: (libc)String/Array Comparison.
* wcscoll: (libc)Collation Functions.
* wcscpy: (libc)Copying Strings and Arrays.
* wcscspn: (libc)Search Functions.
* wcsdup: (libc)Copying Strings and Arrays.
* wcsftime: (libc)Formatting Calendar Time.
* wcslen: (libc)String Length.
* wcsncasecmp: (libc)String/Array Comparison.
* wcsncat: (libc)Truncating Strings.
* wcsncmp: (libc)String/Array Comparison.
* wcsncpy: (libc)Truncating Strings.
* wcsnlen: (libc)String Length.
* wcsnrtombs: (libc)Converting Strings.
* wcspbrk: (libc)Search Functions.
* wcsrchr: (libc)Search Functions.
* wcsrtombs: (libc)Converting Strings.
* wcsspn: (libc)Search Functions.
* wcsstr: (libc)Search Functions.
* wcstod: (libc)Parsing of Floats.
* wcstof: (libc)Parsing of Floats.
* wcstofN: (libc)Parsing of Floats.
* wcstofNx: (libc)Parsing of Floats.
* wcstoimax: (libc)Parsing of Integers.
* wcstok: (libc)Finding Tokens in a String.
* wcstol: (libc)Parsing of Integers.
* wcstold: (libc)Parsing of Floats.
* wcstoll: (libc)Parsing of Integers.
* wcstombs: (libc)Non-reentrant String Conversion.
* wcstoq: (libc)Parsing of Integers.
* wcstoul: (libc)Parsing of Integers.
* wcstoull: (libc)Parsing of Integers.
* wcstoumax: (libc)Parsing of Integers.
* wcstouq: (libc)Parsing of Integers.
* wcswcs: (libc)Search Functions.
* wcsxfrm: (libc)Collation Functions.
* wctob: (libc)Converting a Character.
* wctomb: (libc)Non-reentrant Character Conversion.
* wctrans: (libc)Wide Character Case Conversion.
* wctype: (libc)Classification of Wide Characters.
* wmemchr: (libc)Search Functions.
* wmemcmp: (libc)String/Array Comparison.
* wmemcpy: (libc)Copying Strings and Arrays.
* wmemmove: (libc)Copying Strings and Arrays.
* wmempcpy: (libc)Copying Strings and Arrays.
* wmemset: (libc)Copying Strings and Arrays.
* wordexp: (libc)Calling Wordexp.
* wordfree: (libc)Calling Wordexp.
* wprintf: (libc)Formatted Output Functions.
* write: (libc)I/O Primitives.
* writev: (libc)Scatter-Gather.
* wscanf: (libc)Formatted Input Functions.
* y0: (libc)Special Functions.
* y0f: (libc)Special Functions.
* y0fN: (libc)Special Functions.
* y0fNx: (libc)Special Functions.
* y0l: (libc)Special Functions.
* y1: (libc)Special Functions.
* y1f: (libc)Special Functions.
* y1fN: (libc)Special Functions.
* y1fNx: (libc)Special Functions.
* y1l: (libc)Special Functions.
* yn: (libc)Special Functions.
* ynf: (libc)Special Functions.
* ynfN: (libc)Special Functions.
* ynfNx: (libc)Special Functions.
* ynl: (libc)Special Functions.
END-INFO-DIR-ENTRY


File: libc.info,  Node: Examples of Sysconf,  Prev: Constants for Sysconf,  Up: Sysconf

32.4.3 Examples of ‘sysconf’
----------------------------

We recommend that you first test for a macro definition for the
parameter you are interested in, and call ‘sysconf’ only if the macro is
not defined.  For example, here is how to test whether job control is
supported:

     int
     have_job_control (void)
     {
     #ifdef _POSIX_JOB_CONTROL
       return 1;
     #else
       int value = sysconf (_SC_JOB_CONTROL);
       if (value < 0)
         /* If the system is that badly wedged,
            there’s no use trying to go on.  */
         fatal (strerror (errno));
       return value;
     #endif
     }

   Here is how to get the value of a numeric limit:

     int
     get_child_max ()
     {
     #ifdef CHILD_MAX
       return CHILD_MAX;
     #else
       int value = sysconf (_SC_CHILD_MAX);
       if (value < 0)
         fatal (strerror (errno));
       return value;
     #endif
     }


File: libc.info,  Node: Minimums,  Next: Limits for Files,  Prev: Sysconf,  Up: System Configuration

32.5 Minimum Values for General Capacity Limits
===============================================

Here are the names for the POSIX minimum upper bounds for the system
limit parameters.  The significance of these values is that you can
safely push to these limits without checking whether the particular
system you are using can go that far.

‘_POSIX_AIO_LISTIO_MAX’

     The most restrictive limit permitted by POSIX for the maximum
     number of I/O operations that can be specified in a list I/O call.
     The value of this constant is ‘2’; thus you can add up to two new
     entries of the list of outstanding operations.

‘_POSIX_AIO_MAX’

     The most restrictive limit permitted by POSIX for the maximum
     number of outstanding asynchronous I/O operations.  The value of
     this constant is ‘1’.  So you cannot expect that you can issue more
     than one operation and immediately continue with the normal work,
     receiving the notifications asynchronously.

‘_POSIX_ARG_MAX’

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum combined length of the ARGV and ENVIRON
     arguments that can be passed to the ‘exec’ functions.  Its value is
     ‘4096’.

‘_POSIX_CHILD_MAX’

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum number of simultaneous processes per real
     user ID. Its value is ‘6’.

‘_POSIX_NGROUPS_MAX’

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum number of supplementary group IDs per
     process.  Its value is ‘0’.

‘_POSIX_OPEN_MAX’

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum number of files that a single process can
     have open simultaneously.  Its value is ‘16’.

‘_POSIX_SSIZE_MAX’

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum value that can be stored in an object of type
     ‘ssize_t’.  Its value is ‘32767’.

‘_POSIX_STREAM_MAX’

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum number of streams that a single process can
     have open simultaneously.  Its value is ‘8’.

‘_POSIX_TZNAME_MAX’

     The value of this macro is the most restrictive limit permitted by
     POSIX for the maximum length of a time zone name.  Its value is
     ‘3’.

‘_POSIX2_RE_DUP_MAX’

     The value of this macro is the most restrictive limit permitted by
     POSIX for the numbers used in the ‘\{MIN,MAX\}’ construct in a
     regular expression.  Its value is ‘255’.


File: libc.info,  Node: Limits for Files,  Next: Options for Files,  Prev: Minimums,  Up: System Configuration

32.6 Limits on File System Capacity
===================================

The POSIX.1 standard specifies a number of parameters that describe the
limitations of the file system.  It’s possible for the system to have a
fixed, uniform limit for a parameter, but this isn’t the usual case.  On
most systems, it’s possible for different file systems (and, for some
parameters, even different files) to have different maximum limits.  For
example, this is very likely if you use NFS to mount some of the file
systems from other machines.

   Each of the following macros is defined in ‘limits.h’ only if the
system has a fixed, uniform limit for the parameter in question.  If the
system allows different file systems or files to have different limits,
then the macro is undefined; use ‘pathconf’ or ‘fpathconf’ to find out
the limit that applies to a particular file.  *Note Pathconf::.

   Each parameter also has another macro, with a name starting with
‘_POSIX’, which gives the lowest value that the limit is allowed to have
on _any_ POSIX system.  *Note File Minimums::.

 -- Macro: int LINK_MAX

     The uniform system limit (if any) for the number of names for a
     given file.  *Note Hard Links::.

 -- Macro: int MAX_CANON

     The uniform system limit (if any) for the amount of text in a line
     of input when input editing is enabled.  *Note Canonical or Not::.

 -- Macro: int MAX_INPUT

     The uniform system limit (if any) for the total number of
     characters typed ahead as input.  *Note I/O Queues::.

 -- Macro: int NAME_MAX

     The uniform system limit (if any) for the length of a file name
     component, not including the terminating null character.

     *Portability Note:* On some systems, the GNU C Library defines
     ‘NAME_MAX’, but does not actually enforce this limit.

 -- Macro: int PATH_MAX

     The uniform system limit (if any) for the length of an entire file
     name (that is, the argument given to system calls such as ‘open’),
     including the terminating null character.

     *Portability Note:* The GNU C Library does not enforce this limit
     even if ‘PATH_MAX’ is defined.

 -- Macro: int PIPE_BUF

     The uniform system limit (if any) for the number of bytes that can
     be written atomically to a pipe.  If multiple processes are writing
     to the same pipe simultaneously, output from different processes
     might be interleaved in chunks of this size.  *Note Pipes and
     FIFOs::.

   These are alternative macro names for some of the same information.

 -- Macro: int MAXNAMLEN

     This is the BSD name for ‘NAME_MAX’.  It is defined in ‘dirent.h’.

 -- Macro: int FILENAME_MAX

     The value of this macro is an integer constant expression that
     represents the maximum length of a file name string.  It is defined
     in ‘stdio.h’.

     Unlike ‘PATH_MAX’, this macro is defined even if there is no actual
     limit imposed.  In such a case, its value is typically a very large
     number.  *This is always the case on GNU/Hurd systems.*

     *Usage Note:* Don’t use ‘FILENAME_MAX’ as the size of an array in
     which to store a file name!  You can’t possibly make an array that
     big!  Use dynamic allocation (*note Memory Allocation::) instead.


File: libc.info,  Node: Options for Files,  Next: File Minimums,  Prev: Limits for Files,  Up: System Configuration

32.7 Optional Features in File Support
======================================

POSIX defines certain system-specific options in the system calls for
operating on files.  Some systems support these options and others do
not.  Since these options are provided in the kernel, not in the
library, simply using the GNU C Library does not guarantee that any of
these features is supported; it depends on the system you are using.
They can also vary between file systems on a single machine.

   This section describes the macros you can test to determine whether a
particular option is supported on your machine.  If a given macro is
defined in ‘unistd.h’, then its value says whether the corresponding
feature is supported.  (A value of ‘-1’ indicates no; any other value
indicates yes.)  If the macro is undefined, it means particular files
may or may not support the feature.

   Since all the machines that support the GNU C Library also support
NFS, one can never make a general statement about whether all file
systems support the ‘_POSIX_CHOWN_RESTRICTED’ and ‘_POSIX_NO_TRUNC’
features.  So these names are never defined as macros in the GNU C
Library.

 -- Macro: int _POSIX_CHOWN_RESTRICTED

     If this option is in effect, the ‘chown’ function is restricted so
     that the only changes permitted to nonprivileged processes is to
     change the group owner of a file to either be the effective group
     ID of the process, or one of its supplementary group IDs.  *Note
     File Owner::.

 -- Macro: int _POSIX_NO_TRUNC

     If this option is in effect, file name components longer than
     ‘NAME_MAX’ generate an ‘ENAMETOOLONG’ error.  Otherwise, file name
     components that are too long are silently truncated.

 -- Macro: unsigned char _POSIX_VDISABLE

     This option is only meaningful for files that are terminal devices.
     If it is enabled, then handling for special control characters can
     be disabled individually.  *Note Special Characters::.

   If one of these macros is undefined, that means that the option might
be in effect for some files and not for others.  To inquire about a
particular file, call ‘pathconf’ or ‘fpathconf’.  *Note Pathconf::.


File: libc.info,  Node: File Minimums,  Next: Pathconf,  Prev: Options for Files,  Up: System Configuration

32.8 Minimum Values for File System Limits
==========================================

Here are the names for the POSIX minimum upper bounds for some of the
above parameters.  The significance of these values is that you can
safely push to these limits without checking whether the particular
system you are using can go that far.  In most cases GNU systems do not
have these strict limitations.  The actual limit should be requested if
necessary.

‘_POSIX_LINK_MAX’

     The most restrictive limit permitted by POSIX for the maximum value
     of a file’s link count.  The value of this constant is ‘8’; thus,
     you can always make up to eight names for a file without running
     into a system limit.

‘_POSIX_MAX_CANON’

     The most restrictive limit permitted by POSIX for the maximum
     number of bytes in a canonical input line from a terminal device.
     The value of this constant is ‘255’.

‘_POSIX_MAX_INPUT’

     The most restrictive limit permitted by POSIX for the maximum
     number of bytes in a terminal device input queue (or typeahead
     buffer).  *Note Input Modes::.  The value of this constant is
     ‘255’.

‘_POSIX_NAME_MAX’

     The most restrictive limit permitted by POSIX for the maximum
     number of bytes in a file name component.  The value of this
     constant is ‘14’.

‘_POSIX_PATH_MAX’

     The most restrictive limit permitted by POSIX for the maximum
     number of bytes in a file name.  The value of this constant is
     ‘256’.

‘_POSIX_PIPE_BUF’

     The most restrictive limit permitted by POSIX for the maximum
     number of bytes that can be written atomically to a pipe.  The
     value of this constant is ‘512’.

‘SYMLINK_MAX’

     Maximum number of bytes in a symbolic link.

‘POSIX_REC_INCR_XFER_SIZE’

     Recommended increment for file transfer sizes between the
     ‘POSIX_REC_MIN_XFER_SIZE’ and ‘POSIX_REC_MAX_XFER_SIZE’ values.

‘POSIX_REC_MAX_XFER_SIZE’

     Maximum recommended file transfer size.

‘POSIX_REC_MIN_XFER_SIZE’

     Minimum recommended file transfer size.

‘POSIX_REC_XFER_ALIGN’

     Recommended file transfer buffer alignment.


File: libc.info,  Node: Pathconf,  Next: Utility Limits,  Prev: File Minimums,  Up: System Configuration

32.9 Using ‘pathconf’
=====================

When your machine allows different files to have different values for a
file system parameter, you can use the functions in this section to find
out the value that applies to any particular file.

   These functions and the associated constants for the PARAMETER
argument are declared in the header file ‘unistd.h’.

 -- Function: long int pathconf (const char *FILENAME, int PARAMETER)

     Preliminary: | MT-Safe | AS-Unsafe lock heap | AC-Unsafe lock fd
     mem | *Note POSIX Safety Concepts::.

     This function is used to inquire about the limits that apply to the
     file named FILENAME.

     The PARAMETER argument should be one of the ‘_PC_’ constants listed
     below.

     The normal return value from ‘pathconf’ is the value you requested.
     A value of ‘-1’ is returned both if the implementation does not
     impose a limit, and in case of an error.  In the former case,
     ‘errno’ is not set, while in the latter case, ‘errno’ is set to
     indicate the cause of the problem.  So the only way to use this
     function robustly is to store ‘0’ into ‘errno’ just before calling
     it.

     Besides the usual file name errors (*note File Name Errors::), the
     following error condition is defined for this function:

     ‘EINVAL’
          The value of PARAMETER is invalid, or the implementation
          doesn’t support the PARAMETER for the specific file.

 -- Function: long int fpathconf (int FILEDES, int PARAMETER)

     Preliminary: | MT-Safe | AS-Unsafe lock heap | AC-Unsafe lock fd
     mem | *Note POSIX Safety Concepts::.

     This is just like ‘pathconf’ except that an open file descriptor is
     used to specify the file for which information is requested,
     instead of a file name.

     The following ‘errno’ error conditions are defined for this
     function:

     ‘EBADF’
          The FILEDES argument is not a valid file descriptor.

     ‘EINVAL’
          The value of PARAMETER is invalid, or the implementation
          doesn’t support the PARAMETER for the specific file.

   Here are the symbolic constants that you can use as the PARAMETER
argument to ‘pathconf’ and ‘fpathconf’.  The values are all integer
constants.

‘_PC_LINK_MAX’

     Inquire about the value of ‘LINK_MAX’.

‘_PC_MAX_CANON’

     Inquire about the value of ‘MAX_CANON’.

‘_PC_MAX_INPUT’

     Inquire about the value of ‘MAX_INPUT’.

‘_PC_NAME_MAX’

     Inquire about the value of ‘NAME_MAX’.

‘_PC_PATH_MAX’

     Inquire about the value of ‘PATH_MAX’.

‘_PC_PIPE_BUF’

     Inquire about the value of ‘PIPE_BUF’.

‘_PC_CHOWN_RESTRICTED’

     Inquire about the value of ‘_POSIX_CHOWN_RESTRICTED’.

‘_PC_NO_TRUNC’

     Inquire about the value of ‘_POSIX_NO_TRUNC’.

‘_PC_VDISABLE’

     Inquire about the value of ‘_POSIX_VDISABLE’.

‘_PC_SYNC_IO’

     Inquire about the value of ‘_POSIX_SYNC_IO’.

‘_PC_ASYNC_IO’

     Inquire about the value of ‘_POSIX_ASYNC_IO’.

‘_PC_PRIO_IO’

     Inquire about the value of ‘_POSIX_PRIO_IO’.

‘_PC_FILESIZEBITS’

     Inquire about the availability of large files on the filesystem.

‘_PC_REC_INCR_XFER_SIZE’

     Inquire about the value of ‘POSIX_REC_INCR_XFER_SIZE’.

‘_PC_REC_MAX_XFER_SIZE’

     Inquire about the value of ‘POSIX_REC_MAX_XFER_SIZE’.

‘_PC_REC_MIN_XFER_SIZE’

     Inquire about the value of ‘POSIX_REC_MIN_XFER_SIZE’.

‘_PC_REC_XFER_ALIGN’

     Inquire about the value of ‘POSIX_REC_XFER_ALIGN’.

   *Portability Note:* On some systems, the GNU C Library does not
enforce ‘_PC_NAME_MAX’ or ‘_PC_PATH_MAX’ limits.


File: libc.info,  Node: Utility Limits,  Next: Utility Minimums,  Prev: Pathconf,  Up: System Configuration

32.10 Utility Program Capacity Limits
=====================================

The POSIX.2 standard specifies certain system limits that you can access
through ‘sysconf’ that apply to utility behavior rather than the
behavior of the library or the operating system.

   The GNU C Library defines macros for these limits, and ‘sysconf’
returns values for them if you ask; but these values convey no
meaningful information.  They are simply the smallest values that
POSIX.2 permits.

 -- Macro: int BC_BASE_MAX

     The largest value of ‘obase’ that the ‘bc’ utility is guaranteed to
     support.

 -- Macro: int BC_DIM_MAX

     The largest number of elements in one array that the ‘bc’ utility
     is guaranteed to support.

 -- Macro: int BC_SCALE_MAX

     The largest value of ‘scale’ that the ‘bc’ utility is guaranteed to
     support.

 -- Macro: int BC_STRING_MAX

     The largest number of characters in one string constant that the
     ‘bc’ utility is guaranteed to support.

 -- Macro: int COLL_WEIGHTS_MAX

     The largest number of weights that can necessarily be used in
     defining the collating sequence for a locale.

 -- Macro: int EXPR_NEST_MAX

     The maximum number of expressions that can be nested within
     parentheses by the ‘expr’ utility.

 -- Macro: int LINE_MAX

     The largest text line that the text-oriented POSIX.2 utilities can
     support.  (If you are using the GNU versions of these utilities,
     then there is no actual limit except that imposed by the available
     virtual memory, but there is no way that the library can tell you
     this.)

 -- Macro: int EQUIV_CLASS_MAX

     The maximum number of weights that can be assigned to an entry of
     the ‘LC_COLLATE’ category ‘order’ keyword in a locale definition.
     The GNU C Library does not presently support locale definitions.


File: libc.info,  Node: Utility Minimums,  Next: String Parameters,  Prev: Utility Limits,  Up: System Configuration

32.11 Minimum Values for Utility Limits
=======================================

‘_POSIX2_BC_BASE_MAX’

     The most restrictive limit permitted by POSIX.2 for the maximum
     value of ‘obase’ in the ‘bc’ utility.  Its value is ‘99’.

‘_POSIX2_BC_DIM_MAX’

     The most restrictive limit permitted by POSIX.2 for the maximum
     size of an array in the ‘bc’ utility.  Its value is ‘2048’.

‘_POSIX2_BC_SCALE_MAX’

     The most restrictive limit permitted by POSIX.2 for the maximum
     value of ‘scale’ in the ‘bc’ utility.  Its value is ‘99’.

‘_POSIX2_BC_STRING_MAX’

     The most restrictive limit permitted by POSIX.2 for the maximum
     size of a string constant in the ‘bc’ utility.  Its value is
     ‘1000’.

‘_POSIX2_COLL_WEIGHTS_MAX’

     The most restrictive limit permitted by POSIX.2 for the maximum
     number of weights that can necessarily be used in defining the
     collating sequence for a locale.  Its value is ‘2’.

‘_POSIX2_EXPR_NEST_MAX’

     The most restrictive limit permitted by POSIX.2 for the maximum
     number of expressions nested within parenthesis when using the
     ‘expr’ utility.  Its value is ‘32’.

‘_POSIX2_LINE_MAX’

     The most restrictive limit permitted by POSIX.2 for the maximum
     size of a text line that the text utilities can handle.  Its value
     is ‘2048’.

‘_POSIX2_EQUIV_CLASS_MAX’

     The most restrictive limit permitted by POSIX.2 for the maximum
     number of weights that can be assigned to an entry of the
     ‘LC_COLLATE’ category ‘order’ keyword in a locale definition.  Its
     value is ‘2’.  The GNU C Library does not presently support locale
     definitions.


File: libc.info,  Node: String Parameters,  Prev: Utility Minimums,  Up: System Configuration

32.12 String-Valued Parameters
==============================

POSIX.2 defines a way to get string-valued parameters from the operating
system with the function ‘confstr’:

 -- Function: size_t confstr (int PARAMETER, char *BUF, size_t LEN)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function reads the value of a string-valued system parameter,
     storing the string into LEN bytes of memory space starting at BUF.
     The PARAMETER argument should be one of the ‘_CS_’ symbols listed
     below.

     The normal return value from ‘confstr’ is the length of the string
     value that you asked for.  If you supply a null pointer for BUF,
     then ‘confstr’ does not try to store the string; it just returns
     its length.  A value of ‘0’ indicates an error.

     If the string you asked for is too long for the buffer (that is,
     longer than ‘LEN - 1’), then ‘confstr’ stores just that much
     (leaving room for the terminating null character).  You can tell
     that this has happened because ‘confstr’ returns a value greater
     than or equal to LEN.

     The following ‘errno’ error conditions are defined for this
     function:

     ‘EINVAL’
          The value of the PARAMETER is invalid.

   Currently there is just one parameter you can read with ‘confstr’:

‘_CS_PATH’

     This parameter’s value is the recommended default path for
     searching for executable files.  This is the path that a user has
     by default just after logging in.

‘_CS_LFS_CFLAGS’

     The returned string specifies which additional flags must be given
     to the C compiler if a source is compiled using the
     ‘_LARGEFILE_SOURCE’ feature select macro; *note Feature Test
     Macros::.

‘_CS_LFS_LDFLAGS’

     The returned string specifies which additional flags must be given
     to the linker if a source is compiled using the ‘_LARGEFILE_SOURCE’
     feature select macro; *note Feature Test Macros::.

‘_CS_LFS_LIBS’

     The returned string specifies which additional libraries must be
     linked to the application if a source is compiled using the
     ‘_LARGEFILE_SOURCE’ feature select macro; *note Feature Test
     Macros::.

‘_CS_LFS_LINTFLAGS’

     The returned string specifies which additional flags must be given
     to the lint tool if a source is compiled using the
     ‘_LARGEFILE_SOURCE’ feature select macro; *note Feature Test
     Macros::.

‘_CS_LFS64_CFLAGS’

     The returned string specifies which additional flags must be given
     to the C compiler if a source is compiled using the
     ‘_LARGEFILE64_SOURCE’ feature select macro; *note Feature Test
     Macros::.

‘_CS_LFS64_LDFLAGS’

     The returned string specifies which additional flags must be given
     to the linker if a source is compiled using the
     ‘_LARGEFILE64_SOURCE’ feature select macro; *note Feature Test
     Macros::.

‘_CS_LFS64_LIBS’

     The returned string specifies which additional libraries must be
     linked to the application if a source is compiled using the
     ‘_LARGEFILE64_SOURCE’ feature select macro; *note Feature Test
     Macros::.

‘_CS_LFS64_LINTFLAGS’

     The returned string specifies which additional flags must be given
     to the lint tool if a source is compiled using the
     ‘_LARGEFILE64_SOURCE’ feature select macro; *note Feature Test
     Macros::.

   The way to use ‘confstr’ without any arbitrary limit on string size
is to call it twice: first call it to get the length, allocate the
buffer accordingly, and then call ‘confstr’ again to fill the buffer,
like this:

     char *
     get_default_path (void)
     {
       size_t len = confstr (_CS_PATH, NULL, 0);
       char *buffer = (char *) xmalloc (len);

       if (confstr (_CS_PATH, buf, len + 1) == 0)
         {
           free (buffer);
           return NULL;
         }

       return buffer;
     }


File: libc.info,  Node: Cryptographic Functions,  Next: Debugging Support,  Prev: System Configuration,  Up: Top

33 Cryptographic Functions
**************************

The GNU C Library includes only a few special-purpose cryptographic
functions: one-way hash functions for passphrase storage, and access to
a cryptographic randomness source, if one is provided by the operating
system.  Programs that need general-purpose cryptography should use a
dedicated cryptography library, such as libgcrypt.

   Many countries place legal restrictions on the import, export,
possession, or use of cryptographic software.  We deplore these
restrictions, but we must still warn you that the GNU C Library may be
subject to them, even if you do not use the functions in this chapter
yourself.  The restrictions vary from place to place and are changed
often, so we cannot give any more specific advice than this warning.

* Menu:

* Passphrase Storage::          One-way hashing for passphrases.
* Unpredictable Bytes::         Randomness for cryptographic purposes.


File: libc.info,  Node: Passphrase Storage,  Next: Unpredictable Bytes,  Up: Cryptographic Functions

33.1 Passphrase Storage
=======================

Sometimes it is necessary to be sure that a user is authorized to use
some service a machine provides—for instance, to log in as a particular
user id (*note Users and Groups::).  One traditional way of doing this
is for each user to choose a secret "passphrase"; then, the system can
ask someone claiming to be a user what the user’s passphrase is, and if
the person gives the correct passphrase then the system can grant the
appropriate privileges.  (Traditionally, these were called “passwords,”
but nowadays a single word is too easy to guess.)

   Programs that handle passphrases must take special care not to reveal
them to anyone, no matter what.  It is not enough to keep them in a file
that is only accessible with special privileges.  The file might be
“leaked” via a bug or misconfiguration, and system administrators
shouldn’t learn everyone’s passphrase even if they have to edit that
file for some reason.  To avoid this, passphrases should also be
converted into "one-way hashes", using a "one-way function", before they
are stored.

   A one-way function is easy to compute, but there is no known way to
compute its inverse.  This means the system can easily check
passphrases, by hashing them and comparing the result with the stored
hash.  But an attacker who discovers someone’s passphrase hash can only
discover the passphrase it corresponds to by guessing and checking.  The
one-way functions are designed to make this process impractically slow,
for all but the most obvious guesses.  (Do not use a word from the
dictionary as your passphrase.)

   The GNU C Library provides an interface to four one-way functions,
based on the SHA-2-512, SHA-2-256, MD5, and DES cryptographic
primitives.  New passphrases should be hashed with either of the
SHA-based functions.  The others are too weak for newly set passphrases,
but we continue to support them for verifying old passphrases.  The
DES-based hash is especially weak, because it ignores all but the first
eight characters of its input.

 -- Function: char * crypt (const char *PHRASE, const char *SALT)

     Preliminary: | MT-Unsafe race:crypt | AS-Unsafe corrupt lock heap
     dlopen | AC-Unsafe lock mem | *Note POSIX Safety Concepts::.

     The function ‘crypt’ converts a passphrase string, PHRASE, into a
     one-way hash suitable for storage in the user database.  The string
     that it returns will consist entirely of printable ASCII
     characters.  It will not contain whitespace, nor any of the
     characters ‘:’, ‘;’, ‘*’, ‘!’, or ‘\’.

     The SALT parameter controls which one-way function is used, and it
     also ensures that the output of the one-way function is different
     for every user, even if they have the same passphrase.  This makes
     it harder to guess passphrases from a large user database.  Without
     salt, the attacker could make a guess, run ‘crypt’ on it once, and
     compare the result with all the hashes.  Salt forces the attacker
     to make separate calls to ‘crypt’ for each user.

     To verify a passphrase, pass the previously hashed passphrase as
     the SALT.  To hash a new passphrase for storage, set SALT to a
     string consisting of a prefix plus a sequence of randomly chosen
     characters, according to this table:

     One-way        Prefix  Random sequence
     function
     ----------------------------------------------
     SHA-2-512      ‘$6$’   16 characters
     SHA-2-256      ‘$5$’   16 characters
     MD5            ‘$1$’   8 characters
     DES            ‘’      2 characters

     In all cases, the random characters should be chosen from the
     alphabet ‘./0-9A-Za-z’.

     With all of the hash functions _except_ DES, PHRASE can be
     arbitrarily long, and all eight bits of each byte are significant.
     With DES, only the first eight characters of PHRASE affect the
     output, and the eighth bit of each byte is also ignored.

     ‘crypt’ can fail.  Some implementations return ‘NULL’ on failure,
     and others return an _invalid_ hashed passphrase, which will begin
     with a ‘*’ and will not be the same as SALT.  In either case,
     ‘errno’ will be set to indicate the problem.  Some of the possible
     error codes are:

     ‘EINVAL’
          SALT is invalid; neither a previously hashed passphrase, nor a
          well-formed new salt for any of the supported hash functions.

     ‘EPERM’
          The system configuration forbids use of the hash function
          selected by SALT.

     ‘ENOMEM’
          Failed to allocate internal scratch storage.

     ‘ENOSYS’
     ‘EOPNOTSUPP’
          Hashing passphrases is not supported at all, or the hash
          function selected by SALT is not supported.  The GNU C Library
          does not use these error codes, but they may be encountered on
          other operating systems.

     ‘crypt’ uses static storage for both internal scratchwork and the
     string it returns.  It is not safe to call ‘crypt’ from multiple
     threads simultaneously, and the string it returns will be
     overwritten by any subsequent call to ‘crypt’.

     ‘crypt’ is specified in the X/Open Portability Guide and is present
     on nearly all historical Unix systems.  However, the XPG does not
     specify any one-way functions.

     ‘crypt’ is declared in ‘unistd.h’.  The GNU C Library also declares
     this function in ‘crypt.h’.

 -- Function: char * crypt_r (const char *PHRASE, const char *SALT,
          struct crypt_data *DATA)

     Preliminary: | MT-Safe | AS-Unsafe corrupt lock heap dlopen |
     AC-Unsafe lock mem | *Note POSIX Safety Concepts::.

     The function ‘crypt_r’ is a thread-safe version of ‘crypt’.
     Instead of static storage, it uses the memory pointed to by its
     DATA argument for both scratchwork and the string it returns.  It
     can safely be used from multiple threads, as long as different DATA
     objects are used in each thread.  The string it returns will still
     be overwritten by another call with the same DATA.

     DATA must point to a ‘struct crypt_data’ object allocated by the
     caller.  All of the fields of ‘struct crypt_data’ are private, but
     before one of these objects is used for the first time, it must be
     initialized to all zeroes, using ‘memset’ or similar.  After that,
     it can be reused for many calls to ‘crypt_r’ without erasing it
     again.  ‘struct crypt_data’ is very large, so it is best to
     allocate it with ‘malloc’ rather than as a local variable.  *Note
     Memory Allocation::.

     ‘crypt_r’ is a GNU extension.  It is declared in ‘crypt.h’, as is
     ‘struct crypt_data’.

   The following program shows how to use ‘crypt’ the first time a
passphrase is entered.  It uses ‘getentropy’ to make the salt as
unpredictable as possible; *note Unpredictable Bytes::.


     #include <stdio.h>
     #include <unistd.h>
     #include <crypt.h>

     int
     main(void)
     {
       unsigned char ubytes[16];
       char salt[20];
       const char *const saltchars =
         "./0123456789ABCDEFGHIJKLMNOPQRST"
         "UVWXYZabcdefghijklmnopqrstuvwxyz";
       char *hash;
       int i;

       /* Retrieve 16 unpredictable bytes from the operating system. */
       if (getentropy (ubytes, sizeof ubytes))
         {
           perror ("getentropy");
           return 1;
         }

       /* Use them to fill in the salt string. */
       salt[0] = '$';
       salt[1] = '5'; /* SHA-256 */
       salt[2] = '$';
       for (i = 0; i < 16; i++)
         salt[3+i] = saltchars[ubytes[i] & 0x3f];
       salt[3+i] = '\0';

       /* Read in the user’s passphrase and hash it. */
       hash = crypt (getpass ("Enter new passphrase: "), salt);
       if (!hash || hash[0] == '*')
         {
           perror ("crypt");
           return 1;
         }

       /* Print the results. */
       puts (hash);
       return 0;
     }

   The next program demonstrates how to verify a passphrase.  It checks
a hash hardcoded into the program, because looking up real users’ hashed
passphrases may require special privileges (*note User Database::).  It
also shows that different one-way functions produce different hashes for
the same passphrase.


     #include <stdio.h>
     #include <string.h>
     #include <unistd.h>
     #include <crypt.h>

     /* ‘GNU's Not Unix’ hashed using SHA-256, MD5, and DES. */
     static const char hash_sha[] =
       "$5$DQ2z5NHf1jNJnChB$kV3ZTR0aUaosujPhLzR84Llo3BsspNSe4/tsp7VoEn6";
     static const char hash_md5[] = "$1$A3TxDv41$rtXVTUXl2LkeSV0UU5xxs1";
     static const char hash_des[] = "FgkTuF98w5DaI";

     int
     main(void)
     {
       char *phrase;
       int status = 0;

       /* Prompt for a passphrase. */
       phrase = getpass ("Enter passphrase: ");

       /* Compare against the stored hashes.  Any input that begins with
          ‘GNU's No’ will match the DES hash, but the other two will
          only match ‘GNU's Not Unix’. */

       if (strcmp (crypt (phrase, hash_sha), hash_sha))
         {
           puts ("SHA: not ok");
           status = 1;
         }
       else
         puts ("SHA: ok");

       if (strcmp (crypt (phrase, hash_md5), hash_md5))
         {
           puts ("MD5: not ok");
           status = 1;
         }
       else
         puts ("MD5: ok");

       if (strcmp (crypt (phrase, hash_des), hash_des))
         {
           puts ("DES: not ok");
           status = 1;
         }
       else
         puts ("DES: ok");

       return status;
     }


File: libc.info,  Node: Unpredictable Bytes,  Prev: Passphrase Storage,  Up: Cryptographic Functions

33.2 Generating Unpredictable Bytes
===================================

Cryptographic applications often need some random data that will be as
difficult as possible for a hostile eavesdropper to guess.  For
instance, encryption keys should be chosen at random, and the “salt”
strings used by ‘crypt’ (*note Passphrase Storage::) should also be
chosen at random.

   Some pseudo-random number generators do not provide
unpredictable-enough output for cryptographic applications; *note
Pseudo-Random Numbers::.  Such applications need to use a "cryptographic
random number generator" (CRNG), also sometimes called a
"cryptographically strong pseudo-random number generator" (CSPRNG) or
"deterministic random bit generator" (DRBG).

   Currently, the GNU C Library does not provide a cryptographic random
number generator, but it does provide functions that read random data
from a "randomness source" supplied by the operating system.  The
randomness source is a CRNG at heart, but it also continually “re-seeds”
itself from physical sources of randomness, such as electronic noise and
clock jitter.  This means applications do not need to do anything to
ensure that the random numbers it produces are different on each run.

   The catch, however, is that these functions will only produce
relatively short random strings in any one call.  Often this is not a
problem, but applications that need more than a few kilobytes of
cryptographically strong random data should call these functions once
and use their output to seed a CRNG.

   Most applications should use ‘getentropy’.  The ‘getrandom’ function
is intended for low-level applications which need additional control
over blocking behavior.

 -- Function: int getentropy (void *BUFFER, size_t LENGTH)

     | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety Concepts::.

     This function writes exactly LENGTH bytes of random data to the
     array starting at BUFFER.  LENGTH can be no more than 256.  On
     success, it returns zero.  On failure, it returns -1, and ‘errno’
     is set to indicate the problem.  Some of the possible errors are
     listed below.

     ‘ENOSYS’
          The operating system does not implement a randomness source,
          or does not support this way of accessing it.  (For instance,
          the system call used by this function was added to the Linux
          kernel in version 3.17.)

     ‘EFAULT’
          The combination of BUFFER and LENGTH arguments specifies an
          invalid memory range.

     ‘EIO’
          LENGTH is larger than 256, or the kernel entropy pool has
          suffered a catastrophic failure.

     A call to ‘getentropy’ can only block when the system has just
     booted and the randomness source has not yet been initialized.
     However, if it does block, it cannot be interrupted by signals or
     thread cancellation.  Programs intended to run in very early stages
     of the boot process may need to use ‘getrandom’ in non-blocking
     mode instead, and be prepared to cope with random data not being
     available at all.

     The ‘getentropy’ function is declared in the header file
     ‘sys/random.h’.  It is derived from OpenBSD.

 -- Function: ssize_t getrandom (void *BUFFER, size_t LENGTH, unsigned
          int FLAGS)

     | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety Concepts::.

     This function writes up to LENGTH bytes of random data to the array
     starting at BUFFER.  The FLAGS argument should be either zero, or
     the bitwise OR of some of the following flags:

     ‘GRND_RANDOM’
          Use the ‘/dev/random’ (blocking) source instead of the
          ‘/dev/urandom’ (non-blocking) source to obtain randomness.

          If this flag is specified, the call may block, potentially for
          quite some time, even after the randomness source has been
          initialized.  If it is not specified, the call can only block
          when the system has just booted and the randomness source has
          not yet been initialized.

     ‘GRND_NONBLOCK’
          Instead of blocking, return to the caller immediately if no
          data is available.

     Unlike ‘getentropy’, the ‘getrandom’ function is a cancellation
     point, and if it blocks, it can be interrupted by signals.

     On success, ‘getrandom’ returns the number of bytes which have been
     written to the buffer, which may be less than LENGTH.  On error, it
     returns -1, and ‘errno’ is set to indicate the problem.  Some of
     the possible errors are:

     ‘ENOSYS’
          The operating system does not implement a randomness source,
          or does not support this way of accessing it.  (For instance,
          the system call used by this function was added to the Linux
          kernel in version 3.17.)

     ‘EAGAIN’
          No random data was available and ‘GRND_NONBLOCK’ was specified
          in FLAGS.

     ‘EFAULT’
          The combination of BUFFER and LENGTH arguments specifies an
          invalid memory range.

     ‘EINTR’
          The system call was interrupted.  During the system boot
          process, before the kernel randomness pool is initialized,
          this can happen even if FLAGS is zero.

     ‘EINVAL’
          The FLAGS argument contains an invalid combination of flags.

     The ‘getrandom’ function is declared in the header file
     ‘sys/random.h’.  It is a GNU extension.


File: libc.info,  Node: Debugging Support,  Next: Threads,  Prev: Cryptographic Functions,  Up: Top

34 Debugging support
********************

Applications are usually debugged using dedicated debugger programs.
But sometimes this is not possible and, in any case, it is useful to
provide the developer with as much information as possible at the time
the problems are experienced.  For this reason a few functions are
provided which a program can use to help the developer more easily
locate the problem.

* Menu:

* Backtraces::                Obtaining and printing a back trace of the
                               current stack.


File: libc.info,  Node: Backtraces,  Up: Debugging Support

34.1 Backtraces
===============

A "backtrace" is a list of the function calls that are currently active
in a thread.  The usual way to inspect a backtrace of a program is to
use an external debugger such as gdb.  However, sometimes it is useful
to obtain a backtrace programmatically from within a program, e.g., for
the purposes of logging or diagnostics.

   The header file ‘execinfo.h’ declares three functions that obtain and
manipulate backtraces of the current thread.

 -- Function: int backtrace (void **BUFFER, int SIZE)

     Preliminary: | MT-Safe | AS-Unsafe init heap dlopen plugin lock |
     AC-Unsafe init mem lock fd | *Note POSIX Safety Concepts::.

     The ‘backtrace’ function obtains a backtrace for the current
     thread, as a list of pointers, and places the information into
     BUFFER.  The argument SIZE should be the number of ‘void *’
     elements that will fit into BUFFER.  The return value is the actual
     number of entries of BUFFER that are obtained, and is at most SIZE.

     The pointers placed in BUFFER are actually return addresses
     obtained by inspecting the stack, one return address per stack
     frame.

     Note that certain compiler optimizations may interfere with
     obtaining a valid backtrace.  Function inlining causes the inlined
     function to not have a stack frame; tail call optimization replaces
     one stack frame with another; frame pointer elimination will stop
     ‘backtrace’ from interpreting the stack contents correctly.

 -- Function: char ** backtrace_symbols (void *const *BUFFER, int SIZE)

     Preliminary: | MT-Safe | AS-Unsafe heap | AC-Unsafe mem lock |
     *Note POSIX Safety Concepts::.

     The ‘backtrace_symbols’ function translates the information
     obtained from the ‘backtrace’ function into an array of strings.
     The argument BUFFER should be a pointer to an array of addresses
     obtained via the ‘backtrace’ function, and SIZE is the number of
     entries in that array (the return value of ‘backtrace’).

     The return value is a pointer to an array of strings, which has
     SIZE entries just like the array BUFFER.  Each string contains a
     printable representation of the corresponding element of BUFFER.
     It includes the function name (if this can be determined), an
     offset into the function, and the actual return address (in
     hexadecimal).

     Currently, the function name and offset can only be obtained on
     systems that use the ELF binary format for programs and libraries.
     On other systems, only the hexadecimal return address will be
     present.  Also, you may need to pass additional flags to the linker
     to make the function names available to the program.  (For example,
     on systems using GNU ld, you must pass ‘-rdynamic’.)

     The return value of ‘backtrace_symbols’ is a pointer obtained via
     the ‘malloc’ function, and it is the responsibility of the caller
     to ‘free’ that pointer.  Note that only the return value need be
     freed, not the individual strings.

     The return value is ‘NULL’ if sufficient memory for the strings
     cannot be obtained.

 -- Function: void backtrace_symbols_fd (void *const *BUFFER, int SIZE,
          int FD)

     Preliminary: | MT-Safe | AS-Safe | AC-Unsafe lock | *Note POSIX
     Safety Concepts::.

     The ‘backtrace_symbols_fd’ function performs the same translation
     as the function ‘backtrace_symbols’ function.  Instead of returning
     the strings to the caller, it writes the strings to the file
     descriptor FD, one per line.  It does not use the ‘malloc’
     function, and can therefore be used in situations where that
     function might fail.

   The following program illustrates the use of these functions.  Note
that the array to contain the return addresses returned by ‘backtrace’
is allocated on the stack.  Therefore code like this can be used in
situations where the memory handling via ‘malloc’ does not work anymore
(in which case the ‘backtrace_symbols’ has to be replaced by a
‘backtrace_symbols_fd’ call as well).  The number of return addresses is
normally not very large.  Even complicated programs rather seldom have a
nesting level of more than, say, 50 and with 200 possible entries
probably all programs should be covered.


     #include <execinfo.h>
     #include <stdio.h>
     #include <stdlib.h>

     /* Obtain a backtrace and print it to ‘stdout’. */
     void
     print_trace (void)
     {
       void *array[10];
       size_t size;
       char **strings;
       size_t i;

       size = backtrace (array, 10);
       strings = backtrace_symbols (array, size);

       printf ("Obtained %zd stack frames.\n", size);

       for (i = 0; i < size; i++)
          printf ("%s\n", strings[i]);

       free (strings);
     }

     /* A dummy function to make the backtrace more interesting. */
     void
     dummy_function (void)
     {
       print_trace ();
     }

     int
     main (void)
     {
       dummy_function ();
       return 0;
     }


File: libc.info,  Node: Threads,  Next: Internal Probes,  Prev: Debugging Support,  Up: Top

35 Threads
**********

This chapter describes functions used for managing threads.  The GNU C
Library provides two threading implementations: ISO C threads and POSIX
threads.

* Menu:

* ISO C Threads::	Threads based on the ISO C specification.
* POSIX Threads::	Threads based on the POSIX specification.


File: libc.info,  Node: ISO C Threads,  Next: POSIX Threads,  Up: Threads

35.1 ISO C Threads
==================

This section describes the GNU C Library ISO C threads implementation.
To have a deeper understanding of this API, it is strongly recommended
to read ISO/IEC 9899:2011, section 7.26, in which ISO C threads were
originally specified.  All types and function prototypes are declared in
the header file ‘threads.h’.

* Menu:

* ISO C Threads Return Values:: Symbolic constants that represent a
				function’s return value.
* ISO C Thread Management::	Support for basic threading.
* Call Once::			Single-call functions and macros.
* ISO C Mutexes::		A low-level mechanism for mutual exclusion.
* ISO C Condition Variables::	High-level objects for thread synchronization.
* ISO C Thread-local Storage::	Functions to support thread-local storage.


File: libc.info,  Node: ISO C Threads Return Values,  Next: ISO C Thread Management,  Up: ISO C Threads

35.1.1 Return Values
--------------------

The ISO C thread specification provides the following enumeration
constants for return values from functions in the API:

‘thrd_timedout’

     A specified time was reached without acquiring the requested
     resource, usually a mutex or condition variable.

‘thrd_success’

     The requested operation succeeded.

‘thrd_busy’

     The requested operation failed because a requested resource is
     already in use.

‘thrd_error’

     The requested operation failed.

‘thrd_nomem’

     The requested operation failed because it was unable to allocate
     enough memory.


File: libc.info,  Node: ISO C Thread Management,  Next: Call Once,  Prev: ISO C Threads Return Values,  Up: ISO C Threads

35.1.2 Creation and Control
---------------------------

The GNU C Library implements a set of functions that allow the user to
easily create and use threads.  Additional functionality is provided to
control the behavior of threads.

   The following data types are defined for managing threads:

 -- Data Type: thrd_t

     A unique object that identifies a thread.

 -- Data Type: thrd_start_t

     This data type is an ‘int (*) (void *)’ typedef that is passed to
     ‘thrd_create’ when creating a new thread.  It should point to the
     first function that thread will run.

   The following functions are used for working with threads:

 -- Function: int thrd_create (thrd_t *THR, thrd_start_t FUNC, void
          *ARG)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘thrd_create’ creates a new thread that will execute the function
     FUNC.  The object pointed to by ARG will be used as the argument to
     FUNC.  If successful, THR is set to the new thread identifier.

     This function may return ‘thrd_success’, ‘thrd_nomem’, or
     ‘thrd_error’.

 -- Function: thrd_t thrd_current (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This function returns the identifier of the calling thread.

 -- Function: int thrd_equal (thrd_t LHS, thrd_t RHS)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘thrd_equal’ checks whether LHS and RHS refer to the same thread.
     If LHS and RHS are different threads, this function returns 0;
     otherwise, the return value is non-zero.

 -- Function: int thrd_sleep (const struct timespec *TIME_POINT, struct
          timespec *REMAINING)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘thrd_sleep’ blocks the execution of the current thread for at
     least until the elapsed time pointed to by TIME_POINT has been
     reached.  This function does not take an absolute time, but a
     duration that the thread is required to be blocked.  *Note Time
     Basics::, and *note Elapsed Time::.

     The thread may wake early if a signal that is not ignored is
     received.  In such a case, if ‘remaining’ is not NULL, the
     remaining time duration is stored in the object pointed to by
     REMAINING.

     ‘thrd_sleep’ returns 0 if it blocked for at least the amount of
     time in ‘time_point’, -1 if it was interrupted by a signal, or a
     negative number on failure.

 -- Function: void thrd_yield (void)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘thrd_yield’ provides a hint to the implementation to reschedule
     the execution of the current thread, allowing other threads to run.

 -- Function: _Noreturn void thrd_exit (int RES)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘thrd_exit’ terminates execution of the calling thread and sets its
     result code to RES.

     If this function is called from a single-threaded process, the call
     is equivalent to calling ‘exit’ with ‘EXIT_SUCCESS’ (*note Normal
     Termination::).  Also note that returning from a function that
     started a thread is equivalent to calling ‘thrd_exit’.

 -- Function: int thrd_detach (thrd_t THR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘thrd_detach’ detaches the thread identified by ‘thr’ from the
     current control thread.  The resources held by the detached thread
     will be freed automatically once the thread exits.  The parent
     thread will never be notified by any THR signal.

     Calling ‘thrd_detach’ on a thread that was previously detached or
     joined by another thread results in undefined behavior.

     This function returns either ‘thrd_success’ or ‘thrd_error’.

 -- Function: int thrd_join (thrd_t THR, int *RES)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘thrd_join’ blocks the current thread until the thread identified
     by ‘thr’ finishes execution.  If ‘res’ is not NULL, the result code
     of the thread is put into the location pointed to by RES.  The
     termination of the thread "synchronizes-with" the completion of
     this function, meaning both threads have arrived at a common point
     in their execution.

     Calling ‘thrd_join’ on a thread that was previously detached or
     joined by another thread results in undefined behavior.

     This function returns either ‘thrd_success’ or ‘thrd_error’.


File: libc.info,  Node: Call Once,  Next: ISO C Mutexes,  Prev: ISO C Thread Management,  Up: ISO C Threads

35.1.3 Call Once
----------------

In order to guarantee single access to a function, the GNU C Library
implements a "call once function" to ensure a function is only called
once in the presence of multiple, potentially calling threads.

 -- Data Type: once_flag

     A complete object type capable of holding a flag used by
     ‘call_once’.

 -- Macro: ONCE_FLAG_INIT

     This value is used to initialize an object of type ‘once_flag’.

 -- Function: void call_once (once_flag *FLAG, void (*FUNC) (void))

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘call_once’ calls function FUNC exactly once, even if invoked from
     several threads.  The completion of the function FUNC
     synchronizes-with all previous or subsequent calls to ‘call_once’
     with the same ‘flag’ variable.


File: libc.info,  Node: ISO C Mutexes,  Next: ISO C Condition Variables,  Prev: Call Once,  Up: ISO C Threads

35.1.4 Mutexes
--------------

To have better control of resources and how threads access them, the GNU
C Library implements a "mutex" object, which can help avoid race
conditions and other concurrency issues.  The term “mutex” refers to
mutual exclusion.

   The fundamental data type for a mutex is the ‘mtx_t’:

 -- Data Type: mtx_t

     The ‘mtx_t’ data type uniquely identifies a mutex object.

   The ISO C standard defines several types of mutexes.  They are
represented by the following symbolic constants:

‘mtx_plain’

     A mutex that does not support timeout, or test and return.

‘mtx_recursive’

     A mutex that supports recursive locking, which means that the
     owning thread can lock it more than once without causing deadlock.

‘mtx_timed’

     A mutex that supports timeout.

   The following functions are used for working with mutexes:

 -- Function: int mtx_init (mtx_t *MUTEX, int TYPE)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘mtx_init’ creates a new mutex object with type TYPE.  The object
     pointed to by MUTEX is set to the identifier of the newly created
     mutex.

     Not all combinations of mutex types are valid for the ‘type’
     argument.  Valid uses of mutex types for the ‘type’ argument are:

     ‘mtx_plain’
          A non-recursive mutex that does not support timeout.

     ‘mtx_timed’
          A non-recursive mutex that does support timeout.

     ‘mtx_plain | mtx_recursive’
          A recursive mutex that does not support timeout.

     ‘mtx_timed | mtx_recursive’
          A recursive mutex that does support timeout.

     This function returns either ‘thrd_success’ or ‘thrd_error’.

 -- Function: int mtx_lock (mtx_t *MUTEX)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     ‘mtx_lock’ blocks the current thread until the mutex pointed to by
     MUTEX is locked.  The behavior is undefined if the current thread
     has already locked the mutex and the mutex is not recursive.

     Prior calls to ‘mtx_unlock’ on the same mutex synchronize-with this
     operation (if this operation succeeds), and all lock/unlock
     operations on any given mutex form a single total order (similar to
     the modification order of an atomic).

     This function returns either ‘thrd_success’ or ‘thrd_error’.

 -- Function: int mtx_timedlock (mtx_t *restrict MUTEX, const struct
          timespec *restrict TIME_POINT)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     ‘mtx_timedlock’ blocks the current thread until the mutex pointed
     to by MUTEX is locked or until the calendar time pointed to by
     TIME_POINT has been reached.  Since this function takes an absolute
     time, if a duration is required, the calendar time must be
     calculated manually.  *Note Time Basics::, and *note Calendar
     Time::.

     If the current thread has already locked the mutex and the mutex is
     not recursive, or if the mutex does not support timeout, the
     behavior of this function is undefined.

     Prior calls to ‘mtx_unlock’ on the same mutex synchronize-with this
     operation (if this operation succeeds), and all lock/unlock
     operations on any given mutex form a single total order (similar to
     the modification order of an atomic).

     This function returns either ‘thrd_success’ or ‘thrd_error’.

 -- Function: int mtx_trylock (mtx_t *MUTEX)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     ‘mtx_trylock’ tries to lock the mutex pointed to by MUTEX without
     blocking.  It returns immediately if the mutex is already locked.

     Prior calls to ‘mtx_unlock’ on the same mutex synchronize-with this
     operation (if this operation succeeds), and all lock/unlock
     operations on any given mutex form a single total order (similar to
     the modification order of an atomic).

     This function returns ‘thrd_success’ if the lock was obtained,
     ‘thrd_busy’ if the mutex is already locked, and ‘thrd_error’ on
     failure.

 -- Function: int mtx_unlock (mtx_t *MUTEX)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘mtx_unlock’ unlocks the mutex pointed to by MUTEX.  The behavior
     is undefined if the mutex is not locked by the calling thread.

     This function synchronizes-with subsequent ‘mtx_lock’,
     ‘mtx_trylock’, and ‘mtx_timedlock’ calls on the same mutex.  All
     lock/unlock operations on any given mutex form a single total order
     (similar to the modification order of an atomic).

     This function returns either ‘thrd_success’ or ‘thrd_error’.

 -- Function: void mtx_destroy (mtx_t *MUTEX)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘mtx_destroy’ destroys the mutex pointed to by MUTEX.  If there are
     any threads waiting on the mutex, the behavior is undefined.


File: libc.info,  Node: ISO C Condition Variables,  Next: ISO C Thread-local Storage,  Prev: ISO C Mutexes,  Up: ISO C Threads

35.1.5 Condition Variables
--------------------------

Mutexes are not the only synchronization mechanisms available.  For some
more complex tasks, the GNU C Library also implements "condition
variables", which allow the programmer to think at a higher level when
solving complex synchronization problems.  They are used to synchronize
threads waiting on a certain condition to happen.

   The fundamental data type for condition variables is the ‘cnd_t’:

 -- Data Type: cnd_t

     The ‘cnd_t’ uniquely identifies a condition variable object.

   The following functions are used for working with condition
variables:

 -- Function: int cnd_init (cnd_t *COND)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘cnd_init’ initializes a new condition variable, identified by
     COND.

     This function may return ‘thrd_success’, ‘thrd_nomem’, or
     ‘thrd_error’.

 -- Function: int cnd_signal (cnd_t *COND)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘cnd_signal’ unblocks one thread that is currently waiting on the
     condition variable pointed to by COND.  If a thread is successfully
     unblocked, this function returns ‘thrd_success’.  If no threads are
     blocked, this function does nothing and returns ‘thrd_success’.
     Otherwise, this function returns ‘thrd_error’.

 -- Function: int cnd_broadcast (cnd_t *COND)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘cnd_broadcast’ unblocks all the threads that are currently waiting
     on the condition variable pointed to by COND.  This function
     returns ‘thrd_success’ on success.  If no threads are blocked, this
     function does nothing and returns ‘thrd_success’.  Otherwise, this
     function returns ‘thrd_error’.

 -- Function: int cnd_wait (cnd_t *COND, mtx_t *MUTEX)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     ‘cnd_wait’ atomically unlocks the mutex pointed to by MUTEX and
     blocks on the condition variable pointed to by COND until the
     thread is signaled by ‘cnd_signal’ or ‘cnd_broadcast’.  The mutex
     is locked again before the function returns.

     This function returns either ‘thrd_success’ or ‘thrd_error’.

 -- Function: int cnd_timedwait (cnd_t *restrict COND, mtx_t *restrict
          MUTEX, const struct timespec *restrict TIME_POINT)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     ‘cnd_timedwait’ atomically unlocks the mutex pointed to by MUTEX
     and blocks on the condition variable pointed to by COND until the
     thread is signaled by ‘cnd_signal’ or ‘cnd_broadcast’, or until the
     calendar time pointed to by TIME_POINT has been reached.  The mutex
     is locked again before the function returns.

     As for ‘mtx_timedlock’, since this function takes an absolute time,
     if a duration is required, the calendar time must be calculated
     manually.  *Note Time Basics::, and *note Calendar Time::.

     This function may return ‘thrd_success’, ‘thrd_nomem’, or
     ‘thrd_error’.

 -- Function: void cnd_destroy (cnd_t *COND)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘cnd_destroy’ destroys the condition variable pointed to by COND.
     If there are threads waiting on COND, the behavior is undefined.


File: libc.info,  Node: ISO C Thread-local Storage,  Prev: ISO C Condition Variables,  Up: ISO C Threads

35.1.6 Thread-local Storage
---------------------------

The GNU C Library implements functions to provide "thread-local
storage", a mechanism by which variables can be defined to have unique
per-thread storage, lifetimes that match the thread lifetime, and
destructors that cleanup the unique per-thread storage.

   Several data types and macros exist for working with thread-local
storage:

 -- Data Type: tss_t

     The ‘tss_t’ data type identifies a thread-specific storage object.
     Even if shared, every thread will have its own instance of the
     variable, with different values.

 -- Data Type: tss_dtor_t

     The ‘tss_dtor_t’ is a function pointer of type ‘void (*) (void *)’,
     to be used as a thread-specific storage destructor.  The function
     will be called when the current thread calls ‘thrd_exit’ (but never
     when calling ‘tss_delete’ or ‘exit’).

 -- Macro: thread_local

     ‘thread_local’ is used to mark a variable with thread storage
     duration, which means it is created when the thread starts and
     cleaned up when the thread ends.

     _Note:_ For C++, C++11 or later is required to use the
     ‘thread_local’ keyword.

 -- Macro: TSS_DTOR_ITERATIONS

     ‘TSS_DTOR_ITERATIONS’ is an integer constant expression
     representing the maximum number of iterations over all thread-local
     destructors at the time of thread termination.  This value provides
     a bounded limit to the destruction of thread-local storage; e.g.,
     consider a destructor that creates more thread-local storage.

   The following functions are used to manage thread-local storage:

 -- Function: int tss_create (tss_t *TSS_KEY, tss_dtor_t DESTRUCTOR)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘tss_create’ creates a new thread-specific storage key and stores
     it in the object pointed to by TSS_KEY.  Although the same key
     value may be used by different threads, the values bound to the key
     by ‘tss_set’ are maintained on a per-thread basis and persist for
     the life of the calling thread.

     If ‘destructor’ is not NULL, a destructor function will be set, and
     called when the thread finishes its execution by calling
     ‘thrd_exit’.

     This function returns ‘thrd_success’ if ‘tss_key’ is successfully
     set to a unique value for the thread; otherwise, ‘thrd_error’ is
     returned and the value of ‘tss_key’ is undefined.

 -- Function: int tss_set (tss_t TSS_KEY, void *VAL)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘tss_set’ sets the value of the thread-specific storage identified
     by TSS_KEY for the current thread to VAL.  Different threads may
     set different values to the same key.

     This function returns either ‘thrd_success’ or ‘thrd_error’.

 -- Function: void * tss_get (tss_t TSS_KEY)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘tss_get’ returns the value identified by TSS_KEY held in
     thread-specific storage for the current thread.  Different threads
     may get different values identified by the same key.  On failure,
     ‘tss_get’ returns zero.

 -- Function: void tss_delete (tss_t TSS_KEY)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     ‘tss_delete’ destroys the thread-specific storage identified by
     TSS_KEY.


File: libc.info,  Node: POSIX Threads,  Prev: ISO C Threads,  Up: Threads

35.2 POSIX Threads
==================

This section describes the GNU C Library POSIX Threads implementation.

* Menu:

* Thread-specific Data::          Support for creating and
				  managing thread-specific data
* Non-POSIX Extensions::          Additional functions to extend
				  POSIX Thread functionality


File: libc.info,  Node: Thread-specific Data,  Next: Non-POSIX Extensions,  Up: POSIX Threads

35.2.1 Thread-specific Data
---------------------------

The GNU C Library implements functions to allow users to create and
manage data specific to a thread.  Such data may be destroyed at thread
exit, if a destructor is provided.  The following functions are defined:

 -- Function: int pthread_key_create (pthread_key_t *KEY, void
          (*DESTRUCTOR)(void*))

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Create a thread-specific data key for the calling thread,
     referenced by KEY.

     Objects declared with the C++11 ‘thread_local’ keyword are
     destroyed before thread-specific data, so they should not be used
     in thread-specific data destructors or even as members of the
     thread-specific data, since the latter is passed as an argument to
     the destructor function.

 -- Function: int pthread_key_delete (pthread_key_t KEY)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Destroy the thread-specific data KEY in the calling thread.  The
     destructor for the thread-specific data is not called during
     destruction, nor is it called during thread exit.

 -- Function: void *pthread_getspecific (pthread_key_t KEY)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     Return the thread-specific data associated with KEY in the calling
     thread.

 -- Function: int pthread_setspecific (pthread_key_t KEY, const void
          *VALUE)

     Preliminary: | MT-Safe | AS-Unsafe corrupt heap | AC-Unsafe corrupt
     mem | *Note POSIX Safety Concepts::.

     Associate the thread-specific VALUE with KEY in the calling thread.


File: libc.info,  Node: Non-POSIX Extensions,  Prev: Thread-specific Data,  Up: POSIX Threads

35.2.2 Non-POSIX Extensions
---------------------------

In addition to implementing the POSIX API for threads, the GNU C Library
provides additional functions and interfaces to provide functionality
not specified in the standard.

* Menu:

* Default Thread Attributes::             Setting default attributes for
					  threads in a process.


File: libc.info,  Node: Default Thread Attributes,  Up: Non-POSIX Extensions

35.2.2.1 Setting Process-wide defaults for thread attributes
............................................................

The GNU C Library provides non-standard API functions to set and get the
default attributes used in the creation of threads in a process.

 -- Function: int pthread_getattr_default_np (pthread_attr_t *ATTR)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     Get the default attribute values and set ATTR to match.  This
     function returns 0 on success and a non-zero error code on failure.

 -- Function: int pthread_setattr_default_np (pthread_attr_t *ATTR)

     Preliminary: | MT-Safe | AS-Unsafe heap lock | AC-Unsafe lock mem |
     *Note POSIX Safety Concepts::.

     Set the default attribute values to match the values in ATTR.  The
     function returns 0 on success and a non-zero error code on failure.
     The following error codes are defined for this function:

     ‘EINVAL’
          At least one of the values in ATTR does not qualify as valid
          for the attributes or the stack address is set in the
          attribute.
     ‘ENOMEM’
          The system does not have sufficient memory.

 -- Function: int sem_clockwait (sem_t *SEM, clockid_t CLOCKID,
     const struct timespec *ABSTIME) Behaves like ‘sem_timedwait’ except
     the time ABSTIME is measured against the clock specified by CLOCKID
     rather than ‘CLOCK_REALTIME’.  Currently, CLOCKID must be either
     ‘CLOCK_MONOTONIC’ or ‘CLOCK_REALTIME’.

 -- Function: int pthread_cond_clockwait (pthread_cond_t *COND,
          pthread_mutex_t *MUTEX,
     clockid_t CLOCKID, const struct timespec *ABSTIME) Preliminary: |
     MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note POSIX Safety
     Concepts::.

     Behaves like ‘pthread_cond_timedwait’ except the time ABSTIME is
     measured against the clock specified by CLOCKID rather than the
     clock specified or defaulted when ‘pthread_cond_init’ was called.
     Currently, CLOCKID must be either ‘CLOCK_MONOTONIC’ or
     ‘CLOCK_REALTIME’.

 -- Function: int pthread_rwlock_clockrdlock (pthread_rwlock_t *RWLOCK,
     clockid_t CLOCKID,	const struct timespec *ABSTIME)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     Behaves like ‘pthread_rwlock_timedrdlock’ except the time ABSTIME
     is measured against the clock specified by CLOCKID rather than
     ‘CLOCK_REALTIME’.  Currently, CLOCKID must be either
     ‘CLOCK_MONOTONIC’ or ‘CLOCK_REALTIME’, otherwise ‘EINVAL’ is
     returned.

 -- Function: int pthread_rwlock_clockwrlock (pthread_rwlock_t *RWLOCK,
     clockid_t CLOCKID,	const struct timespec *ABSTIME)

     Preliminary: | MT-Safe | AS-Unsafe lock | AC-Unsafe lock | *Note
     POSIX Safety Concepts::.

     Behaves like ‘pthread_rwlock_timedwrlock’ except the time ABSTIME
     is measured against the clock specified by CLOCKID rather than
     ‘CLOCK_REALTIME’.  Currently, CLOCKID must be either
     ‘CLOCK_MONOTONIC’ or ‘CLOCK_REALTIME’, otherwise ‘EINVAL’ is
     returned.


File: libc.info,  Node: Internal Probes,  Next: Tunables,  Prev: Threads,  Up: Top

36 Internal probes
******************

In order to aid in debugging and monitoring internal behavior, the GNU C
Library exposes nearly-zero-overhead SystemTap probes marked with the
‘libc’ provider.

   These probes are not part of the GNU C Library stable ABI, and they
are subject to change or removal across releases.  Our only promise with
regard to them is that, if we find a need to remove or modify the
arguments of a probe, the modified probe will have a different name, so
that program monitors relying on the old probe will not get unexpected
arguments.

* Menu:

* Memory Allocation Probes::  Probes in the memory allocation subsystem
* Mathematical Function Probes::  Probes in mathematical functions
* Non-local Goto Probes::  Probes in setjmp and longjmp


File: libc.info,  Node: Memory Allocation Probes,  Next: Mathematical Function Probes,  Up: Internal Probes

36.1 Memory Allocation Probes
=============================

These probes are designed to signal relatively unusual situations within
the virtual memory subsystem of the GNU C Library.

 -- Probe: memory_sbrk_more (void *$ARG1, size_t $ARG2)
     This probe is triggered after the main arena is extended by calling
     ‘sbrk’.  Argument $ARG1 is the additional size requested to ‘sbrk’,
     and $ARG2 is the pointer that marks the end of the ‘sbrk’ area,
     returned in response to the request.

 -- Probe: memory_sbrk_less (void *$ARG1, size_t $ARG2)
     This probe is triggered after the size of the main arena is
     decreased by calling ‘sbrk’.  Argument $ARG1 is the size released
     by ‘sbrk’ (the positive value, rather than the negative value
     passed to ‘sbrk’), and $ARG2 is the pointer that marks the end of
     the ‘sbrk’ area, returned in response to the request.

 -- Probe: memory_heap_new (void *$ARG1, size_t $ARG2)
     This probe is triggered after a new heap is ‘mmap’ed.  Argument
     $ARG1 is a pointer to the base of the memory area, where the
     ‘heap_info’ data structure is held, and $ARG2 is the size of the
     heap.

 -- Probe: memory_heap_free (void *$ARG1, size_t $ARG2)
     This probe is triggered _before_ (unlike the other sbrk and heap
     probes) a heap is completely removed via ‘munmap’.  Argument $ARG1
     is a pointer to the heap, and $ARG2 is the size of the heap.

 -- Probe: memory_heap_more (void *$ARG1, size_t $ARG2)
     This probe is triggered after a trailing portion of an ‘mmap’ed
     heap is extended.  Argument $ARG1 is a pointer to the heap, and
     $ARG2 is the new size of the heap.

 -- Probe: memory_heap_less (void *$ARG1, size_t $ARG2)
     This probe is triggered after a trailing portion of an ‘mmap’ed
     heap is released.  Argument $ARG1 is a pointer to the heap, and
     $ARG2 is the new size of the heap.

 -- Probe: memory_malloc_retry (size_t $ARG1)
 -- Probe: memory_realloc_retry (size_t $ARG1, void *$ARG2)
 -- Probe: memory_memalign_retry (size_t $ARG1, size_t $ARG2)
 -- Probe: memory_calloc_retry (size_t $ARG1)
     These probes are triggered when the corresponding functions fail to
     obtain the requested amount of memory from the arena in use, before
     they call ‘arena_get_retry’ to select an alternate arena in which
     to retry the allocation.  Argument $ARG1 is the amount of memory
     requested by the user; in the ‘calloc’ case, that is the total size
     computed from both function arguments.  In the ‘realloc’ case,
     $ARG2 is the pointer to the memory area being resized.  In the
     ‘memalign’ case, $ARG2 is the alignment to be used for the request,
     which may be stricter than the value passed to the ‘memalign’
     function.  A ‘memalign’ probe is also used by functions
     ‘posix_memalign, valloc’ and ‘pvalloc’.

     Note that the argument order does _not_ match that of the
     corresponding two-argument functions, so that in all of these
     probes the user-requested allocation size is in $ARG1.

 -- Probe: memory_arena_retry (size_t $ARG1, void *$ARG2)
     This probe is triggered within ‘arena_get_retry’ (the function
     called to select the alternate arena in which to retry an
     allocation that failed on the first attempt), before the selection
     of an alternate arena.  This probe is redundant, but much easier to
     use when it’s not important to determine which of the various
     memory allocation functions is failing to allocate on the first
     try.  Argument $ARG1 is the same as in the function-specific
     probes, except for extra room for padding introduced by functions
     that have to ensure stricter alignment.  Argument $ARG2 is the
     arena in which allocation failed.

 -- Probe: memory_arena_new (void *$ARG1, size_t $ARG2)
     This probe is triggered when ‘malloc’ allocates and initializes an
     additional arena (not the main arena), but before the arena is
     assigned to the running thread or inserted into the internal linked
     list of arenas.  The arena’s ‘malloc_state’ internal data structure
     is located at $ARG1, within a newly-allocated heap big enough to
     hold at least $ARG2 bytes.

 -- Probe: memory_arena_reuse (void *$ARG1, void *$ARG2)
     This probe is triggered when ‘malloc’ has just selected an existing
     arena to reuse, and (temporarily) reserved it for exclusive use.
     Argument $ARG1 is a pointer to the newly-selected arena, and $ARG2
     is a pointer to the arena previously used by that thread.

     This occurs within ‘reused_arena’, right after the mutex mentioned
     in probe ‘memory_arena_reuse_wait’ is acquired; argument $ARG1 will
     point to the same arena.  In this configuration, this will usually
     only occur once per thread.  The exception is when a thread first
     selected the main arena, but a subsequent allocation from it fails:
     then, and only then, may we switch to another arena to retry that
     allocation, and for further allocations within that thread.

 -- Probe: memory_arena_reuse_wait (void *$ARG1, void *$ARG2, void
          *$ARG3)
     This probe is triggered when ‘malloc’ is about to wait for an arena
     to become available for reuse.  Argument $ARG1 holds a pointer to
     the mutex the thread is going to wait on, $ARG2 is a pointer to a
     newly-chosen arena to be reused, and $ARG3 is a pointer to the
     arena previously used by that thread.

     This occurs within ‘reused_arena’, when a thread first tries to
     allocate memory or needs a retry after a failure to allocate from
     the main arena, there isn’t any free arena, the maximum number of
     arenas has been reached, and an existing arena was chosen for
     reuse, but its mutex could not be immediately acquired.  The mutex
     in $ARG1 is the mutex of the selected arena.

 -- Probe: memory_arena_reuse_free_list (void *$ARG1)
     This probe is triggered when ‘malloc’ has chosen an arena that is
     in the free list for use by a thread, within the ‘get_free_list’
     function.  The argument $ARG1 holds a pointer to the selected
     arena.

 -- Probe: memory_mallopt (int $ARG1, int $ARG2)
     This probe is triggered when function ‘mallopt’ is called to change
     ‘malloc’ internal configuration parameters, before any change to
     the parameters is made.  The arguments $ARG1 and $ARG2 are the ones
     passed to the ‘mallopt’ function.

 -- Probe: memory_mallopt_mxfast (int $ARG1, int $ARG2)
     This probe is triggered shortly after the ‘memory_mallopt’ probe,
     when the parameter to be changed is ‘M_MXFAST’, and the requested
     value is in an acceptable range.  Argument $ARG1 is the requested
     value, and $ARG2 is the previous value of this ‘malloc’ parameter.

 -- Probe: memory_mallopt_trim_threshold (int $ARG1, int $ARG2, int
          $ARG3)
     This probe is triggered shortly after the ‘memory_mallopt’ probe,
     when the parameter to be changed is ‘M_TRIM_THRESHOLD’.  Argument
     $ARG1 is the requested value, $ARG2 is the previous value of this
     ‘malloc’ parameter, and $ARG3 is nonzero if dynamic threshold
     adjustment was already disabled.

 -- Probe: memory_mallopt_top_pad (int $ARG1, int $ARG2, int $ARG3)
     This probe is triggered shortly after the ‘memory_mallopt’ probe,
     when the parameter to be changed is ‘M_TOP_PAD’.  Argument $ARG1 is
     the requested value, $ARG2 is the previous value of this ‘malloc’
     parameter, and $ARG3 is nonzero if dynamic threshold adjustment was
     already disabled.

 -- Probe: memory_mallopt_mmap_threshold (int $ARG1, int $ARG2, int
          $ARG3)
     This probe is triggered shortly after the ‘memory_mallopt’ probe,
     when the parameter to be changed is ‘M_MMAP_THRESHOLD’, and the
     requested value is in an acceptable range.  Argument $ARG1 is the
     requested value, $ARG2 is the previous value of this ‘malloc’
     parameter, and $ARG3 is nonzero if dynamic threshold adjustment was
     already disabled.

 -- Probe: memory_mallopt_mmap_max (int $ARG1, int $ARG2, int $ARG3)
     This probe is triggered shortly after the ‘memory_mallopt’ probe,
     when the parameter to be changed is ‘M_MMAP_MAX’.  Argument $ARG1
     is the requested value, $ARG2 is the previous value of this
     ‘malloc’ parameter, and $ARG3 is nonzero if dynamic threshold
     adjustment was already disabled.

 -- Probe: memory_mallopt_perturb (int $ARG1, int $ARG2)
     This probe is triggered shortly after the ‘memory_mallopt’ probe,
     when the parameter to be changed is ‘M_PERTURB’.  Argument $ARG1 is
     the requested value, and $ARG2 is the previous value of this
     ‘malloc’ parameter.

 -- Probe: memory_mallopt_arena_test (int $ARG1, int $ARG2)
     This probe is triggered shortly after the ‘memory_mallopt’ probe,
     when the parameter to be changed is ‘M_ARENA_TEST’, and the
     requested value is in an acceptable range.  Argument $ARG1 is the
     requested value, and $ARG2 is the previous value of this ‘malloc’
     parameter.

 -- Probe: memory_mallopt_arena_max (int $ARG1, int $ARG2)
     This probe is triggered shortly after the ‘memory_mallopt’ probe,
     when the parameter to be changed is ‘M_ARENA_MAX’, and the
     requested value is in an acceptable range.  Argument $ARG1 is the
     requested value, and $ARG2 is the previous value of this ‘malloc’
     parameter.

 -- Probe: memory_mallopt_free_dyn_thresholds (int $ARG1, int $ARG2)
     This probe is triggered when function ‘free’ decides to adjust the
     dynamic brk/mmap thresholds.  Argument $ARG1 and $ARG2 are the
     adjusted mmap and trim thresholds, respectively.

 -- Probe: memory_tunable_tcache_max_bytes (int $ARG1, int $ARG2)
     This probe is triggered when the ‘glibc.malloc.tcache_max’ tunable
     is set.  Argument $ARG1 is the requested value, and $ARG2 is the
     previous value of this tunable.

 -- Probe: memory_tunable_tcache_count (int $ARG1, int $ARG2)
     This probe is triggered when the ‘glibc.malloc.tcache_count’
     tunable is set.  Argument $ARG1 is the requested value, and $ARG2
     is the previous value of this tunable.

 -- Probe: memory_tunable_tcache_unsorted_limit (int $ARG1, int $ARG2)
     This probe is triggered when the
     ‘glibc.malloc.tcache_unsorted_limit’ tunable is set.  Argument
     $ARG1 is the requested value, and $ARG2 is the previous value of
     this tunable.

 -- Probe: memory_tcache_double_free (void *$ARG1, int $ARG2)
     This probe is triggered when ‘free’ determines that the memory
     being freed has probably already been freed, and resides in the
     per-thread cache.  Note that there is an extremely unlikely chance
     that this probe will trigger due to random payload data remaining
     in the allocated memory matching the key used to detect double
     frees.  This probe actually indicates that an expensive linear
     search of the tcache, looking for a double free, has happened.
     Argument $ARG1 is the memory location as passed to ‘free’, Argument
     $ARG2 is the tcache bin it resides in.


File: libc.info,  Node: Mathematical Function Probes,  Next: Non-local Goto Probes,  Prev: Memory Allocation Probes,  Up: Internal Probes

36.2 Mathematical Function Probes
=================================

Some mathematical functions fall back to multiple precision arithmetic
for some inputs to get last bit precision for their return values.  This
multiple precision fallback is much slower than the default algorithms
and may have a significant impact on application performance.  The
systemtap probe markers described in this section may help you determine
if your application calls mathematical functions with inputs that may
result in multiple-precision arithmetic.

   Unless explicitly mentioned otherwise, a precision of 1 implies 24
bits of precision in the mantissa of the multiple precision number.
Hence, a precision level of 32 implies 768 bits of precision in the
mantissa.

 -- Probe: slowatan2 (int $ARG1, double $ARG2, double $ARG3, double
          $ARG4)
     This probe is triggered when the ‘atan2’ function is called with an
     input that results in multiple precision computation.  Argument
     $ARG1 is the precision with which computation succeeded.  Arguments
     $ARG2 and $ARG3 are inputs to the ‘atan2’ function and $ARG4 is the
     computed result.

 -- Probe: slowatan2_inexact (int $ARG1, double $ARG2, double $ARG3,
          double $ARG4)
     This probe is triggered when the ‘atan’ function is called with an
     input that results in multiple precision computation and none of
     the multiple precision computations result in an accurate result.
     Argument $ARG1 is the maximum precision with which computations
     were performed.  Arguments $ARG2 and $ARG3 are inputs to the
     ‘atan2’ function and $ARG4 is the computed result.

 -- Probe: slowatan (int $ARG1, double $ARG2, double $ARG3)
     This probe is triggered when the ‘atan’ function is called with an
     input that results in multiple precision computation.  Argument
     $ARG1 is the precision with which computation succeeded.  Argument
     $ARG2 is the input to the ‘atan’ function and $ARG3 is the computed
     result.

 -- Probe: slowatan_inexact (int $ARG1, double $ARG2, double $ARG3)
     This probe is triggered when the ‘atan’ function is called with an
     input that results in multiple precision computation and none of
     the multiple precision computations result in an accurate result.
     Argument $ARG1 is the maximum precision with which computations
     were performed.  Argument $ARG2 is the input to the ‘atan’ function
     and $ARG3 is the computed result.

 -- Probe: slowtan (double $ARG1, double $ARG2)
     This probe is triggered when the ‘tan’ function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function and $ARG2 is the
     computed result.

 -- Probe: slowasin (double $ARG1, double $ARG2)
     This probe is triggered when the ‘asin’ function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function and $ARG2 is the
     computed result.

 -- Probe: slowacos (double $ARG1, double $ARG2)
     This probe is triggered when the ‘acos’ function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function and $ARG2 is the
     computed result.

 -- Probe: slowsin (double $ARG1, double $ARG2)
     This probe is triggered when the ‘sin’ function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function and $ARG2 is the
     computed result.

 -- Probe: slowcos (double $ARG1, double $ARG2)
     This probe is triggered when the ‘cos’ function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function and $ARG2 is the
     computed result.

 -- Probe: slowsin_dx (double $ARG1, double $ARG2, double $ARG3)
     This probe is triggered when the ‘sin’ function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function, $ARG2 is the
     error bound of $ARG1 and $ARG3 is the computed result.

 -- Probe: slowcos_dx (double $ARG1, double $ARG2, double $ARG3)
     This probe is triggered when the ‘cos’ function is called with an
     input that results in multiple precision computation with precision
     32.  Argument $ARG1 is the input to the function, $ARG2 is the
     error bound of $ARG1 and $ARG3 is the computed result.


File: libc.info,  Node: Non-local Goto Probes,  Prev: Mathematical Function Probes,  Up: Internal Probes

36.3 Non-local Goto Probes
==========================

These probes are used to signal calls to ‘setjmp’, ‘sigsetjmp’,
‘longjmp’ or ‘siglongjmp’.

 -- Probe: setjmp (void *$ARG1, int $ARG2, void *$ARG3)
     This probe is triggered whenever ‘setjmp’ or ‘sigsetjmp’ is called.
     Argument $ARG1 is a pointer to the ‘jmp_buf’ passed as the first
     argument of ‘setjmp’ or ‘sigsetjmp’, $ARG2 is the second argument
     of ‘sigsetjmp’ or zero if this is a call to ‘setjmp’ and $ARG3 is a
     pointer to the return address that will be stored in the ‘jmp_buf’.

 -- Probe: longjmp (void *$ARG1, int $ARG2, void *$ARG3)
     This probe is triggered whenever ‘longjmp’ or ‘siglongjmp’ is
     called.  Argument $ARG1 is a pointer to the ‘jmp_buf’ passed as the
     first argument of ‘longjmp’ or ‘siglongjmp’, $ARG2 is the return
     value passed as the second argument of ‘longjmp’ or ‘siglongjmp’
     and $ARG3 is a pointer to the return address ‘longjmp’ or
     ‘siglongjmp’ will return to.

     The ‘longjmp’ probe is triggered at a point where the registers
     have not yet been restored to the values in the ‘jmp_buf’ and
     unwinding will show a call stack including the caller of ‘longjmp’
     or ‘siglongjmp’.

 -- Probe: longjmp_target (void *$ARG1, int $ARG2, void *$ARG3)
     This probe is triggered under the same conditions and with the same
     arguments as the ‘longjmp’ probe.

     The ‘longjmp_target’ probe is triggered at a point where the
     registers have been restored to the values in the ‘jmp_buf’ and
     unwinding will show a call stack including the caller of ‘setjmp’
     or ‘sigsetjmp’.


File: libc.info,  Node: Tunables,  Next: Language Features,  Prev: Internal Probes,  Up: Top

37 Tunables
***********

"Tunables" are a feature in the GNU C Library that allows application
authors and distribution maintainers to alter the runtime library
behavior to match their workload.  These are implemented as a set of
switches that may be modified in different ways.  The current default
method to do this is via the ‘GLIBC_TUNABLES’ environment variable by
setting it to a string of colon-separated NAME=VALUE pairs.  For
example, the following example enables malloc checking and sets the
malloc trim threshold to 128 bytes:

     GLIBC_TUNABLES=glibc.malloc.trim_threshold=128:glibc.malloc.check=3
     export GLIBC_TUNABLES

   Tunables are not part of the GNU C Library stable ABI, and they are
subject to change or removal across releases.  Additionally, the method
to modify tunable values may change between releases and across
distributions.  It is possible to implement multiple ‘frontends’ for the
tunables allowing distributions to choose their preferred method at
build time.

   Finally, the set of tunables available may vary between distributions
as the tunables feature allows distributions to add their own tunables
under their own namespace.

* Menu:

* Tunable names::  The structure of a tunable name
* Memory Allocation Tunables::  Tunables in the memory allocation subsystem
* Elision Tunables::  Tunables in elision subsystem
* POSIX Thread Tunables:: Tunables in the POSIX thread subsystem
* Hardware Capability Tunables::  Tunables that modify the hardware
				  capabilities seen by the GNU C Library


File: libc.info,  Node: Tunable names,  Next: Memory Allocation Tunables,  Up: Tunables

37.1 Tunable names
==================

A tunable name is split into three components, a top namespace, a
tunable namespace and the tunable name.  The top namespace for tunables
implemented in the GNU C Library is ‘glibc’.  Distributions that choose
to add custom tunables in their maintained versions of the GNU C Library
may choose to do so under their own top namespace.

   The tunable namespace is a logical grouping of tunables in a single
module.  This currently holds no special significance, although that may
change in the future.

   The tunable name is the actual name of the tunable.  It is possible
that different tunable namespaces may have tunables within them that
have the same name, likewise for top namespaces.  Hence, we only support
identification of tunables by their full name, i.e.  with the top
namespace, tunable namespace and tunable name, separated by periods.


File: libc.info,  Node: Memory Allocation Tunables,  Next: Elision Tunables,  Prev: Tunable names,  Up: Tunables

37.2 Memory Allocation Tunables
===============================

 -- Tunable namespace: glibc.malloc
     Memory allocation behavior can be modified by setting any of the
     following tunables in the ‘malloc’ namespace:

 -- Tunable: glibc.malloc.check
     This tunable supersedes the ‘MALLOC_CHECK_’ environment variable
     and is identical in features.

     Setting this tunable to a non-zero value enables a special (less
     efficient) memory allocator for the malloc family of functions that
     is designed to be tolerant against simple errors such as double
     calls of free with the same argument, or overruns of a single byte
     (off-by-one bugs).  Not all such errors can be protected against,
     however, and memory leaks can result.  Any detected heap corruption
     results in immediate termination of the process.

     Like ‘MALLOC_CHECK_’, ‘glibc.malloc.check’ has a problem in that it
     diverges from normal program behavior by writing to ‘stderr’, which
     could by exploited in SUID and SGID binaries.  Therefore,
     ‘glibc.malloc.check’ is disabled by default for SUID and SGID
     binaries.  This can be enabled again by the system administrator by
     adding a file ‘/etc/suid-debug’; the content of the file could be
     anything or even empty.

 -- Tunable: glibc.malloc.top_pad
     This tunable supersedes the ‘MALLOC_TOP_PAD_’ environment variable
     and is identical in features.

     This tunable determines the amount of extra memory in bytes to
     obtain from the system when any of the arenas need to be extended.
     It also specifies the number of bytes to retain when shrinking any
     of the arenas.  This provides the necessary hysteresis in heap size
     such that excessive amounts of system calls can be avoided.

     The default value of this tunable is ‘0’.

 -- Tunable: glibc.malloc.perturb
     This tunable supersedes the ‘MALLOC_PERTURB_’ environment variable
     and is identical in features.

     If set to a non-zero value, memory blocks are initialized with
     values depending on some low order bits of this tunable when they
     are allocated (except when allocated by calloc) and freed.  This
     can be used to debug the use of uninitialized or freed heap memory.
     Note that this option does not guarantee that the freed block will
     have any specific values.  It only guarantees that the content the
     block had before it was freed will be overwritten.

     The default value of this tunable is ‘0’.

 -- Tunable: glibc.malloc.mmap_threshold
     This tunable supersedes the ‘MALLOC_MMAP_THRESHOLD_’ environment
     variable and is identical in features.

     When this tunable is set, all chunks larger than this value in
     bytes are allocated outside the normal heap, using the ‘mmap’
     system call.  This way it is guaranteed that the memory for these
     chunks can be returned to the system on ‘free’.  Note that requests
     smaller than this threshold might still be allocated via ‘mmap’.

     If this tunable is not set, the default value is set to ‘131072’
     bytes and the threshold is adjusted dynamically to suit the
     allocation patterns of the program.  If the tunable is set, the
     dynamic adjustment is disabled and the value is set as static.

 -- Tunable: glibc.malloc.trim_threshold
     This tunable supersedes the ‘MALLOC_TRIM_THRESHOLD_’ environment
     variable and is identical in features.

     The value of this tunable is the minimum size (in bytes) of the
     top-most, releasable chunk in an arena that will trigger a system
     call in order to return memory to the system from that arena.

     If this tunable is not set, the default value is set as 128 KB and
     the threshold is adjusted dynamically to suit the allocation
     patterns of the program.  If the tunable is set, the dynamic
     adjustment is disabled and the value is set as static.

 -- Tunable: glibc.malloc.mmap_max
     This tunable supersedes the ‘MALLOC_MMAP_MAX_’ environment variable
     and is identical in features.

     The value of this tunable is maximum number of chunks to allocate
     with ‘mmap’.  Setting this to zero disables all use of ‘mmap’.

     The default value of this tunable is ‘65536’.

 -- Tunable: glibc.malloc.arena_test
     This tunable supersedes the ‘MALLOC_ARENA_TEST’ environment
     variable and is identical in features.

     The ‘glibc.malloc.arena_test’ tunable specifies the number of
     arenas that can be created before the test on the limit to the
     number of arenas is conducted.  The value is ignored if
     ‘glibc.malloc.arena_max’ is set.

     The default value of this tunable is 2 for 32-bit systems and 8 for
     64-bit systems.

 -- Tunable: glibc.malloc.arena_max
     This tunable supersedes the ‘MALLOC_ARENA_MAX’ environment variable
     and is identical in features.

     This tunable sets the number of arenas to use in a process
     regardless of the number of cores in the system.

     The default value of this tunable is ‘0’, meaning that the limit on
     the number of arenas is determined by the number of CPU cores
     online.  For 32-bit systems the limit is twice the number of cores
     online and on 64-bit systems, it is 8 times the number of cores
     online.

 -- Tunable: glibc.malloc.tcache_max
     The maximum size of a request (in bytes) which may be met via the
     per-thread cache.  The default (and maximum) value is 1032 bytes on
     64-bit systems and 516 bytes on 32-bit systems.

 -- Tunable: glibc.malloc.tcache_count
     The maximum number of chunks of each size to cache.  The default is
     7.  The upper limit is 65535.  If set to zero, the per-thread cache
     is effectively disabled.

     The approximate maximum overhead of the per-thread cache is thus
     equal to the number of bins times the chunk count in each bin times
     the size of each chunk.  With defaults, the approximate maximum
     overhead of the per-thread cache is approximately 236 KB on 64-bit
     systems and 118 KB on 32-bit systems.

 -- Tunable: glibc.malloc.tcache_unsorted_limit
     When the user requests memory and the request cannot be met via the
     per-thread cache, the arenas are used to meet the request.  At this
     time, additional chunks will be moved from existing arena lists to
     pre-fill the corresponding cache.  While copies from the fastbins,
     smallbins, and regular bins are bounded and predictable due to the
     bin sizes, copies from the unsorted bin are not bounded, and incur
     additional time penalties as they need to be sorted as they’re
     scanned.  To make scanning the unsorted list more predictable and
     bounded, the user may set this tunable to limit the number of
     chunks that are scanned from the unsorted list while searching for
     chunks to pre-fill the per-thread cache with.  The default, or when
     set to zero, is no limit.

 -- Tunable: glibc.malloc.mxfast
     One of the optimizations malloc uses is to maintain a series of
     “fast bins” that hold chunks up to a specific size.  The default
     and maximum size which may be held this way is 80 bytes on 32-bit
     systems or 160 bytes on 64-bit systems.  Applications which value
     size over speed may choose to reduce the size of requests which are
     serviced from fast bins with this tunable.  Note that the value
     specified includes malloc’s internal overhead, which is normally
     the size of one pointer, so add 4 on 32-bit systems or 8 on 64-bit
     systems to the size passed to ‘malloc’ for the largest bin size to
     enable.


File: libc.info,  Node: Elision Tunables,  Next: POSIX Thread Tunables,  Prev: Memory Allocation Tunables,  Up: Tunables

37.3 Elision Tunables
=====================

 -- Tunable namespace: glibc.elision
     Contended locks are usually slow and can lead to performance and
     scalability issues in multithread code.  Lock elision will use
     memory transactions to under certain conditions, to elide locks and
     improve performance.  Elision behavior can be modified by setting
     the following tunables in the ‘elision’ namespace:

 -- Tunable: glibc.elision.enable
     The ‘glibc.elision.enable’ tunable enables lock elision if the
     feature is supported by the hardware.  If elision is not supported
     by the hardware this tunable has no effect.

     Elision tunables are supported for 64-bit Intel, IBM POWER, and z
     System architectures.

 -- Tunable: glibc.elision.skip_lock_busy
     The ‘glibc.elision.skip_lock_busy’ tunable sets how many times to
     use a non-transactional lock after a transactional failure has
     occurred because the lock is already acquired.  Expressed in number
     of lock acquisition attempts.

     The default value of this tunable is ‘3’.

 -- Tunable: glibc.elision.skip_lock_internal_abort
     The ‘glibc.elision.skip_lock_internal_abort’ tunable sets how many
     times the thread should avoid using elision if a transaction
     aborted for any reason other than a different thread’s memory
     accesses.  Expressed in number of lock acquisition attempts.

     The default value of this tunable is ‘3’.

 -- Tunable: glibc.elision.skip_lock_after_retries
     The ‘glibc.elision.skip_lock_after_retries’ tunable sets how many
     times to try to elide a lock with transactions, that only failed
     due to a different thread’s memory accesses, before falling back to
     regular lock.  Expressed in number of lock elision attempts.

     This tunable is supported only on IBM POWER, and z System
     architectures.

     The default value of this tunable is ‘3’.

 -- Tunable: glibc.elision.tries
     The ‘glibc.elision.tries’ sets how many times to retry elision if
     there is chance for the transaction to finish execution e.g., it
     wasn’t aborted due to the lock being already acquired.  If elision
     is not supported by the hardware this tunable is set to ‘0’ to
     avoid retries.

     The default value of this tunable is ‘3’.

 -- Tunable: glibc.elision.skip_trylock_internal_abort
     The ‘glibc.elision.skip_trylock_internal_abort’ tunable sets how
     many times the thread should avoid trying the lock if a transaction
     aborted due to reasons other than a different thread’s memory
     accesses.  Expressed in number of try lock attempts.

     The default value of this tunable is ‘3’.


File: libc.info,  Node: POSIX Thread Tunables,  Next: Hardware Capability Tunables,  Prev: Elision Tunables,  Up: Tunables

37.4 POSIX Thread Tunables
==========================

 -- Tunable namespace: glibc.pthread
     The behavior of POSIX threads can be tuned to gain performance
     improvements according to specific hardware capabilities and
     workload characteristics by setting the following tunables in the
     ‘pthread’ namespace:

 -- Tunable: glibc.pthread.mutex_spin_count
     The ‘glibc.pthread.mutex_spin_count’ tunable sets the maximum
     number of times a thread should spin on the lock before calling
     into the kernel to block.  Adaptive spin is used for mutexes
     initialized with the ‘PTHREAD_MUTEX_ADAPTIVE_NP’ GNU extension.  It
     affects both ‘pthread_mutex_lock’ and ‘pthread_mutex_timedlock’.

     The thread spins until either the maximum spin count is reached or
     the lock is acquired.

     The default value of this tunable is ‘100’.


File: libc.info,  Node: Hardware Capability Tunables,  Prev: POSIX Thread Tunables,  Up: Tunables

37.5 Hardware Capability Tunables
=================================

 -- Tunable namespace: glibc.cpu
     Behavior of the GNU C Library can be tuned to assume specific
     hardware capabilities by setting the following tunables in the
     ‘cpu’ namespace:

 -- Tunable: glibc.cpu.hwcap_mask
     This tunable supersedes the ‘LD_HWCAP_MASK’ environment variable
     and is identical in features.

     The ‘AT_HWCAP’ key in the Auxiliary Vector specifies instruction
     set extensions available in the processor at runtime for some
     architectures.  The ‘glibc.cpu.hwcap_mask’ tunable allows the user
     to mask out those capabilities at runtime, thus disabling use of
     those extensions.

 -- Tunable: glibc.cpu.hwcaps
     The ‘glibc.cpu.hwcaps=-xxx,yyy,-zzz...’ tunable allows the user to
     enable CPU/ARCH feature ‘yyy’, disable CPU/ARCH feature ‘xxx’ and
     ‘zzz’ where the feature name is case-sensitive and has to match the
     ones in ‘sysdeps/x86/cpu-features.h’.

     This tunable is specific to i386 and x86-64.

 -- Tunable: glibc.cpu.cached_memopt
     The ‘glibc.cpu.cached_memopt=[0|1]’ tunable allows the user to
     enable optimizations recommended for cacheable memory.  If set to
     ‘1’, the GNU C Library assumes that the process memory image
     consists of cacheable (non-device) memory only.  The default, ‘0’,
     indicates that the process may use device memory.

     This tunable is specific to powerpc, powerpc64 and powerpc64le.

 -- Tunable: glibc.cpu.name
     The ‘glibc.cpu.name=xxx’ tunable allows the user to tell the GNU C
     Library to assume that the CPU is ‘xxx’ where xxx may have one of
     these values: ‘generic’, ‘falkor’, ‘thunderxt88’, ‘thunderx2t99’,
     ‘thunderx2t99p1’, ‘ares’, ‘emag’.

     This tunable is specific to aarch64.

 -- Tunable: glibc.cpu.x86_data_cache_size
     The ‘glibc.cpu.x86_data_cache_size’ tunable allows the user to set
     data cache size in bytes for use in memory and string routines.

     This tunable is specific to i386 and x86-64.

 -- Tunable: glibc.cpu.x86_shared_cache_size
     The ‘glibc.cpu.x86_shared_cache_size’ tunable allows the user to
     set shared cache size in bytes for use in memory and string
     routines.

 -- Tunable: glibc.cpu.x86_non_temporal_threshold
     The ‘glibc.cpu.x86_non_temporal_threshold’ tunable allows the user
     to set threshold in bytes for non temporal store.

     This tunable is specific to i386 and x86-64.

 -- Tunable: glibc.cpu.x86_ibt
     The ‘glibc.cpu.x86_ibt’ tunable allows the user to control how
     indirect branch tracking (IBT) should be enabled.  Accepted values
     are ‘on’, ‘off’, and ‘permissive’.  ‘on’ always turns on IBT
     regardless of whether IBT is enabled in the executable and its
     dependent shared libraries.  ‘off’ always turns off IBT regardless
     of whether IBT is enabled in the executable and its dependent
     shared libraries.  ‘permissive’ is the same as the default which
     disables IBT on non-CET executables and shared libraries.

     This tunable is specific to i386 and x86-64.

 -- Tunable: glibc.cpu.x86_shstk
     The ‘glibc.cpu.x86_shstk’ tunable allows the user to control how
     the shadow stack (SHSTK) should be enabled.  Accepted values are
     ‘on’, ‘off’, and ‘permissive’.  ‘on’ always turns on SHSTK
     regardless of whether SHSTK is enabled in the executable and its
     dependent shared libraries.  ‘off’ always turns off SHSTK
     regardless of whether SHSTK is enabled in the executable and its
     dependent shared libraries.  ‘permissive’ changes how dlopen works
     on non-CET shared libraries.  By default, when SHSTK is enabled,
     dlopening a non-CET shared library returns an error.  With
     ‘permissive’, it turns off SHSTK instead.

     This tunable is specific to i386 and x86-64.


File: libc.info,  Node: Language Features,  Next: Library Summary,  Prev: Tunables,  Up: Top

Appendix A C Language Facilities in the Library
***********************************************

Some of the facilities implemented by the C library really should be
thought of as parts of the C language itself.  These facilities ought to
be documented in the C Language Manual, not in the library manual; but
since we don’t have the language manual yet, and documentation for these
features has been written, we are publishing it here.

* Menu:

* Consistency Checking::        Using ‘assert’ to abort if
				 something “impossible” happens.
* Variadic Functions::          Defining functions with varying numbers
                                 of args.
* Null Pointer Constant::       The macro ‘NULL’.
* Important Data Types::        Data types for object sizes.
* Data Type Measurements::      Parameters of data type representations.


File: libc.info,  Node: Consistency Checking,  Next: Variadic Functions,  Up: Language Features

A.1 Explicitly Checking Internal Consistency
============================================

When you’re writing a program, it’s often a good idea to put in checks
at strategic places for “impossible” errors or violations of basic
assumptions.  These kinds of checks are helpful in debugging problems
with the interfaces between different parts of the program, for example.

   The ‘assert’ macro, defined in the header file ‘assert.h’, provides a
convenient way to abort the program while printing a message about where
in the program the error was detected.

   Once you think your program is debugged, you can disable the error
checks performed by the ‘assert’ macro by recompiling with the macro
‘NDEBUG’ defined.  This means you don’t actually have to change the
program source code to disable these checks.

   But disabling these consistency checks is undesirable unless they
make the program significantly slower.  All else being equal, more error
checking is good no matter who is running the program.  A wise user
would rather have a program crash, visibly, than have it return nonsense
without indicating anything might be wrong.

 -- Macro: void assert (int EXPRESSION)

     Preliminary: | MT-Safe | AS-Unsafe heap corrupt | AC-Unsafe mem
     lock corrupt | *Note POSIX Safety Concepts::.

     Verify the programmer’s belief that EXPRESSION is nonzero at this
     point in the program.

     If ‘NDEBUG’ is not defined, ‘assert’ tests the value of EXPRESSION.
     If it is false (zero), ‘assert’ aborts the program (*note Aborting
     a Program::) after printing a message of the form:

          FILE:LINENUM: FUNCTION: Assertion `EXPRESSION' failed.

     on the standard error stream ‘stderr’ (*note Standard Streams::).
     The filename and line number are taken from the C preprocessor
     macros ‘__FILE__’ and ‘__LINE__’ and specify where the call to
     ‘assert’ was made.  When using the GNU C compiler, the name of the
     function which calls ‘assert’ is taken from the built-in variable
     ‘__PRETTY_FUNCTION__’; with older compilers, the function name and
     following colon are omitted.

     If the preprocessor macro ‘NDEBUG’ is defined before ‘assert.h’ is
     included, the ‘assert’ macro is defined to do absolutely nothing.

     *Warning:* Even the argument expression EXPRESSION is not evaluated
     if ‘NDEBUG’ is in effect.  So never use ‘assert’ with arguments
     that involve side effects.  For example, ‘assert (++i > 0);’ is a
     bad idea, because ‘i’ will not be incremented if ‘NDEBUG’ is
     defined.

   Sometimes the “impossible” condition you want to check for is an
error return from an operating system function.  Then it is useful to
display not only where the program crashes, but also what error was
returned.  The ‘assert_perror’ macro makes this easy.

 -- Macro: void assert_perror (int ERRNUM)

     Preliminary: | MT-Safe | AS-Unsafe heap corrupt | AC-Unsafe mem
     lock corrupt | *Note POSIX Safety Concepts::.

     Similar to ‘assert’, but verifies that ERRNUM is zero.

     If ‘NDEBUG’ is not defined, ‘assert_perror’ tests the value of
     ERRNUM.  If it is nonzero, ‘assert_perror’ aborts the program after
     printing a message of the form:

          FILE:LINENUM: FUNCTION: ERROR TEXT

     on the standard error stream.  The file name, line number, and
     function name are as for ‘assert’.  The error text is the result of
     ‘strerror (ERRNUM)’.  *Note Error Messages::.

     Like ‘assert’, if ‘NDEBUG’ is defined before ‘assert.h’ is
     included, the ‘assert_perror’ macro does absolutely nothing.  It
     does not evaluate the argument, so ERRNUM should not have any side
     effects.  It is best for ERRNUM to be just a simple variable
     reference; often it will be ‘errno’.

     This macro is a GNU extension.

   *Usage note:* The ‘assert’ facility is designed for detecting
_internal inconsistency_; it is not suitable for reporting invalid input
or improper usage by the _user_ of the program.

   The information in the diagnostic messages printed by the ‘assert’
and ‘assert_perror’ macro is intended to help you, the programmer, track
down the cause of a bug, but is not really useful for telling a user of
your program why his or her input was invalid or why a command could not
be carried out.  What’s more, your program should not abort when given
invalid input, as ‘assert’ would do—it should exit with nonzero status
(*note Exit Status::) after printing its error messages, or perhaps read
another command or move on to the next input file.

   *Note Error Messages::, for information on printing error messages
for problems that _do not_ represent bugs in the program.


File: libc.info,  Node: Variadic Functions,  Next: Null Pointer Constant,  Prev: Consistency Checking,  Up: Language Features

A.2 Variadic Functions
======================

ISO C defines a syntax for declaring a function to take a variable
number or type of arguments.  (Such functions are referred to as
"varargs functions" or "variadic functions".)  However, the language
itself provides no mechanism for such functions to access their
non-required arguments; instead, you use the variable arguments macros
defined in ‘stdarg.h’.

   This section describes how to declare variadic functions, how to
write them, and how to call them properly.

   *Compatibility Note:* Many older C dialects provide a similar, but
incompatible, mechanism for defining functions with variable numbers of
arguments, using ‘varargs.h’.

* Menu:

* Why Variadic::                Reasons for making functions take
                                 variable arguments.
* How Variadic::                How to define and call variadic functions.
* Variadic Example::            A complete example.


File: libc.info,  Node: Why Variadic,  Next: How Variadic,  Up: Variadic Functions

A.2.1 Why Variadic Functions are Used
-------------------------------------

Ordinary C functions take a fixed number of arguments.  When you define
a function, you specify the data type for each argument.  Every call to
the function should supply the expected number of arguments, with types
that can be converted to the specified ones.  Thus, if the function
‘foo’ is declared with ‘int foo (int, char *);’ then you must call it
with two arguments, a number (any kind will do) and a string pointer.

   But some functions perform operations that can meaningfully accept an
unlimited number of arguments.

   In some cases a function can handle any number of values by operating
on all of them as a block.  For example, consider a function that
allocates a one-dimensional array with ‘malloc’ to hold a specified set
of values.  This operation makes sense for any number of values, as long
as the length of the array corresponds to that number.  Without
facilities for variable arguments, you would have to define a separate
function for each possible array size.

   The library function ‘printf’ (*note Formatted Output::) is an
example of another class of function where variable arguments are
useful.  This function prints its arguments (which can vary in type as
well as number) under the control of a format template string.

   These are good reasons to define a "variadic" function which can
handle as many arguments as the caller chooses to pass.

   Some functions such as ‘open’ take a fixed set of arguments, but
occasionally ignore the last few.  Strict adherence to ISO C requires
these functions to be defined as variadic; in practice, however, the GNU
C compiler and most other C compilers let you define such a function to
take a fixed set of arguments—the most it can ever use—and then only
_declare_ the function as variadic (or not declare its arguments at
all!).


File: libc.info,  Node: How Variadic,  Next: Variadic Example,  Prev: Why Variadic,  Up: Variadic Functions

A.2.2 How Variadic Functions are Defined and Used
-------------------------------------------------

Defining and using a variadic function involves three steps:

   • _Define_ the function as variadic, using an ellipsis (‘…’) in the
     argument list, and using special macros to access the variable
     arguments.  *Note Receiving Arguments::.

   • _Declare_ the function as variadic, using a prototype with an
     ellipsis (‘…’), in all the files which call it.  *Note Variadic
     Prototypes::.

   • _Call_ the function by writing the fixed arguments followed by the
     additional variable arguments.  *Note Calling Variadics::.

* Menu:

* Variadic Prototypes::  How to make a prototype for a function
			  with variable arguments.
* Receiving Arguments::  Steps you must follow to access the
			  optional argument values.
* How Many Arguments::   How to decide whether there are more arguments.
* Calling Variadics::    Things you need to know about calling
			  variable arguments functions.
* Argument Macros::      Detailed specification of the macros
        		  for accessing variable arguments.


File: libc.info,  Node: Variadic Prototypes,  Next: Receiving Arguments,  Up: How Variadic

A.2.2.1 Syntax for Variable Arguments
.....................................

A function that accepts a variable number of arguments must be declared
with a prototype that says so.  You write the fixed arguments as usual,
and then tack on ‘…’ to indicate the possibility of additional
arguments.  The syntax of ISO C requires at least one fixed argument
before the ‘…’.  For example,

     int
     func (const char *a, int b, …)
     {
       …
     }

defines a function ‘func’ which returns an ‘int’ and takes two required
arguments, a ‘const char *’ and an ‘int’.  These are followed by any
number of anonymous arguments.

   *Portability note:* For some C compilers, the last required argument
must not be declared ‘register’ in the function definition.
Furthermore, this argument’s type must be "self-promoting": that is, the
default promotions must not change its type.  This rules out array and
function types, as well as ‘float’, ‘char’ (whether signed or not) and ‘short int’
(whether signed or not).  This is actually an ISO C requirement.


File: libc.info,  Node: Receiving Arguments,  Next: How Many Arguments,  Prev: Variadic Prototypes,  Up: How Variadic

A.2.2.2 Receiving the Argument Values
.....................................

Ordinary fixed arguments have individual names, and you can use these
names to access their values.  But optional arguments have no
names—nothing but ‘…’.  How can you access them?

   The only way to access them is sequentially, in the order they were
written, and you must use special macros from ‘stdarg.h’ in the
following three step process:

  1. You initialize an argument pointer variable of type ‘va_list’ using
     ‘va_start’.  The argument pointer when initialized points to the
     first optional argument.

  2. You access the optional arguments by successive calls to ‘va_arg’.
     The first call to ‘va_arg’ gives you the first optional argument,
     the next call gives you the second, and so on.

     You can stop at any time if you wish to ignore any remaining
     optional arguments.  It is perfectly all right for a function to
     access fewer arguments than were supplied in the call, but you will
     get garbage values if you try to access too many arguments.

  3. You indicate that you are finished with the argument pointer
     variable by calling ‘va_end’.

     (In practice, with most C compilers, calling ‘va_end’ does nothing.
     This is always true in the GNU C compiler.  But you might as well
     call ‘va_end’ just in case your program is someday compiled with a
     peculiar compiler.)

   *Note Argument Macros::, for the full definitions of ‘va_start’,
‘va_arg’ and ‘va_end’.

   Steps 1 and 3 must be performed in the function that accepts the
optional arguments.  However, you can pass the ‘va_list’ variable as an
argument to another function and perform all or part of step 2 there.

   You can perform the entire sequence of three steps multiple times
within a single function invocation.  If you want to ignore the optional
arguments, you can do these steps zero times.

   You can have more than one argument pointer variable if you like.
You can initialize each variable with ‘va_start’ when you wish, and then
you can fetch arguments with each argument pointer as you wish.  Each
argument pointer variable will sequence through the same set of argument
values, but at its own pace.

   *Portability note:* With some compilers, once you pass an argument
pointer value to a subroutine, you must not keep using the same argument
pointer value after that subroutine returns.  For full portability, you
should just pass it to ‘va_end’.  This is actually an ISO C requirement,
but most ANSI C compilers work happily regardless.


File: libc.info,  Node: How Many Arguments,  Next: Calling Variadics,  Prev: Receiving Arguments,  Up: How Variadic

A.2.2.3 How Many Arguments Were Supplied
........................................

There is no general way for a function to determine the number and type
of the optional arguments it was called with.  So whoever designs the
function typically designs a convention for the caller to specify the
number and type of arguments.  It is up to you to define an appropriate
calling convention for each variadic function, and write all calls
accordingly.

   One kind of calling convention is to pass the number of optional
arguments as one of the fixed arguments.  This convention works provided
all of the optional arguments are of the same type.

   A similar alternative is to have one of the required arguments be a
bit mask, with a bit for each possible purpose for which an optional
argument might be supplied.  You would test the bits in a predefined
sequence; if the bit is set, fetch the value of the next argument,
otherwise use a default value.

   A required argument can be used as a pattern to specify both the
number and types of the optional arguments.  The format string argument
to ‘printf’ is one example of this (*note Formatted Output Functions::).

   Another possibility is to pass an “end marker” value as the last
optional argument.  For example, for a function that manipulates an
arbitrary number of pointer arguments, a null pointer might indicate the
end of the argument list.  (This assumes that a null pointer isn’t
otherwise meaningful to the function.)  The ‘execl’ function works in
just this way; see *note Executing a File::.


File: libc.info,  Node: Calling Variadics,  Next: Argument Macros,  Prev: How Many Arguments,  Up: How Variadic

A.2.2.4 Calling Variadic Functions
..................................

You don’t have to do anything special to call a variadic function.  Just
put the arguments (required arguments, followed by optional ones) inside
parentheses, separated by commas, as usual.  But you must declare the
function with a prototype and know how the argument values are
converted.

   In principle, functions that are _defined_ to be variadic must also
be _declared_ to be variadic using a function prototype whenever you
call them.  (*Note Variadic Prototypes::, for how.)  This is because
some C compilers use a different calling convention to pass the same set
of argument values to a function depending on whether that function
takes variable arguments or fixed arguments.

   In practice, the GNU C compiler always passes a given set of argument
types in the same way regardless of whether they are optional or
required.  So, as long as the argument types are self-promoting, you can
safely omit declaring them.  Usually it is a good idea to declare the
argument types for variadic functions, and indeed for all functions.
But there are a few functions which it is extremely convenient not to
have to declare as variadic—for example, ‘open’ and ‘printf’.

   Since the prototype doesn’t specify types for optional arguments, in
a call to a variadic function the "default argument promotions" are
performed on the optional argument values.  This means the objects of
type ‘char’ or ‘short int’ (whether signed or not) are promoted to
either ‘int’ or ‘unsigned int’, as appropriate; and that objects of type
‘float’ are promoted to type ‘double’.  So, if the caller passes a
‘char’ as an optional argument, it is promoted to an ‘int’, and the
function can access it with ‘va_arg (AP, int)’.

   Conversion of the required arguments is controlled by the function
prototype in the usual way: the argument expression is converted to the
declared argument type as if it were being assigned to a variable of
that type.


File: libc.info,  Node: Argument Macros,  Prev: Calling Variadics,  Up: How Variadic

A.2.2.5 Argument Access Macros
..............................

Here are descriptions of the macros used to retrieve variable arguments.
These macros are defined in the header file ‘stdarg.h’.

 -- Data Type: va_list

     The type ‘va_list’ is used for argument pointer variables.

 -- Macro: void va_start (va_list AP, LAST-REQUIRED)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This macro initializes the argument pointer variable AP to point to
     the first of the optional arguments of the current function;
     LAST-REQUIRED must be the last required argument to the function.

 -- Macro: TYPE va_arg (va_list AP, TYPE)

     Preliminary: | MT-Safe race:ap | AS-Safe | AC-Unsafe corrupt |
     *Note POSIX Safety Concepts::.

     The ‘va_arg’ macro returns the value of the next optional argument,
     and modifies the value of AP to point to the subsequent argument.
     Thus, successive uses of ‘va_arg’ return successive optional
     arguments.

     The type of the value returned by ‘va_arg’ is TYPE as specified in
     the call.  TYPE must be a self-promoting type (not ‘char’ or ‘short
     int’ or ‘float’) that matches the type of the actual argument.

 -- Macro: void va_end (va_list AP)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This ends the use of AP.  After a ‘va_end’ call, further ‘va_arg’
     calls with the same AP may not work.  You should invoke ‘va_end’
     before returning from the function in which ‘va_start’ was invoked
     with the same AP argument.

     In the GNU C Library, ‘va_end’ does nothing, and you need not ever
     use it except for reasons of portability.

   Sometimes it is necessary to parse the list of parameters more than
once or one wants to remember a certain position in the parameter list.
To do this, one will have to make a copy of the current value of the
argument.  But ‘va_list’ is an opaque type and one cannot necessarily
assign the value of one variable of type ‘va_list’ to another variable
of the same type.

 -- Macro: void va_copy (va_list DEST, va_list SRC)
 -- Macro: void __va_copy (va_list DEST, va_list SRC)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     The ‘va_copy’ macro allows copying of objects of type ‘va_list’
     even if this is not an integral type.  The argument pointer in DEST
     is initialized to point to the same argument as the pointer in SRC.

     ‘va_copy’ was added in ISO C99.  When building for strict
     conformance to ISO C90 (‘gcc -std=c90’), it is not available.  GCC
     provides ‘__va_copy’, as an extension, in any standards mode;
     before GCC 3.0, it was the only macro for this functionality.

     These macros are no longer provided by the GNU C Library, but
     rather by the compiler.

   If you want to use ‘va_copy’ and be portable to pre-C99 systems, you
should always be prepared for the possibility that this macro will not
be available.  On architectures where a simple assignment is invalid,
hopefully ‘va_copy’ _will_ be available, so one should always write
something like this if concerned about pre-C99 portability:

     {
       va_list ap, save;
       …
     #ifdef va_copy
       va_copy (save, ap);
     #else
       save = ap;
     #endif
       …
     }


File: libc.info,  Node: Variadic Example,  Prev: How Variadic,  Up: Variadic Functions

A.2.3 Example of a Variadic Function
------------------------------------

Here is a complete sample function that accepts a variable number of
arguments.  The first argument to the function is the count of remaining
arguments, which are added up and the result returned.  While trivial,
this function is sufficient to illustrate how to use the variable
arguments facility.


     #include <stdarg.h>
     #include <stdio.h>

     int
     add_em_up (int count,...)
     {
       va_list ap;
       int i, sum;

       va_start (ap, count);         /* Initialize the argument list. */

       sum = 0;
       for (i = 0; i < count; i++)
         sum += va_arg (ap, int);    /* Get the next argument value. */

       va_end (ap);                  /* Clean up. */
       return sum;
     }

     int
     main (void)
     {
       /* This call prints 16. */
       printf ("%d\n", add_em_up (3, 5, 5, 6));

       /* This call prints 55. */
       printf ("%d\n", add_em_up (10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

       return 0;
     }


File: libc.info,  Node: Null Pointer Constant,  Next: Important Data Types,  Prev: Variadic Functions,  Up: Language Features

A.3 Null Pointer Constant
=========================

The null pointer constant is guaranteed not to point to any real object.
You can assign it to any pointer variable since it has type ‘void *’.
The preferred way to write a null pointer constant is with ‘NULL’.

 -- Macro: void * NULL

     This is a null pointer constant.

   You can also use ‘0’ or ‘(void *)0’ as a null pointer constant, but
using ‘NULL’ is cleaner because it makes the purpose of the constant
more evident.

   If you use the null pointer constant as a function argument, then for
complete portability you should make sure that the function has a
prototype declaration.  Otherwise, if the target machine has two
different pointer representations, the compiler won’t know which
representation to use for that argument.  You can avoid the problem by
explicitly casting the constant to the proper pointer type, but we
recommend instead adding a prototype for the function you are calling.


File: libc.info,  Node: Important Data Types,  Next: Data Type Measurements,  Prev: Null Pointer Constant,  Up: Language Features

A.4 Important Data Types
========================

The result of subtracting two pointers in C is always an integer, but
the precise data type varies from C compiler to C compiler.  Likewise,
the data type of the result of ‘sizeof’ also varies between compilers.
ISO C defines standard aliases for these two types, so you can refer to
them in a portable fashion.  They are defined in the header file
‘stddef.h’.

 -- Data Type: ptrdiff_t

     This is the signed integer type of the result of subtracting two
     pointers.  For example, with the declaration ‘char *p1, *p2;’, the
     expression ‘p2 - p1’ is of type ‘ptrdiff_t’.  This will probably be
     one of the standard signed integer types (‘short int’, ‘int’ or
     ‘long int’), but might be a nonstandard type that exists only for
     this purpose.

 -- Data Type: size_t

     This is an unsigned integer type used to represent the sizes of
     objects.  The result of the ‘sizeof’ operator is of this type, and
     functions such as ‘malloc’ (*note Unconstrained Allocation::) and
     ‘memcpy’ (*note Copying Strings and Arrays::) accept arguments of
     this type to specify object sizes.  On systems using the GNU C
     Library, this will be ‘unsigned int’ or ‘unsigned long int’.

     *Usage Note:* ‘size_t’ is the preferred way to declare any
     arguments or variables that hold the size of an object.

   *Compatibility Note:* Implementations of C before the advent of ISO C
generally used ‘unsigned int’ for representing object sizes and ‘int’
for pointer subtraction results.  They did not necessarily define either
‘size_t’ or ‘ptrdiff_t’.  Unix systems did define ‘size_t’, in
‘sys/types.h’, but the definition was usually a signed type.


File: libc.info,  Node: Data Type Measurements,  Prev: Important Data Types,  Up: Language Features

A.5 Data Type Measurements
==========================

Most of the time, if you choose the proper C data type for each object
in your program, you need not be concerned with just how it is
represented or how many bits it uses.  When you do need such
information, the C language itself does not provide a way to get it.
The header files ‘limits.h’ and ‘float.h’ contain macros which give you
this information in full detail.

* Menu:

* Width of Type::           How many bits does an integer type hold?
* Range of Type::           What are the largest and smallest values
			     that an integer type can hold?
* Floating Type Macros::    Parameters that measure the floating point types.
* Structure Measurement::   Getting measurements on structure types.


File: libc.info,  Node: Width of Type,  Next: Range of Type,  Up: Data Type Measurements

A.5.1 Width of an Integer Type
------------------------------

TS 18661-1:2014 defines macros for the width of integer types (the
number of value and sign bits).  One benefit of these macros is they can
be used in ‘#if’ preprocessor directives, whereas ‘sizeof’ cannot.  The
following macros are defined in ‘limits.h’.

‘CHAR_WIDTH’
‘SCHAR_WIDTH’
‘UCHAR_WIDTH’
‘SHRT_WIDTH’
‘USHRT_WIDTH’
‘INT_WIDTH’
‘UINT_WIDTH’
‘LONG_WIDTH’
‘ULONG_WIDTH’
‘LLONG_WIDTH’
‘ULLONG_WIDTH’

     These are the widths of the types ‘char’, ‘signed char’, ‘unsigned
     char’, ‘short int’, ‘unsigned short int’, ‘int’, ‘unsigned int’,
     ‘long int’, ‘unsigned long int’, ‘long long int’ and ‘unsigned long
     long int’, respectively.

   Further such macros are defined in ‘stdint.h’.  Apart from those for
types specified by width (*note Integers::), the following are defined:

‘INTPTR_WIDTH’
‘UINTPTR_WIDTH’
‘PTRDIFF_WIDTH’
‘SIG_ATOMIC_WIDTH’
‘SIZE_WIDTH’
‘WCHAR_WIDTH’
‘WINT_WIDTH’

     These are the widths of the types ‘intptr_t’, ‘uintptr_t’,
     ‘ptrdiff_t’, ‘sig_atomic_t’, ‘size_t’, ‘wchar_t’ and ‘wint_t’,
     respectively.

   A common reason that a program needs to know how many bits are in an
integer type is for using an array of ‘unsigned long int’ as a bit
vector.  You can access the bit at index N with:

     vector[N / ULONG_WIDTH] & (1UL << (N % ULONG_WIDTH))

   Before ‘ULONG_WIDTH’ was a part of the C language, ‘CHAR_BIT’ was
used to compute the number of bits in an integer data type.

 -- Macro: int CHAR_BIT

     This is the number of bits in a ‘char’.  POSIX.1-2001 requires this
     to be 8.

   The number of bits in any data type TYPE can be computed like this:

     sizeof (TYPE) * CHAR_BIT

   That expression includes padding bits as well as value and sign bits.
On all systems supported by the GNU C Library, standard integer types
other than ‘_Bool’ do not have any padding bits.

   *Portability Note:* One cannot actually easily compute the number of
usable bits in a portable manner.


File: libc.info,  Node: Range of Type,  Next: Floating Type Macros,  Prev: Width of Type,  Up: Data Type Measurements

A.5.2 Range of an Integer Type
------------------------------

Suppose you need to store an integer value which can range from zero to
one million.  Which is the smallest type you can use?  There is no
general rule; it depends on the C compiler and target machine.  You can
use the ‘MIN’ and ‘MAX’ macros in ‘limits.h’ to determine which type
will work.

   Each signed integer type has a pair of macros which give the smallest
and largest values that it can hold.  Each unsigned integer type has one
such macro, for the maximum value; the minimum value is, of course,
zero.

   The values of these macros are all integer constant expressions.  The
‘MAX’ and ‘MIN’ macros for ‘char’ and ‘short int’ types have values of
type ‘int’.  The ‘MAX’ and ‘MIN’ macros for the other types have values
of the same type described by the macro—thus, ‘ULONG_MAX’ has type
‘unsigned long int’.

‘SCHAR_MIN’

     This is the minimum value that can be represented by a
     ‘signed char’.

‘SCHAR_MAX’
‘UCHAR_MAX’

     These are the maximum values that can be represented by a ‘signed char’
     and ‘unsigned char’, respectively.

‘CHAR_MIN’

     This is the minimum value that can be represented by a ‘char’.
     It’s equal to ‘SCHAR_MIN’ if ‘char’ is signed, or zero otherwise.

‘CHAR_MAX’

     This is the maximum value that can be represented by a ‘char’.
     It’s equal to ‘SCHAR_MAX’ if ‘char’ is signed, or ‘UCHAR_MAX’
     otherwise.

‘SHRT_MIN’

     This is the minimum value that can be represented by a
     ‘signed short int’.  On most machines that the GNU C Library runs
     on, ‘short’ integers are 16-bit quantities.

‘SHRT_MAX’
‘USHRT_MAX’

     These are the maximum values that can be represented by a ‘signed short int’
     and ‘unsigned short int’, respectively.

‘INT_MIN’

     This is the minimum value that can be represented by a
     ‘signed int’.  On most machines that the GNU C Library runs on, an
     ‘int’ is a 32-bit quantity.

‘INT_MAX’
‘UINT_MAX’

     These are the maximum values that can be represented by,
     respectively, the type ‘signed int’ and the type ‘unsigned int’.

‘LONG_MIN’

     This is the minimum value that can be represented by a
     ‘signed long int’.  On most machines that the GNU C Library runs
     on, ‘long’ integers are 32-bit quantities, the same size as ‘int’.

‘LONG_MAX’
‘ULONG_MAX’

     These are the maximum values that can be represented by a ‘signed long int’
     and ‘unsigned long int’, respectively.

‘LLONG_MIN’

     This is the minimum value that can be represented by a
     ‘signed long long int’.  On most machines that the GNU C Library
     runs on, ‘long long’ integers are 64-bit quantities.

‘LLONG_MAX’
‘ULLONG_MAX’

     These are the maximum values that can be represented by a ‘signed
     long long int’ and ‘unsigned long long int’, respectively.

‘LONG_LONG_MIN’
‘LONG_LONG_MAX’
‘ULONG_LONG_MAX’

     These are obsolete names for ‘LLONG_MIN’, ‘LLONG_MAX’, and
     ‘ULLONG_MAX’.  They are only available if ‘_GNU_SOURCE’ is defined
     (*note Feature Test Macros::).  In GCC versions prior to 3.0, these
     were the only names available.

‘WCHAR_MAX’

     This is the maximum value that can be represented by a ‘wchar_t’.
     *Note Extended Char Intro::.

   The header file ‘limits.h’ also defines some additional constants
that parameterize various operating system and file system limits.
These constants are described in *note System Configuration::.


File: libc.info,  Node: Floating Type Macros,  Next: Structure Measurement,  Prev: Range of Type,  Up: Data Type Measurements

A.5.3 Floating Type Macros
--------------------------

The specific representation of floating point numbers varies from
machine to machine.  Because floating point numbers are represented
internally as approximate quantities, algorithms for manipulating
floating point data often need to take account of the precise details of
the machine’s floating point representation.

   Some of the functions in the C library itself need this information;
for example, the algorithms for printing and reading floating point
numbers (*note I/O on Streams::) and for calculating trigonometric and
irrational functions (*note Mathematics::) use it to avoid round-off
error and loss of accuracy.  User programs that implement numerical
analysis techniques also often need this information in order to
minimize or compute error bounds.

   The header file ‘float.h’ describes the format used by your machine.

* Menu:

* Floating Point Concepts::     Definitions of terminology.
* Floating Point Parameters::   Details of specific macros.
* IEEE Floating Point::         The measurements for one common
                                 representation.


File: libc.info,  Node: Floating Point Concepts,  Next: Floating Point Parameters,  Up: Floating Type Macros

A.5.3.1 Floating Point Representation Concepts
..............................................

This section introduces the terminology for describing floating point
representations.

   You are probably already familiar with most of these concepts in
terms of scientific or exponential notation for floating point numbers.
For example, the number ‘123456.0’ could be expressed in exponential
notation as ‘1.23456e+05’, a shorthand notation indicating that the
mantissa ‘1.23456’ is multiplied by the base ‘10’ raised to power ‘5’.

   More formally, the internal representation of a floating point number
can be characterized in terms of the following parameters:

   • The "sign" is either ‘-1’ or ‘1’.

   • The "base" or "radix" for exponentiation, an integer greater than
     ‘1’.  This is a constant for a particular representation.

   • The "exponent" to which the base is raised.  The upper and lower
     bounds of the exponent value are constants for a particular
     representation.

     Sometimes, in the actual bits representing the floating point
     number, the exponent is "biased" by adding a constant to it, to
     make it always be represented as an unsigned quantity.  This is
     only important if you have some reason to pick apart the bit fields
     making up the floating point number by hand, which is something for
     which the GNU C Library provides no support.  So this is ignored in
     the discussion that follows.

   • The "mantissa" or "significand" is an unsigned integer which is a
     part of each floating point number.

   • The "precision" of the mantissa.  If the base of the representation
     is B, then the precision is the number of base-B digits in the
     mantissa.  This is a constant for a particular representation.

     Many floating point representations have an implicit "hidden bit"
     in the mantissa.  This is a bit which is present virtually in the
     mantissa, but not stored in memory because its value is always 1 in
     a normalized number.  The precision figure (see above) includes any
     hidden bits.

     Again, the GNU C Library provides no facilities for dealing with
     such low-level aspects of the representation.

   The mantissa of a floating point number represents an implicit
fraction whose denominator is the base raised to the power of the
precision.  Since the largest representable mantissa is one less than
this denominator, the value of the fraction is always strictly less than
‘1’.  The mathematical value of a floating point number is then the
product of this fraction, the sign, and the base raised to the exponent.

   We say that the floating point number is "normalized" if the fraction
is at least ‘1/B’, where B is the base.  In other words, the mantissa
would be too large to fit if it were multiplied by the base.
Non-normalized numbers are sometimes called "denormal"; they contain
less precision than the representation normally can hold.

   If the number is not normalized, then you can subtract ‘1’ from the
exponent while multiplying the mantissa by the base, and get another
floating point number with the same value.  "Normalization" consists of
doing this repeatedly until the number is normalized.  Two distinct
normalized floating point numbers cannot be equal in value.

   (There is an exception to this rule: if the mantissa is zero, it is
considered normalized.  Another exception happens on certain machines
where the exponent is as small as the representation can hold.  Then it
is impossible to subtract ‘1’ from the exponent, so a number may be
normalized even if its fraction is less than ‘1/B’.)


File: libc.info,  Node: Floating Point Parameters,  Next: IEEE Floating Point,  Prev: Floating Point Concepts,  Up: Floating Type Macros

A.5.3.2 Floating Point Parameters
.................................

These macro definitions can be accessed by including the header file
‘float.h’ in your program.

   Macro names starting with ‘FLT_’ refer to the ‘float’ type, while
names beginning with ‘DBL_’ refer to the ‘double’ type and names
beginning with ‘LDBL_’ refer to the ‘long double’ type.  (If GCC does
not support ‘long double’ as a distinct data type on a target machine
then the values for the ‘LDBL_’ constants are equal to the corresponding
constants for the ‘double’ type.)

   Of these macros, only ‘FLT_RADIX’ is guaranteed to be a constant
expression.  The other macros listed here cannot be reliably used in
places that require constant expressions, such as ‘#if’ preprocessing
directives or in the dimensions of static arrays.

   Although the ISO C standard specifies minimum and maximum values for
most of these parameters, the GNU C implementation uses whatever values
describe the floating point representation of the target machine.  So in
principle GNU C actually satisfies the ISO C requirements only if the
target machine is suitable.  In practice, all the machines currently
supported are suitable.

‘FLT_ROUNDS’

     This value characterizes the rounding mode for floating point
     addition.  The following values indicate standard rounding modes:

     ‘-1’
          The mode is indeterminable.
     ‘0’
          Rounding is towards zero.
     ‘1’
          Rounding is to the nearest number.
     ‘2’
          Rounding is towards positive infinity.
     ‘3’
          Rounding is towards negative infinity.

     Any other value represents a machine-dependent nonstandard rounding
     mode.

     On most machines, the value is ‘1’, in accordance with the IEEE
     standard for floating point.

     Here is a table showing how certain values round for each possible
     value of ‘FLT_ROUNDS’, if the other aspects of the representation
     match the IEEE single-precision standard.

                          0      1             2             3
           1.00000003    1.0    1.0           1.00000012    1.0
           1.00000007    1.0    1.00000012    1.00000012    1.0
          -1.00000003   -1.0   -1.0          -1.0          -1.00000012
          -1.00000007   -1.0   -1.00000012   -1.0          -1.00000012

‘FLT_RADIX’

     This is the value of the base, or radix, of the exponent
     representation.  This is guaranteed to be a constant expression,
     unlike the other macros described in this section.  The value is 2
     on all machines we know of except the IBM 360 and derivatives.

‘FLT_MANT_DIG’

     This is the number of base-‘FLT_RADIX’ digits in the floating point
     mantissa for the ‘float’ data type.  The following expression
     yields ‘1.0’ (even though mathematically it should not) due to the
     limited number of mantissa digits:

          float radix = FLT_RADIX;

          1.0f + 1.0f / radix / radix / … / radix

     where ‘radix’ appears ‘FLT_MANT_DIG’ times.

‘DBL_MANT_DIG’
‘LDBL_MANT_DIG’

     This is the number of base-‘FLT_RADIX’ digits in the floating point
     mantissa for the data types ‘double’ and ‘long double’,
     respectively.

‘FLT_DIG’

     This is the number of decimal digits of precision for the ‘float’
     data type.  Technically, if P and B are the precision and base
     (respectively) for the representation, then the decimal precision Q
     is the maximum number of decimal digits such that any floating
     point number with Q base 10 digits can be rounded to a floating
     point number with P base B digits and back again, without change to
     the Q decimal digits.

     The value of this macro is supposed to be at least ‘6’, to satisfy
     ISO C.

‘DBL_DIG’
‘LDBL_DIG’

     These are similar to ‘FLT_DIG’, but for the data types ‘double’ and
     ‘long double’, respectively.  The values of these macros are
     supposed to be at least ‘10’.

‘FLT_MIN_EXP’

     This is the smallest possible exponent value for type ‘float’.
     More precisely, it is the minimum negative integer such that the
     value ‘FLT_RADIX’ raised to this power minus 1 can be represented
     as a normalized floating point number of type ‘float’.

‘DBL_MIN_EXP’
‘LDBL_MIN_EXP’

     These are similar to ‘FLT_MIN_EXP’, but for the data types ‘double’
     and ‘long double’, respectively.

‘FLT_MIN_10_EXP’

     This is the minimum negative integer such that ‘10’ raised to this
     power minus 1 can be represented as a normalized floating point
     number of type ‘float’.  This is supposed to be ‘-37’ or even less.

‘DBL_MIN_10_EXP’
‘LDBL_MIN_10_EXP’

     These are similar to ‘FLT_MIN_10_EXP’, but for the data types
     ‘double’ and ‘long double’, respectively.

‘FLT_MAX_EXP’

     This is the largest possible exponent value for type ‘float’.  More
     precisely, this is the maximum positive integer such that value
     ‘FLT_RADIX’ raised to this power minus 1 can be represented as a
     floating point number of type ‘float’.

‘DBL_MAX_EXP’
‘LDBL_MAX_EXP’

     These are similar to ‘FLT_MAX_EXP’, but for the data types ‘double’
     and ‘long double’, respectively.

‘FLT_MAX_10_EXP’

     This is the maximum positive integer such that ‘10’ raised to this
     power minus 1 can be represented as a normalized floating point
     number of type ‘float’.  This is supposed to be at least ‘37’.

‘DBL_MAX_10_EXP’
‘LDBL_MAX_10_EXP’

     These are similar to ‘FLT_MAX_10_EXP’, but for the data types
     ‘double’ and ‘long double’, respectively.

‘FLT_MAX’

     The value of this macro is the maximum number representable in type
     ‘float’.  It is supposed to be at least ‘1E+37’.  The value has
     type ‘float’.

     The smallest representable number is ‘- FLT_MAX’.

‘DBL_MAX’
‘LDBL_MAX’

     These are similar to ‘FLT_MAX’, but for the data types ‘double’ and
     ‘long double’, respectively.  The type of the macro’s value is the
     same as the type it describes.

‘FLT_MIN’

     The value of this macro is the minimum normalized positive floating
     point number that is representable in type ‘float’.  It is supposed
     to be no more than ‘1E-37’.

‘DBL_MIN’
‘LDBL_MIN’

     These are similar to ‘FLT_MIN’, but for the data types ‘double’ and
     ‘long double’, respectively.  The type of the macro’s value is the
     same as the type it describes.

‘FLT_EPSILON’

     This is the difference between 1 and the smallest floating point
     number of type ‘float’ that is greater than 1.  It’s supposed to be
     no greater than ‘1E-5’.

‘DBL_EPSILON’
‘LDBL_EPSILON’

     These are similar to ‘FLT_EPSILON’, but for the data types ‘double’
     and ‘long double’, respectively.  The type of the macro’s value is
     the same as the type it describes.  The values are not supposed to
     be greater than ‘1E-9’.


File: libc.info,  Node: IEEE Floating Point,  Prev: Floating Point Parameters,  Up: Floating Type Macros

A.5.3.3 IEEE Floating Point
...........................

Here is an example showing how the floating type measurements come out
for the most common floating point representation, specified by the
‘IEEE Standard for Binary Floating Point Arithmetic (ANSI/IEEE Std
754-1985)’.  Nearly all computers designed since the 1980s use this
format.

   The IEEE single-precision float representation uses a base of 2.
There is a sign bit, a mantissa with 23 bits plus one hidden bit (so the
total precision is 24 base-2 digits), and an 8-bit exponent that can
represent values in the range -125 to 128, inclusive.

   So, for an implementation that uses this representation for the
‘float’ data type, appropriate values for the corresponding parameters
are:

     FLT_RADIX                             2
     FLT_MANT_DIG                         24
     FLT_DIG                               6
     FLT_MIN_EXP                        -125
     FLT_MIN_10_EXP                      -37
     FLT_MAX_EXP                         128
     FLT_MAX_10_EXP                      +38
     FLT_MIN                 1.17549435E-38F
     FLT_MAX                 3.40282347E+38F
     FLT_EPSILON             1.19209290E-07F

   Here are the values for the ‘double’ data type:

     DBL_MANT_DIG                         53
     DBL_DIG                              15
     DBL_MIN_EXP                       -1021
     DBL_MIN_10_EXP                     -307
     DBL_MAX_EXP                        1024
     DBL_MAX_10_EXP                      308
     DBL_MAX         1.7976931348623157E+308
     DBL_MIN         2.2250738585072014E-308
     DBL_EPSILON     2.2204460492503131E-016


File: libc.info,  Node: Structure Measurement,  Prev: Floating Type Macros,  Up: Data Type Measurements

A.5.4 Structure Field Offset Measurement
----------------------------------------

You can use ‘offsetof’ to measure the location within a structure type
of a particular structure member.

 -- Macro: size_t offsetof (TYPE, MEMBER)

     Preliminary: | MT-Safe | AS-Safe | AC-Safe | *Note POSIX Safety
     Concepts::.

     This expands to an integer constant expression that is the offset
     of the structure member named MEMBER in the structure type TYPE.
     For example, ‘offsetof (struct s, elem)’ is the offset, in bytes,
     of the member ‘elem’ in a ‘struct s’.

     This macro won’t work if MEMBER is a bit field; you get an error
     from the C compiler in that case.


File: libc.info,  Node: Library Summary,  Next: Installation,  Prev: Language Features,  Up: Top

Appendix B Summary of Library Facilities
****************************************

This appendix is a complete list of the facilities declared within the
header files supplied with the GNU C Library.  Each entry also lists the
standard or other source from which each facility is derived, and tells
you where in the manual you can find more information about how to use
it.

‘ACCOUNTING’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

‘AF_FILE’

     ‘sys/socket.h’ (GNU): *note Address Formats::.

‘AF_INET’

     ‘sys/socket.h’ (BSD): *note Address Formats::.

‘AF_INET6’

     ‘sys/socket.h’ (IPv6 Basic API): *note Address Formats::.

‘AF_LOCAL’

     ‘sys/socket.h’ (POSIX): *note Address Formats::.

‘AF_UNIX’

     ‘sys/socket.h’ (BSD): *note Address Formats::.

     ‘sys/socket.h’ (Unix98): *note Address Formats::.

‘AF_UNSPEC’

     ‘sys/socket.h’ (BSD): *note Address Formats::.

‘tcflag_t ALTWERASE’

     ‘termios.h’ (BSD): *note Local Modes::.

‘int ARGP_ERR_UNKNOWN’

     ‘argp.h’ (GNU): *note Argp Parser Functions::.

‘ARGP_HELP_BUG_ADDR’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_DOC’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_EXIT_ERR’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_EXIT_OK’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_LONG’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_LONG_ONLY’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_POST_DOC’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_PRE_DOC’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_SEE’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_SHORT_USAGE’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_STD_ERR’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_STD_HELP’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_STD_USAGE’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_HELP_USAGE’

     ‘argp.h’ (GNU): *note Argp Help Flags::.

‘ARGP_IN_ORDER’

     ‘argp.h’ (GNU): *note Argp Flags::.

‘ARGP_KEY_ARG’

     ‘argp.h’ (GNU): *note Argp Special Keys::.

‘ARGP_KEY_ARGS’

     ‘argp.h’ (GNU): *note Argp Special Keys::.

‘ARGP_KEY_END’

     ‘argp.h’ (GNU): *note Argp Special Keys::.

‘ARGP_KEY_ERROR’

     ‘argp.h’ (GNU): *note Argp Special Keys::.

‘ARGP_KEY_FINI’

     ‘argp.h’ (GNU): *note Argp Special Keys::.

‘ARGP_KEY_HELP_ARGS_DOC’

     ‘argp.h’ (GNU): *note Argp Help Filter Keys::.

‘ARGP_KEY_HELP_DUP_ARGS_NOTE’

     ‘argp.h’ (GNU): *note Argp Help Filter Keys::.

‘ARGP_KEY_HELP_EXTRA’

     ‘argp.h’ (GNU): *note Argp Help Filter Keys::.

‘ARGP_KEY_HELP_HEADER’

     ‘argp.h’ (GNU): *note Argp Help Filter Keys::.

‘ARGP_KEY_HELP_POST_DOC’

     ‘argp.h’ (GNU): *note Argp Help Filter Keys::.

‘ARGP_KEY_HELP_PRE_DOC’

     ‘argp.h’ (GNU): *note Argp Help Filter Keys::.

‘ARGP_KEY_INIT’

     ‘argp.h’ (GNU): *note Argp Special Keys::.

‘ARGP_KEY_NO_ARGS’

     ‘argp.h’ (GNU): *note Argp Special Keys::.

‘ARGP_KEY_SUCCESS’

     ‘argp.h’ (GNU): *note Argp Special Keys::.

‘ARGP_LONG_ONLY’

     ‘argp.h’ (GNU): *note Argp Flags::.

‘ARGP_NO_ARGS’

     ‘argp.h’ (GNU): *note Argp Flags::.

‘ARGP_NO_ERRS’

     ‘argp.h’ (GNU): *note Argp Flags::.

‘ARGP_NO_EXIT’

     ‘argp.h’ (GNU): *note Argp Flags::.

‘ARGP_NO_HELP’

     ‘argp.h’ (GNU): *note Argp Flags::.

‘ARGP_PARSE_ARGV0’

     ‘argp.h’ (GNU): *note Argp Flags::.

‘ARGP_SILENT’

     ‘argp.h’ (GNU): *note Argp Flags::.

‘int ARG_MAX’

     ‘limits.h’ (POSIX.1): *note General Limits::.

‘int BC_BASE_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Limits::.

‘int BC_DIM_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Limits::.

‘int BC_SCALE_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Limits::.

‘int BC_STRING_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Limits::.

‘BOOT_TIME’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘tcflag_t BRKINT’

     ‘termios.h’ (POSIX.1): *note Input Modes::.

‘int BUFSIZ’

     ‘stdio.h’ (ISO): *note Controlling Buffering::.

‘tcflag_t CCTS_OFLOW’

     ‘termios.h’ (BSD): *note Control Modes::.

‘int CHAR_BIT’

     ‘limits.h’ (C90): *note Width of Type::.

‘CHAR_MAX’

     ‘limits.h’ (ISO): *note Range of Type::.

‘CHAR_MIN’

     ‘limits.h’ (ISO): *note Range of Type::.

‘CHAR_WIDTH’

     ‘limits.h’ (ISO): *note Width of Type::.

‘int CHILD_MAX’

     ‘limits.h’ (POSIX.1): *note General Limits::.

‘tcflag_t CIGNORE’

     ‘termios.h’ (BSD): *note Control Modes::.

‘int CLK_TCK’

     ‘time.h’ (POSIX.1): *note Processor Time::.

‘tcflag_t CLOCAL’

     ‘termios.h’ (POSIX.1): *note Control Modes::.

‘int CLOCKS_PER_SEC’

     ‘time.h’ (ISO): *note CPU Time::.

‘int COLL_WEIGHTS_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Limits::.

‘void CPU_CLR (int CPU, cpu_set_t *SET)’

     ‘sched.h’ (GNU): *note CPU Affinity::.

‘int CPU_ISSET (int CPU, const cpu_set_t *SET)’

     ‘sched.h’ (GNU): *note CPU Affinity::.

‘void CPU_SET (int CPU, cpu_set_t *SET)’

     ‘sched.h’ (GNU): *note CPU Affinity::.

‘int CPU_SETSIZE’

     ‘sched.h’ (GNU): *note CPU Affinity::.

‘void CPU_ZERO (cpu_set_t *SET)’

     ‘sched.h’ (GNU): *note CPU Affinity::.

‘tcflag_t CREAD’

     ‘termios.h’ (POSIX.1): *note Control Modes::.

‘tcflag_t CRTS_IFLOW’

     ‘termios.h’ (BSD): *note Control Modes::.

‘tcflag_t CS5’

     ‘termios.h’ (POSIX.1): *note Control Modes::.

‘tcflag_t CS6’

     ‘termios.h’ (POSIX.1): *note Control Modes::.

‘tcflag_t CS7’

     ‘termios.h’ (POSIX.1): *note Control Modes::.

‘tcflag_t CS8’

     ‘termios.h’ (POSIX.1): *note Control Modes::.

‘tcflag_t CSIZE’

     ‘termios.h’ (POSIX.1): *note Control Modes::.

‘tcflag_t CSTOPB’

     ‘termios.h’ (POSIX.1): *note Control Modes::.

‘DBL_DIG’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘DBL_EPSILON’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘DBL_MANT_DIG’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘DBL_MAX’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘DBL_MAX_10_EXP’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘DBL_MAX_EXP’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘DBL_MIN’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘DBL_MIN_10_EXP’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘DBL_MIN_EXP’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘DEAD_PROCESS’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘DIR’

     ‘dirent.h’ (POSIX.1): *note Opening a Directory::.

‘mode_t DTTOIF (int DTYPE)’

     ‘dirent.h’ (BSD): *note Directory Entries::.

‘int E2BIG’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EACCES’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EADDRINUSE’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EADDRNOTAVAIL’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EADV’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EAFNOSUPPORT’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EAGAIN’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EALREADY’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EAUTH’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EBACKGROUND’

     ‘errno.h’ (GNU): *note Error Codes::.

‘int EBADE’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EBADF’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EBADFD’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EBADMSG’

     ‘errno.h’ (XOPEN): *note Error Codes::.

‘int EBADR’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EBADRPC’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EBADRQC’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EBADSLT’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EBFONT’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EBUSY’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ECANCELED’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ECHILD’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘tcflag_t ECHO’

     ‘termios.h’ (POSIX.1): *note Local Modes::.

‘tcflag_t ECHOCTL’

     ‘termios.h’ (BSD): *note Local Modes::.

‘tcflag_t ECHOE’

     ‘termios.h’ (POSIX.1): *note Local Modes::.

‘tcflag_t ECHOK’

     ‘termios.h’ (POSIX.1): *note Local Modes::.

‘tcflag_t ECHOKE’

     ‘termios.h’ (BSD): *note Local Modes::.

‘tcflag_t ECHONL’

     ‘termios.h’ (POSIX.1): *note Local Modes::.

‘tcflag_t ECHOPRT’

     ‘termios.h’ (BSD): *note Local Modes::.

‘int ECHRNG’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ECOMM’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ECONNABORTED’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ECONNREFUSED’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ECONNRESET’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ED’

     ‘errno.h’ (GNU): *note Error Codes::.

‘int EDEADLK’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EDEADLOCK’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EDESTADDRREQ’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EDIED’

     ‘errno.h’ (GNU): *note Error Codes::.

‘int EDOM’

     ‘errno.h’ (ISO): *note Error Codes::.

‘int EDOTDOT’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EDQUOT’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EEXIST’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EFAULT’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EFBIG’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EFTYPE’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EGRATUITOUS’

     ‘errno.h’ (GNU): *note Error Codes::.

‘int EGREGIOUS’

     ‘errno.h’ (GNU): *note Error Codes::.

‘int EHOSTDOWN’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EHOSTUNREACH’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EHWPOISON’

     ‘errno.h’ (Linux): *note Error Codes::.

‘int EIDRM’

     ‘errno.h’ (XOPEN): *note Error Codes::.

‘int EIEIO’

     ‘errno.h’ (GNU): *note Error Codes::.

‘int EILSEQ’

     ‘errno.h’ (ISO): *note Error Codes::.

‘int EINPROGRESS’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EINTR’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EINVAL’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EIO’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EISCONN’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EISDIR’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EISNAM’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EKEYEXPIRED’

     ‘errno.h’ (Linux): *note Error Codes::.

‘int EKEYREJECTED’

     ‘errno.h’ (Linux): *note Error Codes::.

‘int EKEYREVOKED’

     ‘errno.h’ (Linux): *note Error Codes::.

‘int EL2HLT’

     ‘errno.h’ (Obsolete): *note Error Codes::.

‘int EL2NSYNC’

     ‘errno.h’ (Obsolete): *note Error Codes::.

‘int EL3HLT’

     ‘errno.h’ (Obsolete): *note Error Codes::.

‘int EL3RST’

     ‘errno.h’ (Obsolete): *note Error Codes::.

‘int ELIBACC’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ELIBBAD’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ELIBEXEC’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ELIBMAX’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ELIBSCN’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ELNRNG’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ELOOP’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EMEDIUMTYPE’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EMFILE’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EMLINK’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘EMPTY’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘int EMSGSIZE’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EMULTIHOP’

     ‘errno.h’ (XOPEN): *note Error Codes::.

‘int ENAMETOOLONG’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENAVAIL’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ENEEDAUTH’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ENETDOWN’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ENETRESET’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ENETUNREACH’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ENFILE’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENOANO’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ENOBUFS’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ENOCSI’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ENODATA’

     ‘errno.h’ (XOPEN): *note Error Codes::.

‘int ENODEV’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENOENT’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENOEXEC’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENOKEY’

     ‘errno.h’ (Linux): *note Error Codes::.

‘int ENOLCK’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENOLINK’

     ‘errno.h’ (XOPEN): *note Error Codes::.

‘int ENOMEDIUM’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ENOMEM’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENOMSG’

     ‘errno.h’ (XOPEN): *note Error Codes::.

‘int ENONET’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ENOPKG’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ENOPROTOOPT’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ENOSPC’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENOSR’

     ‘errno.h’ (XOPEN): *note Error Codes::.

‘int ENOSTR’

     ‘errno.h’ (XOPEN): *note Error Codes::.

‘int ENOSYS’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENOTBLK’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ENOTCONN’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ENOTDIR’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENOTEMPTY’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENOTNAM’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ENOTRECOVERABLE’

     ‘errno.h’ (GNU): *note Error Codes::.

‘int ENOTSOCK’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ENOTSUP’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENOTTY’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ENOTUNIQ’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ENXIO’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EOF’

     ‘stdio.h’ (ISO): *note EOF and Errors::.

‘int EOPNOTSUPP’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EOVERFLOW’

     ‘errno.h’ (XOPEN): *note Error Codes::.

‘int EOWNERDEAD’

     ‘errno.h’ (GNU): *note Error Codes::.

‘int EPERM’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EPFNOSUPPORT’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EPIPE’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EPROCLIM’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EPROCUNAVAIL’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EPROGMISMATCH’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EPROGUNAVAIL’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EPROTO’

     ‘errno.h’ (XOPEN): *note Error Codes::.

‘int EPROTONOSUPPORT’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EPROTOTYPE’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EQUIV_CLASS_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Limits::.

‘int ERANGE’

     ‘errno.h’ (ISO): *note Error Codes::.

‘int EREMCHG’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EREMOTE’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EREMOTEIO’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ERESTART’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ERFKILL’

     ‘errno.h’ (Linux): *note Error Codes::.

‘int EROFS’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ERPCMISMATCH’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ESHUTDOWN’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ESOCKTNOSUPPORT’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ESPIPE’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ESRCH’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int ESRMNT’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ESTALE’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ESTRPIPE’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int ETIME’

     ‘errno.h’ (XOPEN): *note Error Codes::.

‘int ETIMEDOUT’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ETOOMANYREFS’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int ETXTBSY’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EUCLEAN’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EUNATCH’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EUSERS’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EWOULDBLOCK’

     ‘errno.h’ (BSD): *note Error Codes::.

‘int EXDEV’

     ‘errno.h’ (POSIX.1): *note Error Codes::.

‘int EXFULL’

     ‘errno.h’ (Linux???): *note Error Codes::.

‘int EXIT_FAILURE’

     ‘stdlib.h’ (ISO): *note Exit Status::.

‘int EXIT_SUCCESS’

     ‘stdlib.h’ (ISO): *note Exit Status::.

‘int EXPR_NEST_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Limits::.

‘int FD_CLOEXEC’

     ‘fcntl.h’ (POSIX.1): *note Descriptor Flags::.

‘void FD_CLR (int FILEDES, fd_set *SET)’

     ‘sys/types.h’ (BSD): *note Waiting for I/O::.

‘int FD_ISSET (int FILEDES, const fd_set *SET)’

     ‘sys/types.h’ (BSD): *note Waiting for I/O::.

‘void FD_SET (int FILEDES, fd_set *SET)’

     ‘sys/types.h’ (BSD): *note Waiting for I/O::.

‘int FD_SETSIZE’

     ‘sys/types.h’ (BSD): *note Waiting for I/O::.

‘void FD_ZERO (fd_set *SET)’

     ‘sys/types.h’ (BSD): *note Waiting for I/O::.

‘FE_DIVBYZERO’

     ‘fenv.h’ (ISO): *note Status bit operations::.

‘FE_DOWNWARD’

     ‘fenv.h’ (ISO): *note Rounding::.

‘FE_INEXACT’

     ‘fenv.h’ (ISO): *note Status bit operations::.

‘FE_INVALID’

     ‘fenv.h’ (ISO): *note Status bit operations::.

‘FE_OVERFLOW’

     ‘fenv.h’ (ISO): *note Status bit operations::.

‘int FE_SNANS_ALWAYS_SIGNAL’

     ‘fenv.h’ (ISO): *note Infinity and NaN::.

‘FE_TONEAREST’

     ‘fenv.h’ (ISO): *note Rounding::.

‘FE_TOWARDZERO’

     ‘fenv.h’ (ISO): *note Rounding::.

‘FE_UNDERFLOW’

     ‘fenv.h’ (ISO): *note Status bit operations::.

‘FE_UPWARD’

     ‘fenv.h’ (ISO): *note Rounding::.

‘FILE’

     ‘stdio.h’ (ISO): *note Streams::.

‘int FILENAME_MAX’

     ‘stdio.h’ (ISO): *note Limits for Files::.

‘FLT_DIG’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘FLT_EPSILON’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘FLT_MANT_DIG’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘FLT_MAX’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘FLT_MAX_10_EXP’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘FLT_MAX_EXP’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘FLT_MIN’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘FLT_MIN_10_EXP’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘FLT_MIN_EXP’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘FLT_RADIX’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘FLT_ROUNDS’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘tcflag_t FLUSHO’

     ‘termios.h’ (BSD): *note Local Modes::.

‘FNM_CASEFOLD’

     ‘fnmatch.h’ (GNU): *note Wildcard Matching::.

‘FNM_EXTMATCH’

     ‘fnmatch.h’ (GNU): *note Wildcard Matching::.

‘FNM_FILE_NAME’

     ‘fnmatch.h’ (GNU): *note Wildcard Matching::.

‘FNM_LEADING_DIR’

     ‘fnmatch.h’ (GNU): *note Wildcard Matching::.

‘FNM_NOESCAPE’

     ‘fnmatch.h’ (POSIX.2): *note Wildcard Matching::.

‘FNM_PATHNAME’

     ‘fnmatch.h’ (POSIX.2): *note Wildcard Matching::.

‘FNM_PERIOD’

     ‘fnmatch.h’ (POSIX.2): *note Wildcard Matching::.

‘int FOPEN_MAX’

     ‘stdio.h’ (ISO): *note Opening Streams::.

‘FPE_DECOVF_TRAP’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘FPE_FLTDIV_FAULT’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘FPE_FLTDIV_TRAP’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘FPE_FLTOVF_FAULT’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘FPE_FLTOVF_TRAP’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘FPE_FLTUND_FAULT’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘FPE_FLTUND_TRAP’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘FPE_INTDIV_TRAP’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘FPE_INTOVF_TRAP’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘FPE_SUBRNG_TRAP’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘int FP_ILOGB0’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘int FP_ILOGBNAN’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘FP_INFINITE’

     ‘math.h’ (C99): *note Floating Point Classes::.

‘FP_INT_DOWNWARD’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘FP_INT_TONEAREST’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘FP_INT_TONEARESTFROMZERO’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘FP_INT_TOWARDZERO’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘FP_INT_UPWARD’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘long int FP_LLOGB0’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘long int FP_LLOGBNAN’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘FP_NAN’

     ‘math.h’ (C99): *note Floating Point Classes::.

‘FP_NORMAL’

     ‘math.h’ (C99): *note Floating Point Classes::.

‘FP_SUBNORMAL’

     ‘math.h’ (C99): *note Floating Point Classes::.

‘FP_ZERO’

     ‘math.h’ (C99): *note Floating Point Classes::.

‘struct FTW’

     ‘ftw.h’ (XPG4.2): *note Working with Directory Trees::.

‘int F_DUPFD’

     ‘fcntl.h’ (POSIX.1): *note Duplicating Descriptors::.

‘int F_GETFD’

     ‘fcntl.h’ (POSIX.1): *note Descriptor Flags::.

‘int F_GETFL’

     ‘fcntl.h’ (POSIX.1): *note Getting File Status Flags::.

‘int F_GETLK’

     ‘fcntl.h’ (POSIX.1): *note File Locks::.

‘int F_GETOWN’

     ‘fcntl.h’ (BSD): *note Interrupt Input::.

‘int F_OFD_SETLK’

     ‘fcntl.h’ (POSIX.1): *note Open File Description Locks::.

‘int F_OFD_SETLKW’

     ‘fcntl.h’ (POSIX.1): *note Open File Description Locks::.

‘int F_OK’

     ‘unistd.h’ (POSIX.1): *note Testing File Access::.

‘F_RDLCK’

     ‘fcntl.h’ (POSIX.1): *note File Locks::.

‘int F_SETFD’

     ‘fcntl.h’ (POSIX.1): *note Descriptor Flags::.

‘int F_SETFL’

     ‘fcntl.h’ (POSIX.1): *note Getting File Status Flags::.

‘int F_SETLK’

     ‘fcntl.h’ (POSIX.1): *note File Locks::.

‘int F_SETLKW’

     ‘fcntl.h’ (POSIX.1): *note File Locks::.

‘int F_SETOWN’

     ‘fcntl.h’ (BSD): *note Interrupt Input::.

‘F_UNLCK’

     ‘fcntl.h’ (POSIX.1): *note File Locks::.

‘F_WRLCK’

     ‘fcntl.h’ (POSIX.1): *note File Locks::.

‘GLOB_ABORTED’

     ‘glob.h’ (POSIX.2): *note Calling Glob::.

‘GLOB_ALTDIRFUNC’

     ‘glob.h’ (GNU): *note More Flags for Globbing::.

‘GLOB_APPEND’

     ‘glob.h’ (POSIX.2): *note Flags for Globbing::.

‘GLOB_BRACE’

     ‘glob.h’ (GNU): *note More Flags for Globbing::.

‘GLOB_DOOFFS’

     ‘glob.h’ (POSIX.2): *note Flags for Globbing::.

‘GLOB_ERR’

     ‘glob.h’ (POSIX.2): *note Flags for Globbing::.

‘GLOB_MAGCHAR’

     ‘glob.h’ (GNU): *note More Flags for Globbing::.

‘GLOB_MARK’

     ‘glob.h’ (POSIX.2): *note Flags for Globbing::.

‘GLOB_NOCHECK’

     ‘glob.h’ (POSIX.2): *note Flags for Globbing::.

‘GLOB_NOESCAPE’

     ‘glob.h’ (POSIX.2): *note Flags for Globbing::.

‘GLOB_NOMAGIC’

     ‘glob.h’ (GNU): *note More Flags for Globbing::.

‘GLOB_NOMATCH’

     ‘glob.h’ (POSIX.2): *note Calling Glob::.

‘GLOB_NOSORT’

     ‘glob.h’ (POSIX.2): *note Flags for Globbing::.

‘GLOB_NOSPACE’

     ‘glob.h’ (POSIX.2): *note Calling Glob::.

‘GLOB_ONLYDIR’

     ‘glob.h’ (GNU): *note More Flags for Globbing::.

‘GLOB_PERIOD’

     ‘glob.h’ (GNU): *note More Flags for Globbing::.

‘GLOB_TILDE’

     ‘glob.h’ (GNU): *note More Flags for Globbing::.

‘GLOB_TILDE_CHECK’

     ‘glob.h’ (GNU): *note More Flags for Globbing::.

‘HOST_NOT_FOUND’

     ‘netdb.h’ (BSD): *note Host Names::.

‘double HUGE_VAL’

     ‘math.h’ (ISO): *note Math Error Reporting::.

‘float HUGE_VALF’

     ‘math.h’ (ISO): *note Math Error Reporting::.

‘long double HUGE_VALL’

     ‘math.h’ (ISO): *note Math Error Reporting::.

‘_FloatN HUGE_VAL_FN’

     ‘math.h’ (TS 18661-3:2015): *note Math Error Reporting::.

‘_FloatNx HUGE_VAL_FNx’

     ‘math.h’ (TS 18661-3:2015): *note Math Error Reporting::.

‘tcflag_t HUPCL’

     ‘termios.h’ (POSIX.1): *note Control Modes::.

‘const float complex I’

     ‘complex.h’ (C99): *note Complex Numbers::.

‘tcflag_t ICANON’

     ‘termios.h’ (POSIX.1): *note Local Modes::.

‘tcflag_t ICRNL’

     ‘termios.h’ (POSIX.1): *note Input Modes::.

‘tcflag_t IEXTEN’

     ‘termios.h’ (POSIX.1): *note Local Modes::.

‘size_t IFNAMSIZ’

     ‘net/if.h’ (???): *note Interface Naming::.

‘int IFTODT (mode_t MODE)’

     ‘dirent.h’ (BSD): *note Directory Entries::.

‘tcflag_t IGNBRK’

     ‘termios.h’ (POSIX.1): *note Input Modes::.

‘tcflag_t IGNCR’

     ‘termios.h’ (POSIX.1): *note Input Modes::.

‘tcflag_t IGNPAR’

     ‘termios.h’ (POSIX.1): *note Input Modes::.

‘tcflag_t IMAXBEL’

     ‘termios.h’ (BSD): *note Input Modes::.

‘uint32_t INADDR_ANY’

     ‘netinet/in.h’ (BSD): *note Host Address Data Type::.

‘uint32_t INADDR_BROADCAST’

     ‘netinet/in.h’ (BSD): *note Host Address Data Type::.

‘uint32_t INADDR_LOOPBACK’

     ‘netinet/in.h’ (BSD): *note Host Address Data Type::.

‘uint32_t INADDR_NONE’

     ‘netinet/in.h’ (BSD): *note Host Address Data Type::.

‘float INFINITY’

     ‘math.h’ (ISO): *note Infinity and NaN::.

‘INIT_PROCESS’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘tcflag_t INLCR’

     ‘termios.h’ (POSIX.1): *note Input Modes::.

‘tcflag_t INPCK’

     ‘termios.h’ (POSIX.1): *note Input Modes::.

‘INTPTR_WIDTH’

     ‘stdint.h’ (ISO): *note Width of Type::.

‘INT_MAX’

     ‘limits.h’ (ISO): *note Range of Type::.

‘INT_MIN’

     ‘limits.h’ (ISO): *note Range of Type::.

‘INT_WIDTH’

     ‘limits.h’ (ISO): *note Width of Type::.

‘int IPPORT_RESERVED’

     ‘netinet/in.h’ (BSD): *note Ports::.

‘int IPPORT_USERRESERVED’

     ‘netinet/in.h’ (BSD): *note Ports::.

‘tcflag_t ISIG’

     ‘termios.h’ (POSIX.1): *note Local Modes::.

‘tcflag_t ISTRIP’

     ‘termios.h’ (POSIX.1): *note Input Modes::.

‘ITIMER_PROF’

     ‘sys/time.h’ (BSD): *note Setting an Alarm::.

‘ITIMER_REAL’

     ‘sys/time.h’ (BSD): *note Setting an Alarm::.

‘ITIMER_VIRTUAL’

     ‘sys/time.h’ (BSD): *note Setting an Alarm::.

‘tcflag_t IXANY’

     ‘termios.h’ (BSD): *note Input Modes::.

‘tcflag_t IXOFF’

     ‘termios.h’ (POSIX.1): *note Input Modes::.

‘tcflag_t IXON’

     ‘termios.h’ (POSIX.1): *note Input Modes::.

‘LANG’

     ‘locale.h’ (ISO): *note Locale Categories::.

‘LC_ALL’

     ‘locale.h’ (ISO): *note Locale Categories::.

‘LC_COLLATE’

     ‘locale.h’ (ISO): *note Locale Categories::.

‘LC_CTYPE’

     ‘locale.h’ (ISO): *note Locale Categories::.

‘LC_MESSAGES’

     ‘locale.h’ (XOPEN): *note Locale Categories::.

‘LC_MONETARY’

     ‘locale.h’ (ISO): *note Locale Categories::.

‘LC_NUMERIC’

     ‘locale.h’ (ISO): *note Locale Categories::.

‘LC_TIME’

     ‘locale.h’ (ISO): *note Locale Categories::.

‘LDBL_DIG’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘LDBL_EPSILON’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘LDBL_MANT_DIG’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘LDBL_MAX’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘LDBL_MAX_10_EXP’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘LDBL_MAX_EXP’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘LDBL_MIN’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘LDBL_MIN_10_EXP’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘LDBL_MIN_EXP’

     ‘float.h’ (C90): *note Floating Point Parameters::.

‘int LINE_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Limits::.

‘int LINK_MAX’

     ‘limits.h’ _optional_ (POSIX.1): *note Limits for Files::.

‘LLONG_MAX’

     ‘limits.h’ (ISO): *note Range of Type::.

‘LLONG_MIN’

     ‘limits.h’ (ISO): *note Range of Type::.

‘LLONG_WIDTH’

     ‘limits.h’ (ISO): *note Width of Type::.

‘LOGIN_PROCESS’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘LONG_LONG_MAX’

     ‘limits.h’ (GNU): *note Range of Type::.

‘LONG_LONG_MIN’

     ‘limits.h’ (GNU): *note Range of Type::.

‘LONG_MAX’

     ‘limits.h’ (ISO): *note Range of Type::.

‘LONG_MIN’

     ‘limits.h’ (ISO): *note Range of Type::.

‘LONG_WIDTH’

     ‘limits.h’ (ISO): *note Width of Type::.

‘L_INCR’

     ‘sys/file.h’ (BSD): *note File Positioning::.

‘L_SET’

     ‘sys/file.h’ (BSD): *note File Positioning::.

‘L_XTND’

     ‘sys/file.h’ (BSD): *note File Positioning::.

‘int L_ctermid’

     ‘stdio.h’ (POSIX.1): *note Identifying the Terminal::.

‘int L_cuserid’

     ‘stdio.h’ (POSIX.1): *note Who Logged In::.

‘int L_tmpnam’

     ‘stdio.h’ (ISO): *note Temporary Files::.

‘MADV_HUGEPAGE’

     ‘sys/mman.h’ (Linux): *note Memory-mapped I/O::.

‘MAP_HUGETLB’

     ‘sys/mman.h’ (Linux): *note Memory-mapped I/O::.

‘int MAXNAMLEN’

     ‘dirent.h’ (BSD): *note Limits for Files::.

‘int MAXSYMLINKS’

     ‘sys/param.h’ (BSD): *note Symbolic Links::.

‘int MAX_CANON’

     ‘limits.h’ (POSIX.1): *note Limits for Files::.

‘int MAX_INPUT’

     ‘limits.h’ (POSIX.1): *note Limits for Files::.

‘int MB_CUR_MAX’

     ‘stdlib.h’ (ISO): *note Selecting the Conversion::.

‘int MB_LEN_MAX’

     ‘limits.h’ (ISO): *note Selecting the Conversion::.

‘tcflag_t MDMBUF’

     ‘termios.h’ (BSD): *note Control Modes::.

‘MFD_ALLOW_SEALING’

     ‘sys/mman.h’ (Linux): *note Memory-mapped I/O::.

‘MFD_CLOEXEC’

     ‘sys/mman.h’ (Linux): *note Memory-mapped I/O::.

‘MFD_HUGETLB’

     ‘sys/mman.h’ (Linux): *note Memory-mapped I/O::.

‘MLOCK_ONFAULT’

     ‘sys/mman.h’ (Linux): *note Page Lock Functions::.

‘int MSG_DONTROUTE’

     ‘sys/socket.h’ (BSD): *note Socket Data Options::.

‘int MSG_OOB’

     ‘sys/socket.h’ (BSD): *note Socket Data Options::.

‘int MSG_PEEK’

     ‘sys/socket.h’ (BSD): *note Socket Data Options::.

‘int NAME_MAX’

     ‘limits.h’ (POSIX.1): *note Limits for Files::.

‘float NAN’

     ‘math.h’ (GNU): *note Infinity and NaN::.

‘int NCCS’

     ‘termios.h’ (POSIX.1): *note Mode Data Types::.

‘NEW_TIME’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘int NGROUPS_MAX’

     ‘limits.h’ (POSIX.1): *note General Limits::.

‘tcflag_t NOFLSH’

     ‘termios.h’ (POSIX.1): *note Local Modes::.

‘tcflag_t NOKERNINFO’

     ‘termios.h’ _optional_ (BSD): *note Local Modes::.

‘NO_ADDRESS’

     ‘netdb.h’ (BSD): *note Host Names::.

‘NO_RECOVERY’

     ‘netdb.h’ (BSD): *note Host Names::.

‘int NSIG’

     ‘signal.h’ (BSD): *note Standard Signals::.

‘void * NULL’

     ‘stddef.h’ (ISO): *note Null Pointer Constant::.

‘OLD_TIME’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘ONCE_FLAG_INIT’

     ‘threads.h’ (C11): *note Call Once::.

‘tcflag_t ONLCR’

     ‘termios.h’ (POSIX.1): *note Output Modes::.

‘tcflag_t ONOEOT’

     ‘termios.h’ _optional_ (BSD): *note Output Modes::.

‘int OPEN_MAX’

     ‘limits.h’ (POSIX.1): *note General Limits::.

‘tcflag_t OPOST’

     ‘termios.h’ (POSIX.1): *note Output Modes::.

‘OPTION_ALIAS’

     ‘argp.h’ (GNU): *note Argp Option Flags::.

‘OPTION_ARG_OPTIONAL’

     ‘argp.h’ (GNU): *note Argp Option Flags::.

‘OPTION_DOC’

     ‘argp.h’ (GNU): *note Argp Option Flags::.

‘OPTION_HIDDEN’

     ‘argp.h’ (GNU): *note Argp Option Flags::.

‘OPTION_NO_USAGE’

     ‘argp.h’ (GNU): *note Argp Option Flags::.

‘tcflag_t OXTABS’

     ‘termios.h’ _optional_ (BSD): *note Output Modes::.

‘int O_ACCMODE’

     ‘fcntl.h’ (POSIX.1): *note Access Modes::.

‘int O_APPEND’

     ‘fcntl.h’ (POSIX.1): *note Operating Modes::.

‘int O_ASYNC’

     ‘fcntl.h’ (BSD): *note Operating Modes::.

‘int O_CREAT’

     ‘fcntl.h’ (POSIX.1): *note Open-time Flags::.

‘int O_DIRECTORY’

     ‘fcntl.h’ (POSIX.1): *note Open-time Flags::.

‘int O_EXCL’

     ‘fcntl.h’ (POSIX.1): *note Open-time Flags::.

‘int O_EXEC’

     ‘fcntl.h’ _optional_ (GNU): *note Access Modes::.

‘int O_EXLOCK’

     ‘fcntl.h’ _optional_ (BSD): *note Open-time Flags::.

‘int O_FSYNC’

     ‘fcntl.h’ (BSD): *note Operating Modes::.

‘int O_IGNORE_CTTY’

     ‘fcntl.h’ _optional_ (GNU): *note Open-time Flags::.

‘int O_NDELAY’

     ‘fcntl.h’ (BSD): *note Operating Modes::.

‘int O_NOATIME’

     ‘fcntl.h’ (GNU): *note Operating Modes::.

‘int O_NOCTTY’

     ‘fcntl.h’ (POSIX.1): *note Open-time Flags::.

‘int O_NOLINK’

     ‘fcntl.h’ _optional_ (GNU): *note Open-time Flags::.

‘int O_NONBLOCK’

     ‘fcntl.h’ (POSIX.1): *note Open-time Flags::.

     ‘fcntl.h’ (POSIX.1): *note Operating Modes::.

‘int O_NOTRANS’

     ‘fcntl.h’ _optional_ (GNU): *note Open-time Flags::.

‘int O_RDONLY’

     ‘fcntl.h’ (POSIX.1): *note Access Modes::.

‘int O_RDWR’

     ‘fcntl.h’ (POSIX.1): *note Access Modes::.

‘int O_READ’

     ‘fcntl.h’ _optional_ (GNU): *note Access Modes::.

‘int O_SHLOCK’

     ‘fcntl.h’ _optional_ (BSD): *note Open-time Flags::.

‘int O_SYNC’

     ‘fcntl.h’ (BSD): *note Operating Modes::.

‘int O_TMPFILE’

     ‘fcntl.h’ (GNU): *note Open-time Flags::.

‘int O_TRUNC’

     ‘fcntl.h’ (POSIX.1): *note Open-time Flags::.

‘int O_WRITE’

     ‘fcntl.h’ _optional_ (GNU): *note Access Modes::.

‘int O_WRONLY’

     ‘fcntl.h’ (POSIX.1): *note Access Modes::.

‘tcflag_t PARENB’

     ‘termios.h’ (POSIX.1): *note Control Modes::.

‘tcflag_t PARMRK’

     ‘termios.h’ (POSIX.1): *note Input Modes::.

‘tcflag_t PARODD’

     ‘termios.h’ (POSIX.1): *note Control Modes::.

‘int PATH_MAX’

     ‘limits.h’ (POSIX.1): *note Limits for Files::.

‘PA_CHAR’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘PA_DOUBLE’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘PA_FLAG_LONG’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘PA_FLAG_LONG_DOUBLE’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘PA_FLAG_LONG_LONG’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘int PA_FLAG_MASK’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘PA_FLAG_PTR’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘PA_FLAG_SHORT’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘PA_FLOAT’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘PA_INT’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘PA_LAST’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘PA_POINTER’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘PA_STRING’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘tcflag_t PENDIN’

     ‘termios.h’ (BSD): *note Local Modes::.

‘int PF_FILE’

     ‘sys/socket.h’ (GNU): *note Local Namespace Details::.

‘int PF_INET’

     ‘sys/socket.h’ (BSD): *note Internet Namespace::.

‘int PF_INET6’

     ‘sys/socket.h’ (X/Open): *note Internet Namespace::.

‘int PF_LOCAL’

     ‘sys/socket.h’ (POSIX): *note Local Namespace Details::.

‘int PF_UNIX’

     ‘sys/socket.h’ (BSD): *note Local Namespace Details::.

‘int PIPE_BUF’

     ‘limits.h’ (POSIX.1): *note Limits for Files::.

‘PKEY_DISABLE_ACCESS’

     ‘sys/mman.h’ (Linux): *note Memory Protection::.

‘PKEY_DISABLE_WRITE’

     ‘sys/mman.h’ (Linux): *note Memory Protection::.

‘POSIX_REC_INCR_XFER_SIZE’

     ‘limits.h’ (POSIX.1): *note File Minimums::.

‘POSIX_REC_MAX_XFER_SIZE’

     ‘limits.h’ (POSIX.1): *note File Minimums::.

‘POSIX_REC_MIN_XFER_SIZE’

     ‘limits.h’ (POSIX.1): *note File Minimums::.

‘POSIX_REC_XFER_ALIGN’

     ‘limits.h’ (POSIX.1): *note File Minimums::.

‘PRIO_MAX’

     ‘sys/resource.h’ (BSD): *note Traditional Scheduling Functions::.

‘PRIO_MIN’

     ‘sys/resource.h’ (BSD): *note Traditional Scheduling Functions::.

‘PRIO_PGRP’

     ‘sys/resource.h’ (BSD): *note Traditional Scheduling Functions::.

‘PRIO_PROCESS’

     ‘sys/resource.h’ (BSD): *note Traditional Scheduling Functions::.

‘PRIO_USER’

     ‘sys/resource.h’ (BSD): *note Traditional Scheduling Functions::.

‘PROT_EXEC’

     ‘sys/mman.h’ (POSIX): *note Memory Protection::.

‘PROT_NONE’

     ‘sys/mman.h’ (POSIX): *note Memory Protection::.

‘PROT_READ’

     ‘sys/mman.h’ (POSIX): *note Memory Protection::.

‘PROT_WRITE’

     ‘sys/mman.h’ (POSIX): *note Memory Protection::.

‘PTRDIFF_WIDTH’

     ‘stdint.h’ (ISO): *note Width of Type::.

‘char * P_tmpdir’

     ‘stdio.h’ (SVID): *note Temporary Files::.

‘int RAND_MAX’

     ‘stdlib.h’ (ISO): *note ISO Random::.

‘REG_BADBR’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘REG_BADPAT’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘REG_BADRPT’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘REG_EBRACE’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘REG_EBRACK’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘REG_ECOLLATE’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘REG_ECTYPE’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘REG_EESCAPE’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘REG_EPAREN’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘REG_ERANGE’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘REG_ESPACE’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

     ‘regex.h’ (POSIX.2): *note Matching POSIX Regexps::.

‘REG_ESUBREG’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘REG_EXTENDED’

     ‘regex.h’ (POSIX.2): *note Flags for POSIX Regexps::.

‘REG_ICASE’

     ‘regex.h’ (POSIX.2): *note Flags for POSIX Regexps::.

‘REG_NEWLINE’

     ‘regex.h’ (POSIX.2): *note Flags for POSIX Regexps::.

‘REG_NOMATCH’

     ‘regex.h’ (POSIX.2): *note Matching POSIX Regexps::.

‘REG_NOSUB’

     ‘regex.h’ (POSIX.2): *note Flags for POSIX Regexps::.

‘REG_NOTBOL’

     ‘regex.h’ (POSIX.2): *note Matching POSIX Regexps::.

‘REG_NOTEOL’

     ‘regex.h’ (POSIX.2): *note Matching POSIX Regexps::.

‘int RE_DUP_MAX’

     ‘limits.h’ (POSIX.2): *note General Limits::.

‘RLIMIT_AS’

     ‘sys/resource.h’ (Unix98): *note Limits on Resources::.

‘RLIMIT_CORE’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘RLIMIT_CPU’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘RLIMIT_DATA’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘RLIMIT_FSIZE’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘RLIMIT_MEMLOCK’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘RLIMIT_NOFILE’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘RLIMIT_NPROC’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘RLIMIT_RSS’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘RLIMIT_STACK’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘rlim_t RLIM_INFINITY’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘RLIM_NLIMITS’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘RUN_LVL’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘RUSAGE_CHILDREN’

     ‘sys/resource.h’ (BSD): *note Resource Usage::.

‘RUSAGE_SELF’

     ‘sys/resource.h’ (BSD): *note Resource Usage::.

‘int R_OK’

     ‘unistd.h’ (POSIX.1): *note Testing File Access::.

‘int SA_NOCLDSTOP’

     ‘signal.h’ (POSIX.1): *note Flags for Sigaction::.

‘int SA_ONSTACK’

     ‘signal.h’ (BSD): *note Flags for Sigaction::.

‘int SA_RESTART’

     ‘signal.h’ (BSD): *note Flags for Sigaction::.

‘SCHAR_MAX’

     ‘limits.h’ (ISO): *note Range of Type::.

‘SCHAR_MIN’

     ‘limits.h’ (ISO): *note Range of Type::.

‘SCHAR_WIDTH’

     ‘limits.h’ (ISO): *note Width of Type::.

‘int SEEK_CUR’

     ‘stdio.h’ (ISO): *note File Positioning::.

‘int SEEK_END’

     ‘stdio.h’ (ISO): *note File Positioning::.

‘int SEEK_SET’

     ‘stdio.h’ (ISO): *note File Positioning::.

‘SHRT_MAX’

     ‘limits.h’ (ISO): *note Range of Type::.

‘SHRT_MIN’

     ‘limits.h’ (ISO): *note Range of Type::.

‘SHRT_WIDTH’

     ‘limits.h’ (ISO): *note Width of Type::.

‘int SIGABRT’

     ‘signal.h’ (ISO): *note Program Error Signals::.

‘int SIGALRM’

     ‘signal.h’ (POSIX.1): *note Alarm Signals::.

‘int SIGBUS’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘int SIGCHLD’

     ‘signal.h’ (POSIX.1): *note Job Control Signals::.

‘int SIGCLD’

     ‘signal.h’ (SVID): *note Job Control Signals::.

‘int SIGCONT’

     ‘signal.h’ (POSIX.1): *note Job Control Signals::.

‘int SIGEMT’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘int SIGFPE’

     ‘signal.h’ (ISO): *note Program Error Signals::.

‘int SIGHUP’

     ‘signal.h’ (POSIX.1): *note Termination Signals::.

‘int SIGILL’

     ‘signal.h’ (ISO): *note Program Error Signals::.

‘int SIGINFO’

     ‘signal.h’ (BSD): *note Miscellaneous Signals::.

‘int SIGINT’

     ‘signal.h’ (ISO): *note Termination Signals::.

‘int SIGIO’

     ‘signal.h’ (BSD): *note Asynchronous I/O Signals::.

‘int SIGIOT’

     ‘signal.h’ (Unix): *note Program Error Signals::.

‘int SIGKILL’

     ‘signal.h’ (POSIX.1): *note Termination Signals::.

‘int SIGLOST’

     ‘signal.h’ (GNU): *note Operation Error Signals::.

‘int SIGPIPE’

     ‘signal.h’ (POSIX.1): *note Operation Error Signals::.

‘int SIGPOLL’

     ‘signal.h’ (SVID): *note Asynchronous I/O Signals::.

‘int SIGPROF’

     ‘signal.h’ (BSD): *note Alarm Signals::.

‘int SIGQUIT’

     ‘signal.h’ (POSIX.1): *note Termination Signals::.

‘int SIGSEGV’

     ‘signal.h’ (ISO): *note Program Error Signals::.

‘int SIGSTOP’

     ‘signal.h’ (POSIX.1): *note Job Control Signals::.

‘int SIGSYS’

     ‘signal.h’ (Unix): *note Program Error Signals::.

‘int SIGTERM’

     ‘signal.h’ (ISO): *note Termination Signals::.

‘int SIGTRAP’

     ‘signal.h’ (BSD): *note Program Error Signals::.

‘int SIGTSTP’

     ‘signal.h’ (POSIX.1): *note Job Control Signals::.

‘int SIGTTIN’

     ‘signal.h’ (POSIX.1): *note Job Control Signals::.

‘int SIGTTOU’

     ‘signal.h’ (POSIX.1): *note Job Control Signals::.

‘int SIGURG’

     ‘signal.h’ (BSD): *note Asynchronous I/O Signals::.

‘int SIGUSR1’

     ‘signal.h’ (POSIX.1): *note Miscellaneous Signals::.

‘int SIGUSR2’

     ‘signal.h’ (POSIX.1): *note Miscellaneous Signals::.

‘int SIGVTALRM’

     ‘signal.h’ (BSD): *note Alarm Signals::.

‘int SIGWINCH’

     ‘signal.h’ (BSD): *note Miscellaneous Signals::.

‘int SIGXCPU’

     ‘signal.h’ (BSD): *note Operation Error Signals::.

‘int SIGXFSZ’

     ‘signal.h’ (BSD): *note Operation Error Signals::.

‘SIG_ATOMIC_WIDTH’

     ‘stdint.h’ (ISO): *note Width of Type::.

‘SIG_BLOCK’

     ‘signal.h’ (POSIX.1): *note Process Signal Mask::.

‘sighandler_t SIG_ERR’

     ‘signal.h’ (ISO): *note Basic Signal Handling::.

‘SIG_SETMASK’

     ‘signal.h’ (POSIX.1): *note Process Signal Mask::.

‘SIG_UNBLOCK’

     ‘signal.h’ (POSIX.1): *note Process Signal Mask::.

‘SIZE_WIDTH’

     ‘stdint.h’ (ISO): *note Width of Type::.

‘double SNAN’

     ‘math.h’ (TS 18661-1:2014): *note Infinity and NaN::.

‘float SNANF’

     ‘math.h’ (TS 18661-1:2014): *note Infinity and NaN::.

‘_FloatN SNANFN’

     ‘math.h’ (TS 18661-3:2015): *note Infinity and NaN::.

‘_FloatNx SNANFNx’

     ‘math.h’ (TS 18661-3:2015): *note Infinity and NaN::.

‘long double SNANL’

     ‘math.h’ (TS 18661-1:2014): *note Infinity and NaN::.

‘int SOCK_DGRAM’

     ‘sys/socket.h’ (BSD): *note Communication Styles::.

‘int SOCK_RAW’

     ‘sys/socket.h’ (BSD): *note Communication Styles::.

‘int SOCK_STREAM’

     ‘sys/socket.h’ (BSD): *note Communication Styles::.

‘int SOL_SOCKET’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘SO_BROADCAST’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘SO_DEBUG’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘SO_DONTROUTE’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘SO_ERROR’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘SO_KEEPALIVE’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘SO_LINGER’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘SO_OOBINLINE’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘SO_RCVBUF’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘SO_REUSEADDR’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘SO_SNDBUF’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘SO_STYLE’

     ‘sys/socket.h’ (GNU): *note Socket-Level Options::.

‘SO_TYPE’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘ssize_t SSIZE_MAX’

     ‘limits.h’ (POSIX.1): *note General Limits::.

‘STDERR_FILENO’

     ‘unistd.h’ (POSIX.1): *note Descriptors and Streams::.

‘STDIN_FILENO’

     ‘unistd.h’ (POSIX.1): *note Descriptors and Streams::.

‘STDOUT_FILENO’

     ‘unistd.h’ (POSIX.1): *note Descriptors and Streams::.

‘int STREAM_MAX’

     ‘limits.h’ (POSIX.1): *note General Limits::.

‘int SUN_LEN (_struct sockaddr_un *_ PTR)’

     ‘sys/un.h’ (BSD): *note Local Namespace Details::.

‘SYMLINK_MAX’

     ‘limits.h’ (POSIX.1): *note File Minimums::.

‘S_IEXEC’

     ‘sys/stat.h’ (BSD): *note Permission Bits::.

‘S_IFBLK’

     ‘sys/stat.h’ (BSD): *note Testing File Type::.

‘S_IFCHR’

     ‘sys/stat.h’ (BSD): *note Testing File Type::.

‘S_IFDIR’

     ‘sys/stat.h’ (BSD): *note Testing File Type::.

‘S_IFIFO’

     ‘sys/stat.h’ (BSD): *note Testing File Type::.

‘S_IFLNK’

     ‘sys/stat.h’ (BSD): *note Testing File Type::.

‘int S_IFMT’

     ‘sys/stat.h’ (BSD): *note Testing File Type::.

‘S_IFREG’

     ‘sys/stat.h’ (BSD): *note Testing File Type::.

‘S_IFSOCK’

     ‘sys/stat.h’ (BSD): *note Testing File Type::.

‘S_IREAD’

     ‘sys/stat.h’ (BSD): *note Permission Bits::.

‘S_IRGRP’

     ‘sys/stat.h’ (POSIX.1): *note Permission Bits::.

‘S_IROTH’

     ‘sys/stat.h’ (POSIX.1): *note Permission Bits::.

‘S_IRUSR’

     ‘sys/stat.h’ (POSIX.1): *note Permission Bits::.

‘S_IRWXG’

     ‘sys/stat.h’ (POSIX.1): *note Permission Bits::.

‘S_IRWXO’

     ‘sys/stat.h’ (POSIX.1): *note Permission Bits::.

‘S_IRWXU’

     ‘sys/stat.h’ (POSIX.1): *note Permission Bits::.

‘int S_ISBLK (mode_t M)’

     ‘sys/stat.h’ (POSIX): *note Testing File Type::.

‘int S_ISCHR (mode_t M)’

     ‘sys/stat.h’ (POSIX): *note Testing File Type::.

‘int S_ISDIR (mode_t M)’

     ‘sys/stat.h’ (POSIX): *note Testing File Type::.

‘int S_ISFIFO (mode_t M)’

     ‘sys/stat.h’ (POSIX): *note Testing File Type::.

‘S_ISGID’

     ‘sys/stat.h’ (POSIX): *note Permission Bits::.

‘int S_ISLNK (mode_t M)’

     ‘sys/stat.h’ (GNU): *note Testing File Type::.

‘int S_ISREG (mode_t M)’

     ‘sys/stat.h’ (POSIX): *note Testing File Type::.

‘int S_ISSOCK (mode_t M)’

     ‘sys/stat.h’ (GNU): *note Testing File Type::.

‘S_ISUID’

     ‘sys/stat.h’ (POSIX): *note Permission Bits::.

‘S_ISVTX’

     ‘sys/stat.h’ (BSD): *note Permission Bits::.

‘S_IWGRP’

     ‘sys/stat.h’ (POSIX.1): *note Permission Bits::.

‘S_IWOTH’

     ‘sys/stat.h’ (POSIX.1): *note Permission Bits::.

‘S_IWRITE’

     ‘sys/stat.h’ (BSD): *note Permission Bits::.

‘S_IWUSR’

     ‘sys/stat.h’ (POSIX.1): *note Permission Bits::.

‘S_IXGRP’

     ‘sys/stat.h’ (POSIX.1): *note Permission Bits::.

‘S_IXOTH’

     ‘sys/stat.h’ (POSIX.1): *note Permission Bits::.

‘S_IXUSR’

     ‘sys/stat.h’ (POSIX.1): *note Permission Bits::.

‘int S_TYPEISMQ (struct stat *S)’

     ‘sys/stat.h’ (POSIX): *note Testing File Type::.

‘int S_TYPEISSEM (struct stat *S)’

     ‘sys/stat.h’ (POSIX): *note Testing File Type::.

‘int S_TYPEISSHM (struct stat *S)’

     ‘sys/stat.h’ (POSIX): *note Testing File Type::.

‘TCSADRAIN’

     ‘termios.h’ (POSIX.1): *note Mode Functions::.

‘TCSAFLUSH’

     ‘termios.h’ (POSIX.1): *note Mode Functions::.

‘TCSANOW’

     ‘termios.h’ (POSIX.1): *note Mode Functions::.

‘TCSASOFT’

     ‘termios.h’ (BSD): *note Mode Functions::.

‘TEMP_FAILURE_RETRY (EXPRESSION)’

     ‘unistd.h’ (GNU): *note Interrupted Primitives::.

‘int TMP_MAX’

     ‘stdio.h’ (ISO): *note Temporary Files::.

‘tcflag_t TOSTOP’

     ‘termios.h’ (POSIX.1): *note Local Modes::.

‘TRY_AGAIN’

     ‘netdb.h’ (BSD): *note Host Names::.

‘TSS_DTOR_ITERATIONS’

     ‘threads.h’ (C11): *note ISO C Thread-local Storage::.

‘int TZNAME_MAX’

     ‘limits.h’ (POSIX.1): *note General Limits::.

‘UCHAR_MAX’

     ‘limits.h’ (ISO): *note Range of Type::.

‘UCHAR_WIDTH’

     ‘limits.h’ (ISO): *note Width of Type::.

‘UINTPTR_WIDTH’

     ‘stdint.h’ (ISO): *note Width of Type::.

‘UINT_MAX’

     ‘limits.h’ (ISO): *note Range of Type::.

‘UINT_WIDTH’

     ‘limits.h’ (ISO): *note Width of Type::.

‘ULLONG_MAX’

     ‘limits.h’ (ISO): *note Range of Type::.

‘ULLONG_WIDTH’

     ‘limits.h’ (ISO): *note Width of Type::.

‘ULONG_LONG_MAX’

     ‘limits.h’ (GNU): *note Range of Type::.

‘ULONG_MAX’

     ‘limits.h’ (ISO): *note Range of Type::.

‘ULONG_WIDTH’

     ‘limits.h’ (ISO): *note Width of Type::.

‘USER_PROCESS’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘USHRT_MAX’

     ‘limits.h’ (ISO): *note Range of Type::.

‘USHRT_WIDTH’

     ‘limits.h’ (ISO): *note Width of Type::.

‘int VDISCARD’

     ‘termios.h’ (BSD): *note Other Special::.

‘int VDSUSP’

     ‘termios.h’ (BSD): *note Signal Characters::.

‘int VEOF’

     ‘termios.h’ (POSIX.1): *note Editing Characters::.

‘int VEOL’

     ‘termios.h’ (POSIX.1): *note Editing Characters::.

‘int VEOL2’

     ‘termios.h’ (BSD): *note Editing Characters::.

‘int VERASE’

     ‘termios.h’ (POSIX.1): *note Editing Characters::.

‘int VINTR’

     ‘termios.h’ (POSIX.1): *note Signal Characters::.

‘int VKILL’

     ‘termios.h’ (POSIX.1): *note Editing Characters::.

‘int VLNEXT’

     ‘termios.h’ (BSD): *note Other Special::.

‘int VMIN’

     ‘termios.h’ (POSIX.1): *note Noncanonical Input::.

‘int VQUIT’

     ‘termios.h’ (POSIX.1): *note Signal Characters::.

‘int VREPRINT’

     ‘termios.h’ (BSD): *note Editing Characters::.

‘int VSTART’

     ‘termios.h’ (POSIX.1): *note Start/Stop Characters::.

‘int VSTATUS’

     ‘termios.h’ (BSD): *note Other Special::.

‘int VSTOP’

     ‘termios.h’ (POSIX.1): *note Start/Stop Characters::.

‘int VSUSP’

     ‘termios.h’ (POSIX.1): *note Signal Characters::.

‘int VTIME’

     ‘termios.h’ (POSIX.1): *note Noncanonical Input::.

‘int VWERASE’

     ‘termios.h’ (BSD): *note Editing Characters::.

‘WCHAR_MAX’

     ‘limits.h’ (GNU): *note Range of Type::.

‘wint_t WCHAR_MAX’

     ‘wchar.h’ (ISO): *note Extended Char Intro::.

‘wint_t WCHAR_MIN’

     ‘wchar.h’ (ISO): *note Extended Char Intro::.

‘WCHAR_WIDTH’

     ‘stdint.h’ (ISO): *note Width of Type::.

‘int WCOREDUMP (int STATUS)’

     ‘sys/wait.h’ (BSD): *note Process Completion Status::.

‘int WEOF’

     ‘wchar.h’ (ISO): *note EOF and Errors::.

‘wint_t WEOF’

     ‘wchar.h’ (ISO): *note Extended Char Intro::.

‘int WEXITSTATUS (int STATUS)’

     ‘sys/wait.h’ (POSIX.1): *note Process Completion Status::.

‘int WIFEXITED (int STATUS)’

     ‘sys/wait.h’ (POSIX.1): *note Process Completion Status::.

‘int WIFSIGNALED (int STATUS)’

     ‘sys/wait.h’ (POSIX.1): *note Process Completion Status::.

‘int WIFSTOPPED (int STATUS)’

     ‘sys/wait.h’ (POSIX.1): *note Process Completion Status::.

‘WINT_WIDTH’

     ‘stdint.h’ (ISO): *note Width of Type::.

‘WRDE_APPEND’

     ‘wordexp.h’ (POSIX.2): *note Flags for Wordexp::.

‘WRDE_BADCHAR’

     ‘wordexp.h’ (POSIX.2): *note Calling Wordexp::.

‘WRDE_BADVAL’

     ‘wordexp.h’ (POSIX.2): *note Calling Wordexp::.

‘WRDE_CMDSUB’

     ‘wordexp.h’ (POSIX.2): *note Calling Wordexp::.

‘WRDE_DOOFFS’

     ‘wordexp.h’ (POSIX.2): *note Flags for Wordexp::.

‘WRDE_NOCMD’

     ‘wordexp.h’ (POSIX.2): *note Flags for Wordexp::.

‘WRDE_NOSPACE’

     ‘wordexp.h’ (POSIX.2): *note Calling Wordexp::.

‘WRDE_REUSE’

     ‘wordexp.h’ (POSIX.2): *note Flags for Wordexp::.

‘WRDE_SHOWERR’

     ‘wordexp.h’ (POSIX.2): *note Flags for Wordexp::.

‘WRDE_SYNTAX’

     ‘wordexp.h’ (POSIX.2): *note Calling Wordexp::.

‘WRDE_UNDEF’

     ‘wordexp.h’ (POSIX.2): *note Flags for Wordexp::.

‘int WSTOPSIG (int STATUS)’

     ‘sys/wait.h’ (POSIX.1): *note Process Completion Status::.

‘int WTERMSIG (int STATUS)’

     ‘sys/wait.h’ (POSIX.1): *note Process Completion Status::.

‘int W_OK’

     ‘unistd.h’ (POSIX.1): *note Testing File Access::.

‘int X_OK’

     ‘unistd.h’ (POSIX.1): *note Testing File Access::.

‘_ATFILE_SOURCE’

     _no header_ (GNU): *note Feature Test Macros::.

‘_CS_LFS64_CFLAGS’

     ‘unistd.h’ (Unix98): *note String Parameters::.

‘_CS_LFS64_LDFLAGS’

     ‘unistd.h’ (Unix98): *note String Parameters::.

‘_CS_LFS64_LIBS’

     ‘unistd.h’ (Unix98): *note String Parameters::.

‘_CS_LFS64_LINTFLAGS’

     ‘unistd.h’ (Unix98): *note String Parameters::.

‘_CS_LFS_CFLAGS’

     ‘unistd.h’ (Unix98): *note String Parameters::.

‘_CS_LFS_LDFLAGS’

     ‘unistd.h’ (Unix98): *note String Parameters::.

‘_CS_LFS_LIBS’

     ‘unistd.h’ (Unix98): *note String Parameters::.

‘_CS_LFS_LINTFLAGS’

     ‘unistd.h’ (Unix98): *note String Parameters::.

‘_CS_PATH’

     ‘unistd.h’ (POSIX.2): *note String Parameters::.

‘const float complex _Complex_I’

     ‘complex.h’ (C99): *note Complex Numbers::.

‘_DEFAULT_SOURCE’

     _no header_ (GNU): *note Feature Test Macros::.

‘void _Exit (int STATUS)’

     ‘stdlib.h’ (ISO): *note Termination Internals::.

‘_FILE_OFFSET_BITS’

     _no header_ (X/Open): *note Feature Test Macros::.

‘_FORTIFY_SOURCE’

     _no header_ (GNU): *note Feature Test Macros::.

‘_GNU_SOURCE’

     _no header_ (GNU): *note Feature Test Macros::.

‘int _IOFBF’

     ‘stdio.h’ (ISO): *note Controlling Buffering::.

‘int _IOLBF’

     ‘stdio.h’ (ISO): *note Controlling Buffering::.

‘int _IONBF’

     ‘stdio.h’ (ISO): *note Controlling Buffering::.

‘_ISOC11_SOURCE’

     _no header_ (C11): *note Feature Test Macros::.

‘_ISOC99_SOURCE’

     _no header_ (GNU): *note Feature Test Macros::.

‘_LARGEFILE64_SOURCE’

     _no header_ (X/Open): *note Feature Test Macros::.

‘_LARGEFILE_SOURCE’

     _no header_ (X/Open): *note Feature Test Macros::.

‘_PC_ASYNC_IO’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_CHOWN_RESTRICTED’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_FILESIZEBITS’

     ‘unistd.h’ (LFS): *note Pathconf::.

‘_PC_LINK_MAX’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_MAX_CANON’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_MAX_INPUT’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_NAME_MAX’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_NO_TRUNC’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_PATH_MAX’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_PIPE_BUF’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_PRIO_IO’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_REC_INCR_XFER_SIZE’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_REC_MAX_XFER_SIZE’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_REC_MIN_XFER_SIZE’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_REC_XFER_ALIGN’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_SYNC_IO’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_PC_VDISABLE’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘_POSIX2_BC_BASE_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Minimums::.

‘_POSIX2_BC_DIM_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Minimums::.

‘_POSIX2_BC_SCALE_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Minimums::.

‘_POSIX2_BC_STRING_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Minimums::.

‘_POSIX2_COLL_WEIGHTS_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Minimums::.

‘int _POSIX2_C_DEV’

     ‘unistd.h’ (POSIX.2): *note System Options::.

‘long int _POSIX2_C_VERSION’

     ‘unistd.h’ (POSIX.2): *note Version Supported::.

‘_POSIX2_EQUIV_CLASS_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Minimums::.

‘_POSIX2_EXPR_NEST_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Minimums::.

‘int _POSIX2_FORT_DEV’

     ‘unistd.h’ (POSIX.2): *note System Options::.

‘int _POSIX2_FORT_RUN’

     ‘unistd.h’ (POSIX.2): *note System Options::.

‘_POSIX2_LINE_MAX’

     ‘limits.h’ (POSIX.2): *note Utility Minimums::.

‘int _POSIX2_LOCALEDEF’

     ‘unistd.h’ (POSIX.2): *note System Options::.

‘_POSIX2_RE_DUP_MAX’

     ‘limits.h’ (POSIX.2): *note Minimums::.

‘int _POSIX2_SW_DEV’

     ‘unistd.h’ (POSIX.2): *note System Options::.

‘_POSIX_AIO_LISTIO_MAX’

     ‘limits.h’ (POSIX.1): *note Minimums::.

‘_POSIX_AIO_MAX’

     ‘limits.h’ (POSIX.1): *note Minimums::.

‘_POSIX_ARG_MAX’

     ‘limits.h’ (POSIX.1): *note Minimums::.

‘_POSIX_CHILD_MAX’

     ‘limits.h’ (POSIX.1): *note Minimums::.

‘int _POSIX_CHOWN_RESTRICTED’

     ‘unistd.h’ (POSIX.1): *note Options for Files::.

‘_POSIX_C_SOURCE’

     _no header_ (POSIX.2): *note Feature Test Macros::.

‘int _POSIX_JOB_CONTROL’

     ‘unistd.h’ (POSIX.1): *note System Options::.

‘_POSIX_LINK_MAX’

     ‘limits.h’ (POSIX.1): *note File Minimums::.

‘_POSIX_MAX_CANON’

     ‘limits.h’ (POSIX.1): *note File Minimums::.

‘_POSIX_MAX_INPUT’

     ‘limits.h’ (POSIX.1): *note File Minimums::.

‘_POSIX_NAME_MAX’

     ‘limits.h’ (POSIX.1): *note File Minimums::.

‘_POSIX_NGROUPS_MAX’

     ‘limits.h’ (POSIX.1): *note Minimums::.

‘int _POSIX_NO_TRUNC’

     ‘unistd.h’ (POSIX.1): *note Options for Files::.

‘_POSIX_OPEN_MAX’

     ‘limits.h’ (POSIX.1): *note Minimums::.

‘_POSIX_PATH_MAX’

     ‘limits.h’ (POSIX.1): *note File Minimums::.

‘_POSIX_PIPE_BUF’

     ‘limits.h’ (POSIX.1): *note File Minimums::.

‘int _POSIX_SAVED_IDS’

     ‘unistd.h’ (POSIX.1): *note System Options::.

‘_POSIX_SOURCE’

     _no header_ (POSIX.1): *note Feature Test Macros::.

‘_POSIX_SSIZE_MAX’

     ‘limits.h’ (POSIX.1): *note Minimums::.

‘_POSIX_STREAM_MAX’

     ‘limits.h’ (POSIX.1): *note Minimums::.

‘_POSIX_TZNAME_MAX’

     ‘limits.h’ (POSIX.1): *note Minimums::.

‘unsigned char _POSIX_VDISABLE’

     ‘unistd.h’ (POSIX.1): *note Options for Files::.

‘long int _POSIX_VERSION’

     ‘unistd.h’ (POSIX.1): *note Version Supported::.

‘_REENTRANT’

     _no header_ (Obsolete): *note Feature Test Macros::.

‘_SC_2_C_DEV’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_2_FORT_DEV’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_2_FORT_RUN’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_2_LOCALEDEF’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_2_SW_DEV’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_2_VERSION’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_AIO_LISTIO_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_AIO_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_AIO_PRIO_DELTA_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_ARG_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_ASYNCHRONOUS_IO’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_ATEXIT_MAX’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_AVPHYS_PAGES’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_BC_BASE_MAX’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_BC_DIM_MAX’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_BC_SCALE_MAX’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_BC_STRING_MAX’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_CHARCLASS_NAME_MAX’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_CHAR_BIT’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_CHAR_MAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_CHAR_MIN’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_CHILD_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_CLK_TCK’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_COLL_WEIGHTS_MAX’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_DELAYTIMER_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_EQUIV_CLASS_MAX’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_EXPR_NEST_MAX’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_FSYNC’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_GETGR_R_SIZE_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_GETPW_R_SIZE_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_INT_MAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_INT_MIN’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_JOB_CONTROL’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_LEVEL1_DCACHE_ASSOC’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL1_DCACHE_LINESIZE’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL1_DCACHE_SIZE’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL1_ICACHE_ASSOC’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL1_ICACHE_LINESIZE’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL1_ICACHE_SIZE’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL2_CACHE_ASSOC’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL2_CACHE_LINESIZE’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL2_CACHE_SIZE’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL3_CACHE_ASSOC’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL3_CACHE_LINESIZE’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL3_CACHE_SIZE’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL4_CACHE_ASSOC’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL4_CACHE_LINESIZE’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LEVEL4_CACHE_SIZE’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_LINE_MAX’

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_LOGIN_NAME_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_LONG_BIT’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_MAPPED_FILES’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_MB_LEN_MAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_MEMLOCK’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_MEMLOCK_RANGE’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_MEMORY_PROTECTION’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_MESSAGE_PASSING’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_MQ_OPEN_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_MQ_PRIO_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_NGROUPS_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_NL_ARGMAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_NL_LANGMAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_NL_MSGMAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_NL_NMAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_NL_SETMAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_NL_TEXTMAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_NPROCESSORS_CONF’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_NPROCESSORS_ONLN’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_NZERO’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_OPEN_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_PAGESIZE’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_PHYS_PAGES’

     ‘unistd.h’ (GNU): *note Constants for Sysconf::.

‘_SC_PII’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_PII_INTERNET’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_PII_INTERNET_DGRAM’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_PII_INTERNET_STREAM’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_PII_OSI’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_PII_OSI_CLTS’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_PII_OSI_COTS’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_PII_OSI_M’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_PII_SOCKET’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_PII_XTI’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_PRIORITIZED_IO’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_PRIORITY_SCHEDULING’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_REALTIME_SIGNALS’

     ‘unistdh.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_RTSIG_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_SAVED_IDS’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_SCHAR_MAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_SCHAR_MIN’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_SELECT’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_SEMAPHORES’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_SEM_NSEMS_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_SEM_VALUE_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_SHARED_MEMORY_OBJECTS’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_SHRT_MAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_SHRT_MIN’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_SIGQUEUE_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_SSIZE_MAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_STREAM_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_SYNCHRONIZED_IO’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_THREADS’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_THREAD_ATTR_STACKADDR’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_THREAD_ATTR_STACKSIZE’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_THREAD_DESTRUCTOR_ITERATIONS’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_THREAD_KEYS_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_THREAD_PRIORITY_SCHEDULING’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_THREAD_PRIO_INHERIT’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_THREAD_PRIO_PROTECT’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_THREAD_PROCESS_SHARED’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_THREAD_SAFE_FUNCTIONS’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_THREAD_STACK_MIN’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_THREAD_THREADS_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_TIMERS’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_TIMER_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_TTY_NAME_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_TZNAME_MAX’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

‘_SC_T_IOV_MAX’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_UCHAR_MAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_UINT_MAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_UIO_MAXIOV’

     ‘unistd.h’ (POSIX.1g): *note Constants for Sysconf::.

‘_SC_ULONG_MAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_USHRT_MAX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_VERSION’

     ‘unistd.h’ (POSIX.1): *note Constants for Sysconf::.

     ‘unistd.h’ (POSIX.2): *note Constants for Sysconf::.

‘_SC_WORD_BIT’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_XOPEN_CRYPT’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_XOPEN_ENH_I18N’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_XOPEN_LEGACY’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_XOPEN_REALTIME’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_XOPEN_REALTIME_THREADS’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_XOPEN_SHM’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_XOPEN_UNIX’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_XOPEN_VERSION’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_XOPEN_XCU_VERSION’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_XOPEN_XPG2’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_XOPEN_XPG3’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_SC_XOPEN_XPG4’

     ‘unistd.h’ (X/Open): *note Constants for Sysconf::.

‘_THREAD_SAFE’

     _no header_ (Obsolete): *note Feature Test Macros::.

‘_XOPEN_SOURCE’

     _no header_ (X/Open): *note Feature Test Macros::.

‘_XOPEN_SOURCE_EXTENDED’

     _no header_ (X/Open): *note Feature Test Macros::.

‘__STDC_WANT_IEC_60559_BFP_EXT__’

     _no header_ (ISO): *note Feature Test Macros::.

‘__STDC_WANT_IEC_60559_FUNCS_EXT__’

     _no header_ (ISO): *note Feature Test Macros::.

‘__STDC_WANT_IEC_60559_TYPES_EXT__’

     _no header_ (ISO): *note Feature Test Macros::.

‘__STDC_WANT_LIB_EXT2__’

     _no header_ (ISO): *note Feature Test Macros::.

‘size_t __fbufsize (FILE *STREAM)’

     ‘stdio_ext.h’ (GNU): *note Controlling Buffering::.

‘int __flbf (FILE *STREAM)’

     ‘stdio_ext.h’ (GNU): *note Controlling Buffering::.

‘size_t __fpending (FILE *STREAM)’

     ‘stdio_ext.h’ (GNU): *note Controlling Buffering::.

‘void __fpurge (FILE *STREAM)’

     ‘stdio_ext.h’ (GNU): *note Flushing Buffers::.

‘int __freadable (FILE *STREAM)’

     ‘stdio_ext.h’ (GNU): *note Opening Streams::.

‘int __freading (FILE *STREAM)’

     ‘stdio_ext.h’ (GNU): *note Opening Streams::.

‘__free_hook’

     ‘malloc.h’ (GNU): *note Hooks for Malloc::.

‘int __fsetlocking (FILE *STREAM, int TYPE)’

     ‘stdio_ext.h’ (GNU): *note Streams and Threads::.

‘__ftw64_func_t’

     ‘ftw.h’ (GNU): *note Working with Directory Trees::.

‘__ftw_func_t’

     ‘ftw.h’ (GNU): *note Working with Directory Trees::.

‘int __fwritable (FILE *STREAM)’

     ‘stdio_ext.h’ (GNU): *note Opening Streams::.

‘int __fwriting (FILE *STREAM)’

     ‘stdio_ext.h’ (GNU): *note Opening Streams::.

‘void (*__gconv_end_fct) (struct gconv_step *)’

     ‘gconv.h’ (GNU): *note glibc iconv Implementation::.

‘int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *, const char **, const char *, size_t *, int)’

     ‘gconv.h’ (GNU): *note glibc iconv Implementation::.

‘int (*__gconv_init_fct) (struct __gconv_step *)’

     ‘gconv.h’ (GNU): *note glibc iconv Implementation::.

‘struct __gconv_step’

     ‘gconv.h’ (GNU): *note glibc iconv Implementation::.

‘struct __gconv_step_data’

     ‘gconv.h’ (GNU): *note glibc iconv Implementation::.

‘__malloc_hook’

     ‘malloc.h’ (GNU): *note Hooks for Malloc::.

‘__memalign_hook’

     ‘malloc.h’ (GNU): *note Hooks for Malloc::.

‘__nftw64_func_t’

     ‘ftw.h’ (GNU): *note Working with Directory Trees::.

‘__nftw_func_t’

     ‘ftw.h’ (GNU): *note Working with Directory Trees::.

‘__realloc_hook’

     ‘malloc.h’ (GNU): *note Hooks for Malloc::.

‘void __va_copy (va_list DEST, va_list SRC)’

     ‘stdarg.h’ (GNU): *note Argument Macros::.

‘void _exit (int STATUS)’

     ‘unistd.h’ (POSIX.1): *note Termination Internals::.

‘void _flushlbf (void)’

     ‘stdio_ext.h’ (GNU): *note Flushing Buffers::.

‘int _tolower (int C)’

     ‘ctype.h’ (SVID): *note Case Conversion::.

‘int _toupper (int C)’

     ‘ctype.h’ (SVID): *note Case Conversion::.

‘long int a64l (const char *STRING)’

     ‘stdlib.h’ (XPG): *note Encode Binary Data::.

‘void abort (void)’

     ‘stdlib.h’ (ISO): *note Aborting a Program::.

‘int abs (int NUMBER)’

     ‘stdlib.h’ (ISO): *note Absolute Value::.

‘int accept (int SOCKET, struct sockaddr *ADDR, socklen_t *LENGTH_PTR)’

     ‘sys/socket.h’ (BSD): *note Accepting Connections::.

‘int access (const char *FILENAME, int HOW)’

     ‘unistd.h’ (POSIX.1): *note Testing File Access::.

‘double acos (double X)’

     ‘math.h’ (ISO): *note Inverse Trig Functions::.

‘float acosf (float X)’

     ‘math.h’ (ISO): *note Inverse Trig Functions::.

‘_FloatN acosfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘_FloatNx acosfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘double acosh (double X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘float acoshf (float X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘_FloatN acoshfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘_FloatNx acoshfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘long double acoshl (long double X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘long double acosl (long double X)’

     ‘math.h’ (ISO): *note Inverse Trig Functions::.

‘int addmntent (FILE *STREAM, const struct mntent *MNT)’

     ‘mntent.h’ (BSD): *note mtab::.

‘int adjtime (const struct timeval *DELTA, struct timeval *OLDDELTA)’

     ‘sys/time.h’ (BSD): *note High-Resolution Calendar::.

‘int adjtimex (struct timex *TIMEX)’

     ‘sys/timex.h’ (GNU): *note High-Resolution Calendar::.

‘int aio_cancel (int FILDES, struct aiocb *AIOCBP)’

     ‘aio.h’ (POSIX.1b): *note Cancel AIO Operations::.

‘int aio_cancel64 (int FILDES, struct aiocb64 *AIOCBP)’

     ‘aio.h’ (Unix98): *note Cancel AIO Operations::.

‘int aio_error (const struct aiocb *AIOCBP)’

     ‘aio.h’ (POSIX.1b): *note Status of AIO Operations::.

‘int aio_error64 (const struct aiocb64 *AIOCBP)’

     ‘aio.h’ (Unix98): *note Status of AIO Operations::.

‘int aio_fsync (int OP, struct aiocb *AIOCBP)’

     ‘aio.h’ (POSIX.1b): *note Synchronizing AIO Operations::.

‘int aio_fsync64 (int OP, struct aiocb64 *AIOCBP)’

     ‘aio.h’ (Unix98): *note Synchronizing AIO Operations::.

‘void aio_init (const struct aioinit *INIT)’

     ‘aio.h’ (GNU): *note Configuration of AIO::.

‘int aio_read (struct aiocb *AIOCBP)’

     ‘aio.h’ (POSIX.1b): *note Asynchronous Reads/Writes::.

‘int aio_read64 (struct aiocb64 *AIOCBP)’

     ‘aio.h’ (Unix98): *note Asynchronous Reads/Writes::.

‘ssize_t aio_return (struct aiocb *AIOCBP)’

     ‘aio.h’ (POSIX.1b): *note Status of AIO Operations::.

‘ssize_t aio_return64 (struct aiocb64 *AIOCBP)’

     ‘aio.h’ (Unix98): *note Status of AIO Operations::.

‘int aio_suspend (const struct aiocb *const LIST[], int NENT, const struct timespec *TIMEOUT)’

     ‘aio.h’ (POSIX.1b): *note Synchronizing AIO Operations::.

‘int aio_suspend64 (const struct aiocb64 *const LIST[], int NENT, const struct timespec *TIMEOUT)’

     ‘aio.h’ (Unix98): *note Synchronizing AIO Operations::.

‘int aio_write (struct aiocb *AIOCBP)’

     ‘aio.h’ (POSIX.1b): *note Asynchronous Reads/Writes::.

‘int aio_write64 (struct aiocb64 *AIOCBP)’

     ‘aio.h’ (Unix98): *note Asynchronous Reads/Writes::.

‘struct aiocb’

     ‘aio.h’ (POSIX.1b): *note Asynchronous I/O::.

‘struct aiocb64’

     ‘aio.h’ (POSIX.1b): *note Asynchronous I/O::.

‘struct aioinit’

     ‘aio.h’ (GNU): *note Configuration of AIO::.

‘unsigned int alarm (unsigned int SECONDS)’

     ‘unistd.h’ (POSIX.1): *note Setting an Alarm::.

‘void * aligned_alloc (size_t ALIGNMENT, size_t SIZE)’

     ‘stdlib.h’ (???): *note Aligned Memory Blocks::.

‘void * alloca (size_t SIZE)’

     ‘stdlib.h’ (GNU): *note Variable Size Automatic::.

     ‘stdlib.h’ (BSD): *note Variable Size Automatic::.

‘int alphasort (const struct dirent **A, const struct dirent **B)’

     ‘dirent.h’ (BSD): *note Scanning Directory Content::.

     ‘dirent.h’ (SVID): *note Scanning Directory Content::.

‘int alphasort64 (const struct dirent64 **A, const struct dirent **B)’

     ‘dirent.h’ (GNU): *note Scanning Directory Content::.

‘struct argp’

     ‘argp.h’ (GNU): *note Argp Parsers::.

‘struct argp_child’

     ‘argp.h’ (GNU): *note Argp Children::.

‘error_t argp_err_exit_status’

     ‘argp.h’ (GNU): *note Argp Global Variables::.

‘void argp_error (const struct argp_state *STATE, const char *FMT, …)’

     ‘argp.h’ (GNU): *note Argp Helper Functions::.

‘void argp_failure (const struct argp_state *STATE, int STATUS, int ERRNUM, const char *FMT, …)’

     ‘argp.h’ (GNU): *note Argp Helper Functions::.

‘void argp_help (const struct argp *ARGP, FILE *STREAM, unsigned FLAGS, char *NAME)’

     ‘argp.h’ (GNU): *note Argp Help::.

‘struct argp_option’

     ‘argp.h’ (GNU): *note Argp Option Vectors::.

‘error_t argp_parse (const struct argp *ARGP, int ARGC, char **ARGV, unsigned FLAGS, int *ARG_INDEX, void *INPUT)’

     ‘argp.h’ (GNU): *note Argp::.

‘const char * argp_program_bug_address’

     ‘argp.h’ (GNU): *note Argp Global Variables::.

‘const char * argp_program_version’

     ‘argp.h’ (GNU): *note Argp Global Variables::.

‘argp_program_version_hook’

     ‘argp.h’ (GNU): *note Argp Global Variables::.

‘struct argp_state’

     ‘argp.h’ (GNU): *note Argp Parsing State::.

‘void argp_state_help (const struct argp_state *STATE, FILE *STREAM, unsigned FLAGS)’

     ‘argp.h’ (GNU): *note Argp Helper Functions::.

‘void argp_usage (const struct argp_state *STATE)’

     ‘argp.h’ (GNU): *note Argp Helper Functions::.

‘error_t argz_add (char **ARGZ, size_t *ARGZ_LEN, const char *STR)’

     ‘argz.h’ (GNU): *note Argz Functions::.

‘error_t argz_add_sep (char **ARGZ, size_t *ARGZ_LEN, const char *STR, int DELIM)’

     ‘argz.h’ (GNU): *note Argz Functions::.

‘error_t argz_append (char **ARGZ, size_t *ARGZ_LEN, const char *BUF, size_t BUF_LEN)’

     ‘argz.h’ (GNU): *note Argz Functions::.

‘size_t argz_count (const char *ARGZ, size_t ARGZ_LEN)’

     ‘argz.h’ (GNU): *note Argz Functions::.

‘error_t argz_create (char *const ARGV[], char **ARGZ, size_t *ARGZ_LEN)’

     ‘argz.h’ (GNU): *note Argz Functions::.

‘error_t argz_create_sep (const char *STRING, int SEP, char **ARGZ, size_t *ARGZ_LEN)’

     ‘argz.h’ (GNU): *note Argz Functions::.

‘void argz_delete (char **ARGZ, size_t *ARGZ_LEN, char *ENTRY)’

     ‘argz.h’ (GNU): *note Argz Functions::.

‘void argz_extract (const char *ARGZ, size_t ARGZ_LEN, char **ARGV)’

     ‘argz.h’ (GNU): *note Argz Functions::.

‘error_t argz_insert (char **ARGZ, size_t *ARGZ_LEN, char *BEFORE, const char *ENTRY)’

     ‘argz.h’ (GNU): *note Argz Functions::.

‘char * argz_next (const char *ARGZ, size_t ARGZ_LEN, const char *ENTRY)’

     ‘argz.h’ (GNU): *note Argz Functions::.

‘error_t argz_replace (char **ARGZ, size_t *ARGZ_LEN, const char *STR, const char *WITH, unsigned *REPLACE_COUNT)’

     ‘argz.h’ (GNU): *note Argz Functions::.

‘void argz_stringify (char *ARGZ, size_t LEN, int SEP)’

     ‘argz.h’ (GNU): *note Argz Functions::.

‘char * asctime (const struct tm *BROKENTIME)’

     ‘time.h’ (ISO): *note Formatting Calendar Time::.

‘char * asctime_r (const struct tm *BROKENTIME, char *BUFFER)’

     ‘time.h’ (POSIX.1c): *note Formatting Calendar Time::.

‘double asin (double X)’

     ‘math.h’ (ISO): *note Inverse Trig Functions::.

‘float asinf (float X)’

     ‘math.h’ (ISO): *note Inverse Trig Functions::.

‘_FloatN asinfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘_FloatNx asinfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘double asinh (double X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘float asinhf (float X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘_FloatN asinhfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘_FloatNx asinhfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘long double asinhl (long double X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘long double asinl (long double X)’

     ‘math.h’ (ISO): *note Inverse Trig Functions::.

‘int asprintf (char **PTR, const char *TEMPLATE, …)’

     ‘stdio.h’ (GNU): *note Dynamic Output::.

‘void assert (int EXPRESSION)’

     ‘assert.h’ (ISO): *note Consistency Checking::.

‘void assert_perror (int ERRNUM)’

     ‘assert.h’ (GNU): *note Consistency Checking::.

‘double atan (double X)’

     ‘math.h’ (ISO): *note Inverse Trig Functions::.

‘double atan2 (double Y, double X)’

     ‘math.h’ (ISO): *note Inverse Trig Functions::.

‘float atan2f (float Y, float X)’

     ‘math.h’ (ISO): *note Inverse Trig Functions::.

‘_FloatN atan2fN (_FloatN Y, _FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘_FloatNx atan2fNx (_FloatNx Y, _FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘long double atan2l (long double Y, long double X)’

     ‘math.h’ (ISO): *note Inverse Trig Functions::.

‘float atanf (float X)’

     ‘math.h’ (ISO): *note Inverse Trig Functions::.

‘_FloatN atanfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘_FloatNx atanfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘double atanh (double X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘float atanhf (float X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘_FloatN atanhfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘_FloatNx atanhfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘long double atanhl (long double X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘long double atanl (long double X)’

     ‘math.h’ (ISO): *note Inverse Trig Functions::.

‘int atexit (void (*FUNCTION) (void))’

     ‘stdlib.h’ (ISO): *note Cleanups on Exit::.

‘double atof (const char *STRING)’

     ‘stdlib.h’ (ISO): *note Parsing of Floats::.

‘int atoi (const char *STRING)’

     ‘stdlib.h’ (ISO): *note Parsing of Integers::.

‘long int atol (const char *STRING)’

     ‘stdlib.h’ (ISO): *note Parsing of Integers::.

‘long long int atoll (const char *STRING)’

     ‘stdlib.h’ (ISO): *note Parsing of Integers::.

‘int backtrace (void **BUFFER, int SIZE)’

     ‘execinfo.h’ (GNU): *note Backtraces::.

‘char ** backtrace_symbols (void *const *BUFFER, int SIZE)’

     ‘execinfo.h’ (GNU): *note Backtraces::.

‘void backtrace_symbols_fd (void *const *BUFFER, int SIZE, int FD)’

     ‘execinfo.h’ (GNU): *note Backtraces::.

‘char * basename (char *PATH)’

     ‘libgen.h’ (XPG): *note Finding Tokens in a String::.

‘char * basename (const char *FILENAME)’

     ‘string.h’ (GNU): *note Finding Tokens in a String::.

‘int bcmp (const void *A1, const void *A2, size_t SIZE)’

     ‘string.h’ (BSD): *note String/Array Comparison::.

‘void bcopy (const void *FROM, void *TO, size_t SIZE)’

     ‘string.h’ (BSD): *note Copying Strings and Arrays::.

‘int bind (int SOCKET, struct sockaddr *ADDR, socklen_t LENGTH)’

     ‘sys/socket.h’ (BSD): *note Setting Address::.

‘char * bind_textdomain_codeset (const char *DOMAINNAME, const char *CODESET)’

     ‘libintl.h’ (GNU): *note Charset conversion in gettext::.

‘char * bindtextdomain (const char *DOMAINNAME, const char *DIRNAME)’

     ‘libintl.h’ (GNU): *note Locating gettext catalog::.

‘blkcnt64_t’

     ‘sys/types.h’ (Unix98): *note Attribute Meanings::.

‘blkcnt_t’

     ‘sys/types.h’ (Unix98): *note Attribute Meanings::.

‘int brk (void *ADDR)’

     ‘unistd.h’ (BSD): *note Resizing the Data Segment::.

‘void * bsearch (const void *KEY, const void *ARRAY, size_t COUNT, size_t SIZE, comparison_fn_t COMPARE)’

     ‘stdlib.h’ (ISO): *note Array Search Function::.

‘wint_t btowc (int C)’

     ‘wchar.h’ (ISO): *note Converting a Character::.

‘void bzero (void *BLOCK, size_t SIZE)’

     ‘string.h’ (BSD): *note Copying Strings and Arrays::.

‘double cabs (complex double Z)’

     ‘complex.h’ (ISO): *note Absolute Value::.

‘float cabsf (complex float Z)’

     ‘complex.h’ (ISO): *note Absolute Value::.

‘_FloatN cabsfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Absolute Value::.

‘_FloatNx cabsfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Absolute Value::.

‘long double cabsl (complex long double Z)’

     ‘complex.h’ (ISO): *note Absolute Value::.

‘complex double cacos (complex double Z)’

     ‘complex.h’ (ISO): *note Inverse Trig Functions::.

‘complex float cacosf (complex float Z)’

     ‘complex.h’ (ISO): *note Inverse Trig Functions::.

‘complex _FloatN cacosfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘complex _FloatNx cacosfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘complex double cacosh (complex double Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex float cacoshf (complex float Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex _FloatN cacoshfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘complex _FloatNx cacoshfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘complex long double cacoshl (complex long double Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex long double cacosl (complex long double Z)’

     ‘complex.h’ (ISO): *note Inverse Trig Functions::.

‘void call_once (once_flag *FLAG, void (*FUNC) (void))’

     ‘threads.h’ (C11): *note Call Once::.

‘void * calloc (size_t COUNT, size_t ELTSIZE)’

     ‘malloc.h’ (ISO): *note Allocating Cleared Space::.

     ‘stdlib.h’ (ISO): *note Allocating Cleared Space::.

‘int canonicalize (double *CX, const double *X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘char * canonicalize_file_name (const char *NAME)’

     ‘stdlib.h’ (GNU): *note Symbolic Links::.

‘int canonicalizef (float *CX, const float *X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘int canonicalizefN (_FloatN *CX, const _FloatN *X)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘int canonicalizefNx (_FloatNx *CX, const _FloatNx *X)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘int canonicalizel (long double *CX, const long double *X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘double carg (complex double Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘float cargf (complex float Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘_FloatN cargfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Operations on Complex::.

‘_FloatNx cargfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Operations on Complex::.

‘long double cargl (complex long double Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘complex double casin (complex double Z)’

     ‘complex.h’ (ISO): *note Inverse Trig Functions::.

‘complex float casinf (complex float Z)’

     ‘complex.h’ (ISO): *note Inverse Trig Functions::.

‘complex _FloatN casinfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘complex _FloatNx casinfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘complex double casinh (complex double Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex float casinhf (complex float Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex _FloatN casinhfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘complex _FloatNx casinhfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘complex long double casinhl (complex long double Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex long double casinl (complex long double Z)’

     ‘complex.h’ (ISO): *note Inverse Trig Functions::.

‘complex double catan (complex double Z)’

     ‘complex.h’ (ISO): *note Inverse Trig Functions::.

‘complex float catanf (complex float Z)’

     ‘complex.h’ (ISO): *note Inverse Trig Functions::.

‘complex _FloatN catanfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘complex _FloatNx catanfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Inverse Trig Functions::.

‘complex double catanh (complex double Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex float catanhf (complex float Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex _FloatN catanhfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘complex _FloatNx catanhfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘complex long double catanhl (complex long double Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex long double catanl (complex long double Z)’

     ‘complex.h’ (ISO): *note Inverse Trig Functions::.

‘nl_catd catopen (const char *CAT_NAME, int FLAG)’

     ‘nl_types.h’ (X/Open): *note The catgets Functions::.

‘double cbrt (double X)’

     ‘math.h’ (BSD): *note Exponents and Logarithms::.

‘float cbrtf (float X)’

     ‘math.h’ (BSD): *note Exponents and Logarithms::.

‘_FloatN cbrtfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘_FloatNx cbrtfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long double cbrtl (long double X)’

     ‘math.h’ (BSD): *note Exponents and Logarithms::.

‘cc_t’

     ‘termios.h’ (POSIX.1): *note Mode Data Types::.

‘complex double ccos (complex double Z)’

     ‘complex.h’ (ISO): *note Trig Functions::.

‘complex float ccosf (complex float Z)’

     ‘complex.h’ (ISO): *note Trig Functions::.

‘complex _FloatN ccosfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Trig Functions::.

‘complex _FloatNx ccosfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Trig Functions::.

‘complex double ccosh (complex double Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex float ccoshf (complex float Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex _FloatN ccoshfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘complex _FloatNx ccoshfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘complex long double ccoshl (complex long double Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex long double ccosl (complex long double Z)’

     ‘complex.h’ (ISO): *note Trig Functions::.

‘double ceil (double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘float ceilf (float X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘_FloatN ceilfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘_FloatNx ceilfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long double ceill (long double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘complex double cexp (complex double Z)’

     ‘complex.h’ (ISO): *note Exponents and Logarithms::.

‘complex float cexpf (complex float Z)’

     ‘complex.h’ (ISO): *note Exponents and Logarithms::.

‘complex _FloatN cexpfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘complex _FloatNx cexpfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘complex long double cexpl (complex long double Z)’

     ‘complex.h’ (ISO): *note Exponents and Logarithms::.

‘speed_t cfgetispeed (const struct termios *TERMIOS-P)’

     ‘termios.h’ (POSIX.1): *note Line Speed::.

‘speed_t cfgetospeed (const struct termios *TERMIOS-P)’

     ‘termios.h’ (POSIX.1): *note Line Speed::.

‘void cfmakeraw (struct termios *TERMIOS-P)’

     ‘termios.h’ (BSD): *note Noncanonical Input::.

‘int cfsetispeed (struct termios *TERMIOS-P, speed_t SPEED)’

     ‘termios.h’ (POSIX.1): *note Line Speed::.

‘int cfsetospeed (struct termios *TERMIOS-P, speed_t SPEED)’

     ‘termios.h’ (POSIX.1): *note Line Speed::.

‘int cfsetspeed (struct termios *TERMIOS-P, speed_t SPEED)’

     ‘termios.h’ (BSD): *note Line Speed::.

‘int chdir (const char *FILENAME)’

     ‘unistd.h’ (POSIX.1): *note Working Directory::.

‘int chmod (const char *FILENAME, mode_t MODE)’

     ‘sys/stat.h’ (POSIX.1): *note Setting Permissions::.

‘int chown (const char *FILENAME, uid_t OWNER, gid_t GROUP)’

     ‘unistd.h’ (POSIX.1): *note File Owner::.

‘double cimag (complex double Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘float cimagf (complex float Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘_FloatN cimagfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Operations on Complex::.

‘_FloatNx cimagfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Operations on Complex::.

‘long double cimagl (complex long double Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘int clearenv (void)’

     ‘stdlib.h’ (GNU): *note Environment Access::.

‘void clearerr (FILE *STREAM)’

     ‘stdio.h’ (ISO): *note Error Recovery::.

‘void clearerr_unlocked (FILE *STREAM)’

     ‘stdio.h’ (GNU): *note Error Recovery::.

‘clock_t clock (void)’

     ‘time.h’ (ISO): *note CPU Time::.

‘clock_t’

     ‘time.h’ (ISO): *note CPU Time::.

‘complex double clog (complex double Z)’

     ‘complex.h’ (ISO): *note Exponents and Logarithms::.

‘complex double clog10 (complex double Z)’

     ‘complex.h’ (GNU): *note Exponents and Logarithms::.

‘complex float clog10f (complex float Z)’

     ‘complex.h’ (GNU): *note Exponents and Logarithms::.

‘complex _FloatN clog10fN (complex _FloatN Z)’

     ‘complex.h’ (GNU): *note Exponents and Logarithms::.

‘complex _FloatNx clog10fNx (complex _FloatNx Z)’

     ‘complex.h’ (GNU): *note Exponents and Logarithms::.

‘complex long double clog10l (complex long double Z)’

     ‘complex.h’ (GNU): *note Exponents and Logarithms::.

‘complex float clogf (complex float Z)’

     ‘complex.h’ (ISO): *note Exponents and Logarithms::.

‘complex _FloatN clogfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘complex _FloatNx clogfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘complex long double clogl (complex long double Z)’

     ‘complex.h’ (ISO): *note Exponents and Logarithms::.

‘int close (int FILEDES)’

     ‘unistd.h’ (POSIX.1): *note Opening and Closing Files::.

‘int closedir (DIR *DIRSTREAM)’

     ‘dirent.h’ (POSIX.1): *note Reading/Closing Directory::.

‘void closelog (void)’

     ‘syslog.h’ (BSD): *note closelog::.

‘int cnd_broadcast (cnd_t *COND)’

     ‘threads.h’ (C11): *note ISO C Condition Variables::.

‘void cnd_destroy (cnd_t *COND)’

     ‘threads.h’ (C11): *note ISO C Condition Variables::.

‘int cnd_init (cnd_t *COND)’

     ‘threads.h’ (C11): *note ISO C Condition Variables::.

‘int cnd_signal (cnd_t *COND)’

     ‘threads.h’ (C11): *note ISO C Condition Variables::.

‘cnd_t’

     ‘threads.h’ (C11): *note ISO C Condition Variables::.

‘int cnd_timedwait (cnd_t *restrict COND, mtx_t *restrict MUTEX, const struct timespec *restrict TIME_POINT)’

     ‘threads.h’ (C11): *note ISO C Condition Variables::.

‘int cnd_wait (cnd_t *COND, mtx_t *MUTEX)’

     ‘threads.h’ (C11): *note ISO C Condition Variables::.

‘size_t confstr (int PARAMETER, char *BUF, size_t LEN)’

     ‘unistd.h’ (POSIX.2): *note String Parameters::.

‘complex double conj (complex double Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘complex float conjf (complex float Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘complex _FloatN conjfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Operations on Complex::.

‘complex _FloatNx conjfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Operations on Complex::.

‘complex long double conjl (complex long double Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘int connect (int SOCKET, struct sockaddr *ADDR, socklen_t LENGTH)’

     ‘sys/socket.h’ (BSD): *note Connecting::.

‘cookie_close_function_t’

     ‘stdio.h’ (GNU): *note Hook Functions::.

‘cookie_io_functions_t’

     ‘stdio.h’ (GNU): *note Streams and Cookies::.

‘cookie_read_function_t’

     ‘stdio.h’ (GNU): *note Hook Functions::.

‘cookie_seek_function_t’

     ‘stdio.h’ (GNU): *note Hook Functions::.

‘cookie_write_function_t’

     ‘stdio.h’ (GNU): *note Hook Functions::.

‘ssize_t copy_file_range (int INPUTFD, off64_t *INPUTPOS, int OUTPUTFD, off64_t *OUTPUTPOS, ssize_t LENGTH, unsigned int FLAGS)’

     ‘unistd.h’ (GNU): *note Copying File Data::.

‘double copysign (double X, double Y)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘float copysignf (float X, float Y)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘_FloatN copysignfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘_FloatNx copysignfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘long double copysignl (long double X, long double Y)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘double cos (double X)’

     ‘math.h’ (ISO): *note Trig Functions::.

‘float cosf (float X)’

     ‘math.h’ (ISO): *note Trig Functions::.

‘_FloatN cosfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Trig Functions::.

‘_FloatNx cosfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Trig Functions::.

‘double cosh (double X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘float coshf (float X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘_FloatN coshfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘_FloatNx coshfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘long double coshl (long double X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘long double cosl (long double X)’

     ‘math.h’ (ISO): *note Trig Functions::.

‘complex double cpow (complex double BASE, complex double POWER)’

     ‘complex.h’ (ISO): *note Exponents and Logarithms::.

‘complex float cpowf (complex float BASE, complex float POWER)’

     ‘complex.h’ (ISO): *note Exponents and Logarithms::.

‘complex _FloatN cpowfN (complex _FloatN BASE, complex _FloatN POWER)’

     ‘complex.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘complex _FloatNx cpowfNx (complex _FloatNx BASE, complex _FloatNx POWER)’

     ‘complex.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘complex long double cpowl (complex long double BASE, complex long double POWER)’

     ‘complex.h’ (ISO): *note Exponents and Logarithms::.

‘complex double cproj (complex double Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘complex float cprojf (complex float Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘complex _FloatN cprojfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Operations on Complex::.

‘complex _FloatNx cprojfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Operations on Complex::.

‘complex long double cprojl (complex long double Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘cpu_set_t’

     ‘sched.h’ (GNU): *note CPU Affinity::.

‘double creal (complex double Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘float crealf (complex float Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘_FloatN crealfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Operations on Complex::.

‘_FloatNx crealfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Operations on Complex::.

‘long double creall (complex long double Z)’

     ‘complex.h’ (ISO): *note Operations on Complex::.

‘int creat (const char *FILENAME, mode_t MODE)’

     ‘fcntl.h’ (POSIX.1): *note Opening and Closing Files::.

‘int creat64 (const char *FILENAME, mode_t MODE)’

     ‘fcntl.h’ (Unix98): *note Opening and Closing Files::.

‘char * crypt (const char *PHRASE, const char *SALT)’

     ‘unistd.h’ (X/Open): *note Passphrase Storage::.

     ‘crypt.h’ (GNU): *note Passphrase Storage::.

‘char * crypt_r (const char *PHRASE, const char *SALT, struct crypt_data *DATA)’

     ‘crypt.h’ (GNU): *note Passphrase Storage::.

‘complex double csin (complex double Z)’

     ‘complex.h’ (ISO): *note Trig Functions::.

‘complex float csinf (complex float Z)’

     ‘complex.h’ (ISO): *note Trig Functions::.

‘complex _FloatN csinfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Trig Functions::.

‘complex _FloatNx csinfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Trig Functions::.

‘complex double csinh (complex double Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex float csinhf (complex float Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex _FloatN csinhfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘complex _FloatNx csinhfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘complex long double csinhl (complex long double Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex long double csinl (complex long double Z)’

     ‘complex.h’ (ISO): *note Trig Functions::.

‘complex double csqrt (complex double Z)’

     ‘complex.h’ (ISO): *note Exponents and Logarithms::.

‘complex float csqrtf (complex float Z)’

     ‘complex.h’ (ISO): *note Exponents and Logarithms::.

‘complex _FloatN csqrtfN (_FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘complex _FloatNx csqrtfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘complex long double csqrtl (complex long double Z)’

     ‘complex.h’ (ISO): *note Exponents and Logarithms::.

‘complex double ctan (complex double Z)’

     ‘complex.h’ (ISO): *note Trig Functions::.

‘complex float ctanf (complex float Z)’

     ‘complex.h’ (ISO): *note Trig Functions::.

‘complex _FloatN ctanfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Trig Functions::.

‘complex _FloatNx ctanfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Trig Functions::.

‘complex double ctanh (complex double Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex float ctanhf (complex float Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex _FloatN ctanhfN (complex _FloatN Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘complex _FloatNx ctanhfNx (complex _FloatNx Z)’

     ‘complex.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘complex long double ctanhl (complex long double Z)’

     ‘complex.h’ (ISO): *note Hyperbolic Functions::.

‘complex long double ctanl (complex long double Z)’

     ‘complex.h’ (ISO): *note Trig Functions::.

‘char * ctermid (char *STRING)’

     ‘stdio.h’ (POSIX.1): *note Identifying the Terminal::.

‘char * ctime (const time_t *TIME)’

     ‘time.h’ (ISO): *note Formatting Calendar Time::.

‘char * ctime_r (const time_t *TIME, char *BUFFER)’

     ‘time.h’ (POSIX.1c): *note Formatting Calendar Time::.

‘char * cuserid (char *STRING)’

     ‘stdio.h’ (POSIX.1): *note Who Logged In::.

‘double daddl (long double X, long double Y)’

     ‘math.h’ (TS 18661-1:2014): *note Misc FP Arithmetic::.

‘int daylight’

     ‘time.h’ (SVID): *note Time Zone Functions::.

‘char * dcgettext (const char *DOMAINNAME, const char *MSGID, int CATEGORY)’

     ‘libintl.h’ (GNU): *note Translation with gettext::.

‘char * dcngettext (const char *DOMAIN, const char *MSGID1, const char *MSGID2, unsigned long int N, int CATEGORY)’

     ‘libintl.h’ (GNU): *note Advanced gettext functions::.

‘double ddivl (long double X, long double Y)’

     ‘math.h’ (TS 18661-1:2014): *note Misc FP Arithmetic::.

‘dev_t’

     ‘sys/types.h’ (POSIX.1): *note Attribute Meanings::.

‘char * dgettext (const char *DOMAINNAME, const char *MSGID)’

     ‘libintl.h’ (GNU): *note Translation with gettext::.

‘double difftime (time_t TIME1, time_t TIME0)’

     ‘time.h’ (ISO): *note Elapsed Time::.

‘struct dirent’

     ‘dirent.h’ (POSIX.1): *note Directory Entries::.

‘int dirfd (DIR *DIRSTREAM)’

     ‘dirent.h’ (GNU): *note Opening a Directory::.

‘char * dirname (char *PATH)’

     ‘libgen.h’ (XPG): *note Finding Tokens in a String::.

‘div_t div (int NUMERATOR, int DENOMINATOR)’

     ‘stdlib.h’ (ISO): *note Integer Division::.

‘div_t’

     ‘stdlib.h’ (ISO): *note Integer Division::.

‘double dmull (long double X, long double Y)’

     ‘math.h’ (TS 18661-1:2014): *note Misc FP Arithmetic::.

‘char * dngettext (const char *DOMAIN, const char *MSGID1, const char *MSGID2, unsigned long int N)’

     ‘libintl.h’ (GNU): *note Advanced gettext functions::.

‘double drand48 (void)’

     ‘stdlib.h’ (SVID): *note SVID Random::.

‘int drand48_r (struct drand48_data *BUFFER, double *RESULT)’

     ‘stdlib.h’ (GNU): *note SVID Random::.

‘double drem (double NUMERATOR, double DENOMINATOR)’

     ‘math.h’ (BSD): *note Remainder Functions::.

‘float dremf (float NUMERATOR, float DENOMINATOR)’

     ‘math.h’ (BSD): *note Remainder Functions::.

‘long double dreml (long double NUMERATOR, long double DENOMINATOR)’

     ‘math.h’ (BSD): *note Remainder Functions::.

‘double dsubl (long double X, long double Y)’

     ‘math.h’ (TS 18661-1:2014): *note Misc FP Arithmetic::.

‘int dup (int OLD)’

     ‘unistd.h’ (POSIX.1): *note Duplicating Descriptors::.

‘int dup2 (int OLD, int NEW)’

     ‘unistd.h’ (POSIX.1): *note Duplicating Descriptors::.

‘char * ecvt (double VALUE, int NDIGIT, int *DECPT, int *NEG)’

     ‘stdlib.h’ (SVID): *note System V Number Conversion::.

     ‘stdlib.h’ (Unix98): *note System V Number Conversion::.

‘int ecvt_r (double VALUE, int NDIGIT, int *DECPT, int *NEG, char *BUF, size_t LEN)’

     ‘stdlib.h’ (GNU): *note System V Number Conversion::.

‘void endfsent (void)’

     ‘fstab.h’ (BSD): *note fstab::.

‘void endgrent (void)’

     ‘grp.h’ (SVID): *note Scanning All Groups::.

     ‘grp.h’ (BSD): *note Scanning All Groups::.

‘void endhostent (void)’

     ‘netdb.h’ (BSD): *note Host Names::.

‘int endmntent (FILE *STREAM)’

     ‘mntent.h’ (BSD): *note mtab::.

‘void endnetent (void)’

     ‘netdb.h’ (BSD): *note Networks Database::.

‘void endnetgrent (void)’

     ‘netdb.h’ (BSD): *note Lookup Netgroup::.

‘void endprotoent (void)’

     ‘netdb.h’ (BSD): *note Protocols Database::.

‘void endpwent (void)’

     ‘pwd.h’ (SVID): *note Scanning All Users::.

     ‘pwd.h’ (BSD): *note Scanning All Users::.

‘void endservent (void)’

     ‘netdb.h’ (BSD): *note Services Database::.

‘void endutent (void)’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

‘void endutxent (void)’

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘char ** environ’

     ‘unistd.h’ (POSIX.1): *note Environment Access::.

‘error_t envz_add (char **ENVZ, size_t *ENVZ_LEN, const char *NAME, const char *VALUE)’

     ‘envz.h’ (GNU): *note Envz Functions::.

‘char * envz_entry (const char *ENVZ, size_t ENVZ_LEN, const char *NAME)’

     ‘envz.h’ (GNU): *note Envz Functions::.

‘char * envz_get (const char *ENVZ, size_t ENVZ_LEN, const char *NAME)’

     ‘envz.h’ (GNU): *note Envz Functions::.

‘error_t envz_merge (char **ENVZ, size_t *ENVZ_LEN, const char *ENVZ2, size_t ENVZ2_LEN, int OVERRIDE)’

     ‘envz.h’ (GNU): *note Envz Functions::.

‘void envz_remove (char **ENVZ, size_t *ENVZ_LEN, const char *NAME)’

     ‘envz.h’ (GNU): *note Envz Functions::.

‘void envz_strip (char **ENVZ, size_t *ENVZ_LEN)’

     ‘envz.h’ (GNU): *note Envz Functions::.

‘double erand48 (unsigned short int XSUBI[3])’

     ‘stdlib.h’ (SVID): *note SVID Random::.

‘int erand48_r (unsigned short int XSUBI[3], struct drand48_data *BUFFER, double *RESULT)’

     ‘stdlib.h’ (GNU): *note SVID Random::.

‘double erf (double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘double erfc (double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘float erfcf (float X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘_FloatN erfcfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Special Functions::.

‘_FloatNx erfcfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Special Functions::.

‘long double erfcl (long double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘float erff (float X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘_FloatN erffN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Special Functions::.

‘_FloatNx erffNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Special Functions::.

‘long double erfl (long double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘void err (int STATUS, const char *FORMAT, …)’

     ‘err.h’ (BSD): *note Error Messages::.

‘volatile int errno’

     ‘errno.h’ (ISO): *note Checking for Errors::.

‘void error (int STATUS, int ERRNUM, const char *FORMAT, …)’

     ‘error.h’ (GNU): *note Error Messages::.

‘void error_at_line (int STATUS, int ERRNUM, const char *FNAME, unsigned int LINENO, const char *FORMAT, …)’

     ‘error.h’ (GNU): *note Error Messages::.

‘unsigned int error_message_count’

     ‘error.h’ (GNU): *note Error Messages::.

‘int error_one_per_line’

     ‘error.h’ (GNU): *note Error Messages::.

‘void (*error_print_progname) (void)’

     ‘error.h’ (GNU): *note Error Messages::.

‘void errx (int STATUS, const char *FORMAT, …)’

     ‘err.h’ (BSD): *note Error Messages::.

‘int execl (const char *FILENAME, const char *ARG0, …)’

     ‘unistd.h’ (POSIX.1): *note Executing a File::.

‘int execle (const char *FILENAME, const char *ARG0, …, char *const ENV[])’

     ‘unistd.h’ (POSIX.1): *note Executing a File::.

‘int execlp (const char *FILENAME, const char *ARG0, …)’

     ‘unistd.h’ (POSIX.1): *note Executing a File::.

‘int execv (const char *FILENAME, char *const ARGV[])’

     ‘unistd.h’ (POSIX.1): *note Executing a File::.

‘int execve (const char *FILENAME, char *const ARGV[], char *const ENV[])’

     ‘unistd.h’ (POSIX.1): *note Executing a File::.

‘int execvp (const char *FILENAME, char *const ARGV[])’

     ‘unistd.h’ (POSIX.1): *note Executing a File::.

‘void exit (int STATUS)’

     ‘stdlib.h’ (ISO): *note Normal Termination::.

‘struct exit_status’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

‘double exp (double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘double exp10 (double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘float exp10f (float X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatN exp10fN (_FloatN X)’

     ‘math.h’ (TS 18661-4:2015): *note Exponents and Logarithms::.

‘_FloatNx exp10fNx (_FloatNx X)’

     ‘math.h’ (TS 18661-4:2015): *note Exponents and Logarithms::.

‘long double exp10l (long double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘double exp2 (double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘float exp2f (float X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatN exp2fN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘_FloatNx exp2fNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long double exp2l (long double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘float expf (float X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatN expfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘_FloatNx expfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long double expl (long double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘void explicit_bzero (void *BLOCK, size_t LEN)’

     ‘string.h’ (BSD): *note Erasing Sensitive Data::.

‘double expm1 (double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘float expm1f (float X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatN expm1fN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘_FloatNx expm1fNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long double expm1l (long double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatM fMaddfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatM fMaddfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatM fMdivfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatM fMdivfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatM fMmulfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatM fMmulfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatM fMsubfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatM fMsubfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatMx fMxaddfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatMx fMxaddfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatMx fMxdivfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatMx fMxdivfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatMx fMxmulfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatMx fMxmulfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatMx fMxsubfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatMx fMxsubfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘double fabs (double NUMBER)’

     ‘math.h’ (ISO): *note Absolute Value::.

‘float fabsf (float NUMBER)’

     ‘math.h’ (ISO): *note Absolute Value::.

‘_FloatN fabsfN (_FloatN NUMBER)’

     ‘math.h’ (TS 18661-3:2015): *note Absolute Value::.

‘_FloatNx fabsfNx (_FloatNx NUMBER)’

     ‘math.h’ (TS 18661-3:2015): *note Absolute Value::.

‘long double fabsl (long double NUMBER)’

     ‘math.h’ (ISO): *note Absolute Value::.

‘float fadd (double X, double Y)’

     ‘math.h’ (TS 18661-1:2014): *note Misc FP Arithmetic::.

‘float faddl (long double X, long double Y)’

     ‘math.h’ (TS 18661-1:2014): *note Misc FP Arithmetic::.

‘int fchdir (int FILEDES)’

     ‘unistd.h’ (XPG): *note Working Directory::.

‘int fchmod (int FILEDES, mode_t MODE)’

     ‘sys/stat.h’ (BSD): *note Setting Permissions::.

‘int fchown (int FILEDES, uid_t OWNER, gid_t GROUP)’

     ‘unistd.h’ (BSD): *note File Owner::.

‘int fclose (FILE *STREAM)’

     ‘stdio.h’ (ISO): *note Closing Streams::.

‘int fcloseall (void)’

     ‘stdio.h’ (GNU): *note Closing Streams::.

‘int fcntl (int FILEDES, int COMMAND, …)’

     ‘fcntl.h’ (POSIX.1): *note Control Operations::.

‘char * fcvt (double VALUE, int NDIGIT, int *DECPT, int *NEG)’

     ‘stdlib.h’ (SVID): *note System V Number Conversion::.

     ‘stdlib.h’ (Unix98): *note System V Number Conversion::.

‘int fcvt_r (double VALUE, int NDIGIT, int *DECPT, int *NEG, char *BUF, size_t LEN)’

     ‘stdlib.h’ (SVID): *note System V Number Conversion::.

     ‘stdlib.h’ (Unix98): *note System V Number Conversion::.

‘fd_set’

     ‘sys/types.h’ (BSD): *note Waiting for I/O::.

‘int fdatasync (int FILDES)’

     ‘unistd.h’ (POSIX): *note Synchronizing I/O::.

‘double fdim (double X, double Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘float fdimf (float X, float Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘_FloatN fdimfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatNx fdimfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘long double fdiml (long double X, long double Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘float fdiv (double X, double Y)’

     ‘math.h’ (TS 18661-1:2014): *note Misc FP Arithmetic::.

‘float fdivl (long double X, long double Y)’

     ‘math.h’ (TS 18661-1:2014): *note Misc FP Arithmetic::.

‘FILE * fdopen (int FILEDES, const char *OPENTYPE)’

     ‘stdio.h’ (POSIX.1): *note Descriptors and Streams::.

‘DIR * fdopendir (int FD)’

     ‘dirent.h’ (GNU): *note Opening a Directory::.

‘int feclearexcept (int EXCEPTS)’

     ‘fenv.h’ (ISO): *note Status bit operations::.

‘int fedisableexcept (int EXCEPTS)’

     ‘fenv.h’ (GNU): *note Control Functions::.

‘int feenableexcept (int EXCEPTS)’

     ‘fenv.h’ (GNU): *note Control Functions::.

‘int fegetenv (fenv_t *ENVP)’

     ‘fenv.h’ (ISO): *note Control Functions::.

‘int fegetexcept (void)’

     ‘fenv.h’ (GNU): *note Control Functions::.

‘int fegetexceptflag (fexcept_t *FLAGP, int EXCEPTS)’

     ‘fenv.h’ (ISO): *note Status bit operations::.

‘int fegetmode (femode_t *MODEP)’

     ‘fenv.h’ (ISO): *note Control Functions::.

‘int fegetround (void)’

     ‘fenv.h’ (ISO): *note Rounding::.

‘int feholdexcept (fenv_t *ENVP)’

     ‘fenv.h’ (ISO): *note Control Functions::.

‘int feof (FILE *STREAM)’

     ‘stdio.h’ (ISO): *note EOF and Errors::.

‘int feof_unlocked (FILE *STREAM)’

     ‘stdio.h’ (GNU): *note EOF and Errors::.

‘int feraiseexcept (int EXCEPTS)’

     ‘fenv.h’ (ISO): *note Status bit operations::.

‘int ferror (FILE *STREAM)’

     ‘stdio.h’ (ISO): *note EOF and Errors::.

‘int ferror_unlocked (FILE *STREAM)’

     ‘stdio.h’ (GNU): *note EOF and Errors::.

‘int fesetenv (const fenv_t *ENVP)’

     ‘fenv.h’ (ISO): *note Control Functions::.

‘int fesetexcept (int EXCEPTS)’

     ‘fenv.h’ (ISO): *note Status bit operations::.

‘int fesetexceptflag (const fexcept_t *FLAGP, int EXCEPTS)’

     ‘fenv.h’ (ISO): *note Status bit operations::.

‘int fesetmode (const femode_t *MODEP)’

     ‘fenv.h’ (ISO): *note Control Functions::.

‘int fesetround (int ROUND)’

     ‘fenv.h’ (ISO): *note Rounding::.

‘int fetestexcept (int EXCEPTS)’

     ‘fenv.h’ (ISO): *note Status bit operations::.

‘int fetestexceptflag (const fexcept_t *FLAGP, int EXCEPTS)’

     ‘fenv.h’ (ISO): *note Status bit operations::.

‘int feupdateenv (const fenv_t *ENVP)’

     ‘fenv.h’ (ISO): *note Control Functions::.

‘int fflush (FILE *STREAM)’

     ‘stdio.h’ (ISO): *note Flushing Buffers::.

‘int fflush_unlocked (FILE *STREAM)’

     ‘stdio.h’ (POSIX): *note Flushing Buffers::.

‘int fgetc (FILE *STREAM)’

     ‘stdio.h’ (ISO): *note Character Input::.

‘int fgetc_unlocked (FILE *STREAM)’

     ‘stdio.h’ (POSIX): *note Character Input::.

‘struct group * fgetgrent (FILE *STREAM)’

     ‘grp.h’ (SVID): *note Scanning All Groups::.

‘int fgetgrent_r (FILE *STREAM, struct group *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct group **RESULT)’

     ‘grp.h’ (GNU): *note Scanning All Groups::.

‘int fgetpos (FILE *STREAM, fpos_t *POSITION)’

     ‘stdio.h’ (ISO): *note Portable Positioning::.

‘int fgetpos64 (FILE *STREAM, fpos64_t *POSITION)’

     ‘stdio.h’ (Unix98): *note Portable Positioning::.

‘struct passwd * fgetpwent (FILE *STREAM)’

     ‘pwd.h’ (SVID): *note Scanning All Users::.

‘int fgetpwent_r (FILE *STREAM, struct passwd *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct passwd **RESULT)’

     ‘pwd.h’ (GNU): *note Scanning All Users::.

‘char * fgets (char *S, int COUNT, FILE *STREAM)’

     ‘stdio.h’ (ISO): *note Line Input::.

‘char * fgets_unlocked (char *S, int COUNT, FILE *STREAM)’

     ‘stdio.h’ (GNU): *note Line Input::.

‘wint_t fgetwc (FILE *STREAM)’

     ‘wchar.h’ (ISO): *note Character Input::.

‘wint_t fgetwc_unlocked (FILE *STREAM)’

     ‘wchar.h’ (GNU): *note Character Input::.

‘wchar_t * fgetws (wchar_t *WS, int COUNT, FILE *STREAM)’

     ‘wchar.h’ (ISO): *note Line Input::.

‘wchar_t * fgetws_unlocked (wchar_t *WS, int COUNT, FILE *STREAM)’

     ‘wchar.h’ (GNU): *note Line Input::.

‘int fileno (FILE *STREAM)’

     ‘stdio.h’ (POSIX.1): *note Descriptors and Streams::.

‘int fileno_unlocked (FILE *STREAM)’

     ‘stdio.h’ (GNU): *note Descriptors and Streams::.

‘int finite (double X)’

     ‘math.h’ (BSD): *note Floating Point Classes::.

‘int finitef (float X)’

     ‘math.h’ (BSD): *note Floating Point Classes::.

‘int finitel (long double X)’

     ‘math.h’ (BSD): *note Floating Point Classes::.

‘struct flock’

     ‘fcntl.h’ (POSIX.1): *note File Locks::.

‘void flockfile (FILE *STREAM)’

     ‘stdio.h’ (POSIX): *note Streams and Threads::.

‘double floor (double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘float floorf (float X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘_FloatN floorfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘_FloatNx floorfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long double floorl (long double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘double fma (double X, double Y, double Z)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘float fmaf (float X, float Y, float Z)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘_FloatN fmafN (_FloatN X, _FloatN Y, _FloatN Z)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatNx fmafNx (_FloatNx X, _FloatNx Y, _FloatNx Z)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘long double fmal (long double X, long double Y, long double Z)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘double fmax (double X, double Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘float fmaxf (float X, float Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘_FloatN fmaxfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatNx fmaxfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘long double fmaxl (long double X, long double Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘double fmaxmag (double X, double Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘float fmaxmagf (float X, float Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘_FloatN fmaxmagfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatNx fmaxmagfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘long double fmaxmagl (long double X, long double Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘FILE * fmemopen (void *BUF, size_t SIZE, const char *OPENTYPE)’

     ‘stdio.h’ (GNU): *note String Streams::.

‘double fmin (double X, double Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘float fminf (float X, float Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘_FloatN fminfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatNx fminfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘long double fminl (long double X, long double Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘double fminmag (double X, double Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘float fminmagf (float X, float Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘_FloatN fminmagfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘_FloatNx fminmagfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Misc FP Arithmetic::.

‘long double fminmagl (long double X, long double Y)’

     ‘math.h’ (ISO): *note Misc FP Arithmetic::.

‘double fmod (double NUMERATOR, double DENOMINATOR)’

     ‘math.h’ (ISO): *note Remainder Functions::.

‘float fmodf (float NUMERATOR, float DENOMINATOR)’

     ‘math.h’ (ISO): *note Remainder Functions::.

‘_FloatN fmodfN (_FloatN NUMERATOR, _FloatN DENOMINATOR)’

     ‘math.h’ (TS 18661-3:2015): *note Remainder Functions::.

‘_FloatNx fmodfNx (_FloatNx NUMERATOR, _FloatNx DENOMINATOR)’

     ‘math.h’ (TS 18661-3:2015): *note Remainder Functions::.

‘long double fmodl (long double NUMERATOR, long double DENOMINATOR)’

     ‘math.h’ (ISO): *note Remainder Functions::.

‘int fmtmsg (long int CLASSIFICATION, const char *LABEL, int SEVERITY, const char *TEXT, const char *ACTION, const char *TAG)’

     ‘fmtmsg.h’ (XPG): *note Printing Formatted Messages::.

‘float fmul (double X, double Y)’

     ‘math.h’ (TS 18661-1:2014): *note Misc FP Arithmetic::.

‘float fmull (long double X, long double Y)’

     ‘math.h’ (TS 18661-1:2014): *note Misc FP Arithmetic::.

‘int fnmatch (const char *PATTERN, const char *STRING, int FLAGS)’

     ‘fnmatch.h’ (POSIX.2): *note Wildcard Matching::.

‘FILE * fopen (const char *FILENAME, const char *OPENTYPE)’

     ‘stdio.h’ (ISO): *note Opening Streams::.

‘FILE * fopen64 (const char *FILENAME, const char *OPENTYPE)’

     ‘stdio.h’ (Unix98): *note Opening Streams::.

‘FILE * fopencookie (void *COOKIE, const char *OPENTYPE, cookie_io_functions_t IO-FUNCTIONS)’

     ‘stdio.h’ (GNU): *note Streams and Cookies::.

‘pid_t fork (void)’

     ‘unistd.h’ (POSIX.1): *note Creating a Process::.

‘int forkpty (int *AMASTER, char *NAME, const struct termios *TERMP, const struct winsize *WINP)’

     ‘pty.h’ (BSD): *note Pseudo-Terminal Pairs::.

‘long int fpathconf (int FILEDES, int PARAMETER)’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘int fpclassify (_float-type_ X)’

     ‘math.h’ (ISO): *note Floating Point Classes::.

‘fpos64_t’

     ‘stdio.h’ (Unix98): *note Portable Positioning::.

‘fpos_t’

     ‘stdio.h’ (ISO): *note Portable Positioning::.

‘int fprintf (FILE *STREAM, const char *TEMPLATE, …)’

     ‘stdio.h’ (ISO): *note Formatted Output Functions::.

‘int fputc (int C, FILE *STREAM)’

     ‘stdio.h’ (ISO): *note Simple Output::.

‘int fputc_unlocked (int C, FILE *STREAM)’

     ‘stdio.h’ (POSIX): *note Simple Output::.

‘int fputs (const char *S, FILE *STREAM)’

     ‘stdio.h’ (ISO): *note Simple Output::.

‘int fputs_unlocked (const char *S, FILE *STREAM)’

     ‘stdio.h’ (GNU): *note Simple Output::.

‘wint_t fputwc (wchar_t WC, FILE *STREAM)’

     ‘wchar.h’ (ISO): *note Simple Output::.

‘wint_t fputwc_unlocked (wchar_t WC, FILE *STREAM)’

     ‘wchar.h’ (POSIX): *note Simple Output::.

‘int fputws (const wchar_t *WS, FILE *STREAM)’

     ‘wchar.h’ (ISO): *note Simple Output::.

‘int fputws_unlocked (const wchar_t *WS, FILE *STREAM)’

     ‘wchar.h’ (GNU): *note Simple Output::.

‘size_t fread (void *DATA, size_t SIZE, size_t COUNT, FILE *STREAM)’

     ‘stdio.h’ (ISO): *note Block Input/Output::.

‘size_t fread_unlocked (void *DATA, size_t SIZE, size_t COUNT, FILE *STREAM)’

     ‘stdio.h’ (GNU): *note Block Input/Output::.

‘void free (void *PTR)’

     ‘malloc.h’ (ISO): *note Freeing after Malloc::.

     ‘stdlib.h’ (ISO): *note Freeing after Malloc::.

‘FILE * freopen (const char *FILENAME, const char *OPENTYPE, FILE *STREAM)’

     ‘stdio.h’ (ISO): *note Opening Streams::.

‘FILE * freopen64 (const char *FILENAME, const char *OPENTYPE, FILE *STREAM)’

     ‘stdio.h’ (Unix98): *note Opening Streams::.

‘double frexp (double VALUE, int *EXPONENT)’

     ‘math.h’ (ISO): *note Normalization Functions::.

‘float frexpf (float VALUE, int *EXPONENT)’

     ‘math.h’ (ISO): *note Normalization Functions::.

‘_FloatN frexpfN (_FloatN VALUE, int *EXPONENT)’

     ‘math.h’ (TS 18661-3:2015): *note Normalization Functions::.

‘_FloatNx frexpfNx (_FloatNx VALUE, int *EXPONENT)’

     ‘math.h’ (TS 18661-3:2015): *note Normalization Functions::.

‘long double frexpl (long double VALUE, int *EXPONENT)’

     ‘math.h’ (ISO): *note Normalization Functions::.

‘intmax_t fromfp (double X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘intmax_t fromfpf (float X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘intmax_t fromfpfN (_FloatN X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘intmax_t fromfpfNx (_FloatNx X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘intmax_t fromfpl (long double X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘intmax_t fromfpx (double X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘intmax_t fromfpxf (float X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘intmax_t fromfpxfN (_FloatN X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘intmax_t fromfpxfNx (_FloatNx X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘intmax_t fromfpxl (long double X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘int fscanf (FILE *STREAM, const char *TEMPLATE, …)’

     ‘stdio.h’ (ISO): *note Formatted Input Functions::.

‘int fseek (FILE *STREAM, long int OFFSET, int WHENCE)’

     ‘stdio.h’ (ISO): *note File Positioning::.

‘int fseeko (FILE *STREAM, off_t OFFSET, int WHENCE)’

     ‘stdio.h’ (Unix98): *note File Positioning::.

‘int fseeko64 (FILE *STREAM, off64_t OFFSET, int WHENCE)’

     ‘stdio.h’ (Unix98): *note File Positioning::.

‘int fsetpos (FILE *STREAM, const fpos_t *POSITION)’

     ‘stdio.h’ (ISO): *note Portable Positioning::.

‘int fsetpos64 (FILE *STREAM, const fpos64_t *POSITION)’

     ‘stdio.h’ (Unix98): *note Portable Positioning::.

‘struct fstab’

     ‘fstab.h’ (BSD): *note fstab::.

‘int fstat (int FILEDES, struct stat *BUF)’

     ‘sys/stat.h’ (POSIX.1): *note Reading Attributes::.

‘int fstat64 (int FILEDES, struct stat64 *BUF)’

     ‘sys/stat.h’ (Unix98): *note Reading Attributes::.

‘float fsub (double X, double Y)’

     ‘math.h’ (TS 18661-1:2014): *note Misc FP Arithmetic::.

‘float fsubl (long double X, long double Y)’

     ‘math.h’ (TS 18661-1:2014): *note Misc FP Arithmetic::.

‘int fsync (int FILDES)’

     ‘unistd.h’ (POSIX): *note Synchronizing I/O::.

‘long int ftell (FILE *STREAM)’

     ‘stdio.h’ (ISO): *note File Positioning::.

‘off_t ftello (FILE *STREAM)’

     ‘stdio.h’ (Unix98): *note File Positioning::.

‘off64_t ftello64 (FILE *STREAM)’

     ‘stdio.h’ (Unix98): *note File Positioning::.

‘int ftruncate (int FD, off_t LENGTH)’

     ‘unistd.h’ (POSIX): *note File Size::.

‘int ftruncate64 (int ID, off64_t LENGTH)’

     ‘unistd.h’ (Unix98): *note File Size::.

‘int ftrylockfile (FILE *STREAM)’

     ‘stdio.h’ (POSIX): *note Streams and Threads::.

‘int ftw (const char *FILENAME, __ftw_func_t FUNC, int DESCRIPTORS)’

     ‘ftw.h’ (SVID): *note Working with Directory Trees::.

‘int ftw64 (const char *FILENAME, __ftw64_func_t FUNC, int DESCRIPTORS)’

     ‘ftw.h’ (Unix98): *note Working with Directory Trees::.

‘void funlockfile (FILE *STREAM)’

     ‘stdio.h’ (POSIX): *note Streams and Threads::.

‘int futimes (int FD, const struct timeval TVP[2])’

     ‘sys/time.h’ (BSD): *note File Times::.

‘int fwide (FILE *STREAM, int MODE)’

     ‘wchar.h’ (ISO): *note Streams and I18N::.

‘int fwprintf (FILE *STREAM, const wchar_t *TEMPLATE, …)’

     ‘wchar.h’ (ISO): *note Formatted Output Functions::.

‘size_t fwrite (const void *DATA, size_t SIZE, size_t COUNT, FILE *STREAM)’

     ‘stdio.h’ (ISO): *note Block Input/Output::.

‘size_t fwrite_unlocked (const void *DATA, size_t SIZE, size_t COUNT, FILE *STREAM)’

     ‘stdio.h’ (GNU): *note Block Input/Output::.

‘int fwscanf (FILE *STREAM, const wchar_t *TEMPLATE, …)’

     ‘wchar.h’ (ISO): *note Formatted Input Functions::.

‘double gamma (double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘float gammaf (float X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘long double gammal (long double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘char * gcvt (double VALUE, int NDIGIT, char *BUF)’

     ‘stdlib.h’ (SVID): *note System V Number Conversion::.

     ‘stdlib.h’ (Unix98): *note System V Number Conversion::.

‘long int get_avphys_pages (void)’

     ‘sys/sysinfo.h’ (GNU): *note Query Memory Parameters::.

‘char * get_current_dir_name (void)’

     ‘unistd.h’ (GNU): *note Working Directory::.

‘int get_nprocs (void)’

     ‘sys/sysinfo.h’ (GNU): *note Processor Resources::.

‘int get_nprocs_conf (void)’

     ‘sys/sysinfo.h’ (GNU): *note Processor Resources::.

‘long int get_phys_pages (void)’

     ‘sys/sysinfo.h’ (GNU): *note Query Memory Parameters::.

‘unsigned long int getauxval (unsigned long int TYPE)’

     ‘sys/auxv.h’ (???): *note Auxiliary Vector::.

‘int getc (FILE *STREAM)’

     ‘stdio.h’ (ISO): *note Character Input::.

‘int getc_unlocked (FILE *STREAM)’

     ‘stdio.h’ (POSIX): *note Character Input::.

‘int getchar (void)’

     ‘stdio.h’ (ISO): *note Character Input::.

‘int getchar_unlocked (void)’

     ‘stdio.h’ (POSIX): *note Character Input::.

‘int getcontext (ucontext_t *UCP)’

     ‘ucontext.h’ (SVID): *note System V contexts::.

‘int getcpu (unsigned int *cpu, unsigned int *node)’

     ‘<sched.h>’ (Linux): *note CPU Affinity::.

‘char * getcwd (char *BUFFER, size_t SIZE)’

     ‘unistd.h’ (POSIX.1): *note Working Directory::.

‘struct tm * getdate (const char *STRING)’

     ‘time.h’ (Unix98): *note General Time String Parsing::.

‘getdate_err’

     ‘time.h’ (Unix98): *note General Time String Parsing::.

‘int getdate_r (const char *STRING, struct tm *TP)’

     ‘time.h’ (GNU): *note General Time String Parsing::.

‘ssize_t getdelim (char **LINEPTR, size_t *N, int DELIMITER, FILE *STREAM)’

     ‘stdio.h’ (GNU): *note Line Input::.

‘ssize_t getdents64 (int FD, void *BUFFER, size_t LENGTH)’

     ‘dirent.h’ (Linux): *note Low-level Directory Access::.

‘int getdomainnname (char *NAME, size_t LENGTH)’

     ‘unistd.h’ (???): *note Host Identification::.

‘gid_t getegid (void)’

     ‘unistd.h’ (POSIX.1): *note Reading Persona::.

‘int getentropy (void *BUFFER, size_t LENGTH)’

     ‘sys/random.h’ (GNU): *note Unpredictable Bytes::.

‘char * getenv (const char *NAME)’

     ‘stdlib.h’ (ISO): *note Environment Access::.

‘uid_t geteuid (void)’

     ‘unistd.h’ (POSIX.1): *note Reading Persona::.

‘struct fstab * getfsent (void)’

     ‘fstab.h’ (BSD): *note fstab::.

‘struct fstab * getfsfile (const char *NAME)’

     ‘fstab.h’ (BSD): *note fstab::.

‘struct fstab * getfsspec (const char *NAME)’

     ‘fstab.h’ (BSD): *note fstab::.

‘gid_t getgid (void)’

     ‘unistd.h’ (POSIX.1): *note Reading Persona::.

‘struct group * getgrent (void)’

     ‘grp.h’ (SVID): *note Scanning All Groups::.

     ‘grp.h’ (BSD): *note Scanning All Groups::.

‘int getgrent_r (struct group *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct group **RESULT)’

     ‘grp.h’ (GNU): *note Scanning All Groups::.

‘struct group * getgrgid (gid_t GID)’

     ‘grp.h’ (POSIX.1): *note Lookup Group::.

‘int getgrgid_r (gid_t GID, struct group *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct group **RESULT)’

     ‘grp.h’ (POSIX.1c): *note Lookup Group::.

‘struct group * getgrnam (const char *NAME)’

     ‘grp.h’ (SVID): *note Lookup Group::.

     ‘grp.h’ (BSD): *note Lookup Group::.

‘int getgrnam_r (const char *NAME, struct group *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct group **RESULT)’

     ‘grp.h’ (POSIX.1c): *note Lookup Group::.

‘int getgrouplist (const char *USER, gid_t GROUP, gid_t *GROUPS, int *NGROUPS)’

     ‘grp.h’ (BSD): *note Setting Groups::.

‘int getgroups (int COUNT, gid_t *GROUPS)’

     ‘unistd.h’ (POSIX.1): *note Reading Persona::.

‘struct hostent * gethostbyaddr (const void *ADDR, socklen_t LENGTH, int FORMAT)’

     ‘netdb.h’ (BSD): *note Host Names::.

‘int gethostbyaddr_r (const void *ADDR, socklen_t LENGTH, int FORMAT, struct hostent *restrict RESULT_BUF, char *restrict BUF, size_t BUFLEN, struct hostent **restrict RESULT, int *restrict H_ERRNOP)’

     ‘netdb.h’ (GNU): *note Host Names::.

‘struct hostent * gethostbyname (const char *NAME)’

     ‘netdb.h’ (BSD): *note Host Names::.

‘struct hostent * gethostbyname2 (const char *NAME, int AF)’

     ‘netdb.h’ (IPv6 Basic API): *note Host Names::.

‘int gethostbyname2_r (const char *NAME, int AF, struct hostent *restrict RESULT_BUF, char *restrict BUF, size_t BUFLEN, struct hostent **restrict RESULT, int *restrict H_ERRNOP)’

     ‘netdb.h’ (GNU): *note Host Names::.

‘int gethostbyname_r (const char *restrict NAME, struct hostent *restrict RESULT_BUF, char *restrict BUF, size_t BUFLEN, struct hostent **restrict RESULT, int *restrict H_ERRNOP)’

     ‘netdb.h’ (GNU): *note Host Names::.

‘struct hostent * gethostent (void)’

     ‘netdb.h’ (BSD): *note Host Names::.

‘long int gethostid (void)’

     ‘unistd.h’ (BSD): *note Host Identification::.

‘int gethostname (char *NAME, size_t SIZE)’

     ‘unistd.h’ (BSD): *note Host Identification::.

‘int getitimer (int WHICH, struct itimerval *OLD)’

     ‘sys/time.h’ (BSD): *note Setting an Alarm::.

‘ssize_t getline (char **LINEPTR, size_t *N, FILE *STREAM)’

     ‘stdio.h’ (GNU): *note Line Input::.

‘int getloadavg (double LOADAVG[], int NELEM)’

     ‘stdlib.h’ (BSD): *note Processor Resources::.

‘char * getlogin (void)’

     ‘unistd.h’ (POSIX.1): *note Who Logged In::.

‘struct mntent * getmntent (FILE *STREAM)’

     ‘mntent.h’ (BSD): *note mtab::.

‘struct mntent * getmntent_r (FILE *STREAM, struct mntent *RESULT, char *BUFFER, int BUFSIZE)’

     ‘mntent.h’ (BSD): *note mtab::.

‘struct netent * getnetbyaddr (uint32_t NET, int TYPE)’

     ‘netdb.h’ (BSD): *note Networks Database::.

‘struct netent * getnetbyname (const char *NAME)’

     ‘netdb.h’ (BSD): *note Networks Database::.

‘struct netent * getnetent (void)’

     ‘netdb.h’ (BSD): *note Networks Database::.

‘int getnetgrent (char **HOSTP, char **USERP, char **DOMAINP)’

     ‘netdb.h’ (BSD): *note Lookup Netgroup::.

‘int getnetgrent_r (char **HOSTP, char **USERP, char **DOMAINP, char *BUFFER, size_t BUFLEN)’

     ‘netdb.h’ (GNU): *note Lookup Netgroup::.

‘int getopt (int ARGC, char *const *ARGV, const char *OPTIONS)’

     ‘unistd.h’ (POSIX.2): *note Using Getopt::.

‘int getopt_long (int ARGC, char *const *ARGV, const char *SHORTOPTS, const struct option *LONGOPTS, int *INDEXPTR)’

     ‘getopt.h’ (GNU): *note Getopt Long Options::.

‘int getopt_long_only (int ARGC, char *const *ARGV, const char *SHORTOPTS, const struct option *LONGOPTS, int *INDEXPTR)’

     ‘getopt.h’ (GNU): *note Getopt Long Options::.

‘int getpagesize (void)’

     ‘unistd.h’ (BSD): *note Query Memory Parameters::.

‘char * getpass (const char *PROMPT)’

     ‘unistd.h’ (BSD): *note getpass::.

‘double getpayload (const double *X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘float getpayloadf (const float *X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘_FloatN getpayloadfN (const _FloatN *X)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘_FloatNx getpayloadfNx (const _FloatNx *X)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘long double getpayloadl (const long double *X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘int getpeername (int SOCKET, struct sockaddr *ADDR, socklen_t *LENGTH-PTR)’

     ‘sys/socket.h’ (BSD): *note Who is Connected::.

‘int getpgid (pid_t PID)’

     ‘unistd.h’ (POSIX.1): *note Process Group Functions::.

‘pid_t getpgrp (void)’

     ‘unistd.h’ (POSIX.1): *note Process Group Functions::.

‘pid_t getpid (void)’

     ‘unistd.h’ (POSIX.1): *note Process Identification::.

‘pid_t getppid (void)’

     ‘unistd.h’ (POSIX.1): *note Process Identification::.

‘int getpriority (int CLASS, int ID)’

     ‘sys/resource.h’ (BSD): *note Traditional Scheduling Functions::.

     ‘sys/resource.h’ (POSIX): *note Traditional Scheduling Functions::.

‘struct protoent * getprotobyname (const char *NAME)’

     ‘netdb.h’ (BSD): *note Protocols Database::.

‘struct protoent * getprotobynumber (int PROTOCOL)’

     ‘netdb.h’ (BSD): *note Protocols Database::.

‘struct protoent * getprotoent (void)’

     ‘netdb.h’ (BSD): *note Protocols Database::.

‘int getpt (void)’

     ‘stdlib.h’ (GNU): *note Allocation::.

‘struct passwd * getpwent (void)’

     ‘pwd.h’ (POSIX.1): *note Scanning All Users::.

‘int getpwent_r (struct passwd *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct passwd **RESULT)’

     ‘pwd.h’ (GNU): *note Scanning All Users::.

‘struct passwd * getpwnam (const char *NAME)’

     ‘pwd.h’ (POSIX.1): *note Lookup User::.

‘int getpwnam_r (const char *NAME, struct passwd *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct passwd **RESULT)’

     ‘pwd.h’ (POSIX.1c): *note Lookup User::.

‘struct passwd * getpwuid (uid_t UID)’

     ‘pwd.h’ (POSIX.1): *note Lookup User::.

‘int getpwuid_r (uid_t UID, struct passwd *RESULT_BUF, char *BUFFER, size_t BUFLEN, struct passwd **RESULT)’

     ‘pwd.h’ (POSIX.1c): *note Lookup User::.

‘ssize_t getrandom (void *BUFFER, size_t LENGTH, unsigned int FLAGS)’

     ‘sys/random.h’ (GNU): *note Unpredictable Bytes::.

‘int getrlimit (int RESOURCE, struct rlimit *RLP)’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘int getrlimit64 (int RESOURCE, struct rlimit64 *RLP)’

     ‘sys/resource.h’ (Unix98): *note Limits on Resources::.

‘int getrusage (int PROCESSES, struct rusage *RUSAGE)’

     ‘sys/resource.h’ (BSD): *note Resource Usage::.

‘char * gets (char *S)’

     ‘stdio.h’ (ISO): *note Line Input::.

‘struct servent * getservbyname (const char *NAME, const char *PROTO)’

     ‘netdb.h’ (BSD): *note Services Database::.

‘struct servent * getservbyport (int PORT, const char *PROTO)’

     ‘netdb.h’ (BSD): *note Services Database::.

‘struct servent * getservent (void)’

     ‘netdb.h’ (BSD): *note Services Database::.

‘pid_t getsid (pid_t PID)’

     ‘unistd.h’ (SVID): *note Process Group Functions::.

‘int getsockname (int SOCKET, struct sockaddr *ADDR, socklen_t *LENGTH-PTR)’

     ‘sys/socket.h’ (BSD): *note Reading Address::.

‘int getsockopt (int SOCKET, int LEVEL, int OPTNAME, void *OPTVAL, socklen_t *OPTLEN-PTR)’

     ‘sys/socket.h’ (BSD): *note Socket Option Functions::.

‘int getsubopt (char **OPTIONP, char *const *TOKENS, char **VALUEP)’

     ‘stdlib.h’ (???): *note Suboptions::.

‘char * gettext (const char *MSGID)’

     ‘libintl.h’ (GNU): *note Translation with gettext::.

‘pid_t gettid (void)’

     ‘unistd.h’ (Linux): *note Process Identification::.

‘int gettimeofday (struct timeval *TP, struct timezone *TZP)’

     ‘sys/time.h’ (BSD): *note High-Resolution Calendar::.

‘uid_t getuid (void)’

     ‘unistd.h’ (POSIX.1): *note Reading Persona::.

‘mode_t getumask (void)’

     ‘sys/stat.h’ (GNU): *note Setting Permissions::.

‘struct utmp * getutent (void)’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

‘int getutent_r (struct utmp *BUFFER, struct utmp **RESULT)’

     ‘utmp.h’ (GNU): *note Manipulating the Database::.

‘struct utmp * getutid (const struct utmp *ID)’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

‘int getutid_r (const struct utmp *ID, struct utmp *BUFFER, struct utmp **RESULT)’

     ‘utmp.h’ (GNU): *note Manipulating the Database::.

‘struct utmp * getutline (const struct utmp *LINE)’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

‘int getutline_r (const struct utmp *LINE, struct utmp *BUFFER, struct utmp **RESULT)’

     ‘utmp.h’ (GNU): *note Manipulating the Database::.

‘int getutmp (const struct utmpx *UTMPX, struct utmp *UTMP)’

     ‘utmp.h’ (GNU): *note XPG Functions::.

     ‘utmpx.h’ (GNU): *note XPG Functions::.

‘int getutmpx (const struct utmp *UTMP, struct utmpx *UTMPX)’

     ‘utmp.h’ (GNU): *note XPG Functions::.

     ‘utmpx.h’ (GNU): *note XPG Functions::.

‘struct utmpx * getutxent (void)’

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘struct utmpx * getutxid (const struct utmpx *ID)’

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘struct utmpx * getutxline (const struct utmpx *LINE)’

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘int getw (FILE *STREAM)’

     ‘stdio.h’ (SVID): *note Character Input::.

‘wint_t getwc (FILE *STREAM)’

     ‘wchar.h’ (ISO): *note Character Input::.

‘wint_t getwc_unlocked (FILE *STREAM)’

     ‘wchar.h’ (GNU): *note Character Input::.

‘wint_t getwchar (void)’

     ‘wchar.h’ (ISO): *note Character Input::.

‘wint_t getwchar_unlocked (void)’

     ‘wchar.h’ (GNU): *note Character Input::.

‘char * getwd (char *BUFFER)’

     ‘unistd.h’ (BSD): *note Working Directory::.

‘gid_t’

     ‘sys/types.h’ (POSIX.1): *note Reading Persona::.

‘int glob (const char *PATTERN, int FLAGS, int (*ERRFUNC) (const char *FILENAME, int ERROR-CODE), glob_t *VECTOR-PTR)’

     ‘glob.h’ (POSIX.2): *note Calling Glob::.

‘int glob64 (const char *PATTERN, int FLAGS, int (*ERRFUNC) (const char *FILENAME, int ERROR-CODE), glob64_t *VECTOR-PTR)’

     ‘glob.h’ (GNU): *note Calling Glob::.

‘glob64_t’

     ‘glob.h’ (GNU): *note Calling Glob::.

‘glob_t’

     ‘glob.h’ (POSIX.2): *note Calling Glob::.

‘void globfree (glob_t *PGLOB)’

     ‘glob.h’ (POSIX.2): *note More Flags for Globbing::.

‘void globfree64 (glob64_t *PGLOB)’

     ‘glob.h’ (GNU): *note More Flags for Globbing::.

‘struct tm * gmtime (const time_t *TIME)’

     ‘time.h’ (ISO): *note Broken-down Time::.

‘struct tm * gmtime_r (const time_t *TIME, struct tm *RESULTP)’

     ‘time.h’ (POSIX.1c): *note Broken-down Time::.

‘int grantpt (int FILEDES)’

     ‘stdlib.h’ (SVID): *note Allocation::.

     ‘stdlib.h’ (XPG4.2): *note Allocation::.

‘struct group’

     ‘grp.h’ (POSIX.1): *note Group Data Structure::.

‘int gsignal (int SIGNUM)’

     ‘signal.h’ (SVID): *note Signaling Yourself::.

‘int gtty (int FILEDES, struct sgttyb *ATTRIBUTES)’

     ‘sgtty.h’ (BSD): *note BSD Terminal Modes::.

‘char * hasmntopt (const struct mntent *MNT, const char *OPT)’

     ‘mntent.h’ (BSD): *note mtab::.

‘int hcreate (size_t NEL)’

     ‘search.h’ (SVID): *note Hash Search Function::.

‘int hcreate_r (size_t NEL, struct hsearch_data *HTAB)’

     ‘search.h’ (GNU): *note Hash Search Function::.

‘void hdestroy (void)’

     ‘search.h’ (SVID): *note Hash Search Function::.

‘void hdestroy_r (struct hsearch_data *HTAB)’

     ‘search.h’ (GNU): *note Hash Search Function::.

‘struct hostent’

     ‘netdb.h’ (BSD): *note Host Names::.

‘ENTRY * hsearch (ENTRY ITEM, ACTION ACTION)’

     ‘search.h’ (SVID): *note Hash Search Function::.

‘int hsearch_r (ENTRY ITEM, ACTION ACTION, ENTRY **RETVAL, struct hsearch_data *HTAB)’

     ‘search.h’ (GNU): *note Hash Search Function::.

‘uint32_t htonl (uint32_t HOSTLONG)’

     ‘netinet/in.h’ (BSD): *note Byte Order::.

‘uint16_t htons (uint16_t HOSTSHORT)’

     ‘netinet/in.h’ (BSD): *note Byte Order::.

‘double hypot (double X, double Y)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘float hypotf (float X, float Y)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatN hypotfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘_FloatNx hypotfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long double hypotl (long double X, long double Y)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘size_t iconv (iconv_t CD, char **INBUF, size_t *INBYTESLEFT, char **OUTBUF, size_t *OUTBYTESLEFT)’

     ‘iconv.h’ (XPG2): *note Generic Conversion Interface::.

‘int iconv_close (iconv_t CD)’

     ‘iconv.h’ (XPG2): *note Generic Conversion Interface::.

‘iconv_t iconv_open (const char *TOCODE, const char *FROMCODE)’

     ‘iconv.h’ (XPG2): *note Generic Conversion Interface::.

‘iconv_t’

     ‘iconv.h’ (XPG2): *note Generic Conversion Interface::.

‘void if_freenameindex (struct if_nameindex *PTR)’

     ‘net/if.h’ (IPv6 basic API): *note Interface Naming::.

‘char * if_indextoname (unsigned int IFINDEX, char *IFNAME)’

     ‘net/if.h’ (IPv6 basic API): *note Interface Naming::.

‘struct if_nameindex’

     ‘net/if.h’ (IPv6 basic API): *note Interface Naming::.

‘struct if_nameindex * if_nameindex (void)’

     ‘net/if.h’ (IPv6 basic API): *note Interface Naming::.

‘unsigned int if_nametoindex (const char *IFNAME)’

     ‘net/if.h’ (IPv6 basic API): *note Interface Naming::.

‘int ilogb (double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘int ilogbf (float X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘int ilogbfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘int ilogbfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘int ilogbl (long double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘intmax_t imaxabs (intmax_t NUMBER)’

     ‘inttypes.h’ (ISO): *note Absolute Value::.

‘imaxdiv_t imaxdiv (intmax_t NUMERATOR, intmax_t DENOMINATOR)’

     ‘inttypes.h’ (ISO): *note Integer Division::.

‘imaxdiv_t’

     ‘inttypes.h’ (ISO): *note Integer Division::.

‘struct in6_addr’

     ‘netinet/in.h’ (IPv6 basic API): *note Host Address Data Type::.

‘struct in6_addr in6addr_any’

     ‘netinet/in.h’ (IPv6 basic API): *note Host Address Data Type::.

‘struct in6_addr in6addr_loopback’

     ‘netinet/in.h’ (IPv6 basic API): *note Host Address Data Type::.

‘struct in_addr’

     ‘netinet/in.h’ (BSD): *note Host Address Data Type::.

‘char * index (const char *STRING, int C)’

     ‘string.h’ (BSD): *note Search Functions::.

‘uint32_t inet_addr (const char *NAME)’

     ‘arpa/inet.h’ (BSD): *note Host Address Functions::.

‘int inet_aton (const char *NAME, struct in_addr *ADDR)’

     ‘arpa/inet.h’ (BSD): *note Host Address Functions::.

‘uint32_t inet_lnaof (struct in_addr ADDR)’

     ‘arpa/inet.h’ (BSD): *note Host Address Functions::.

‘struct in_addr inet_makeaddr (uint32_t NET, uint32_t LOCAL)’

     ‘arpa/inet.h’ (BSD): *note Host Address Functions::.

‘uint32_t inet_netof (struct in_addr ADDR)’

     ‘arpa/inet.h’ (BSD): *note Host Address Functions::.

‘uint32_t inet_network (const char *NAME)’

     ‘arpa/inet.h’ (BSD): *note Host Address Functions::.

‘char * inet_ntoa (struct in_addr ADDR)’

     ‘arpa/inet.h’ (BSD): *note Host Address Functions::.

‘const char * inet_ntop (int AF, const void *CP, char *BUF, socklen_t LEN)’

     ‘arpa/inet.h’ (IPv6 basic API): *note Host Address Functions::.

‘int inet_pton (int AF, const char *CP, void *BUF)’

     ‘arpa/inet.h’ (IPv6 basic API): *note Host Address Functions::.

‘int initgroups (const char *USER, gid_t GROUP)’

     ‘grp.h’ (BSD): *note Setting Groups::.

‘char * initstate (unsigned int SEED, char *STATE, size_t SIZE)’

     ‘stdlib.h’ (BSD): *note BSD Random::.

‘int initstate_r (unsigned int SEED, char *restrict STATEBUF, size_t STATELEN, struct random_data *restrict BUF)’

     ‘stdlib.h’ (GNU): *note BSD Random::.

‘int innetgr (const char *NETGROUP, const char *HOST, const char *USER, const char *DOMAIN)’

     ‘netdb.h’ (BSD): *note Netgroup Membership::.

‘ino64_t’

     ‘sys/types.h’ (Unix98): *note Attribute Meanings::.

‘ino_t’

     ‘sys/types.h’ (POSIX.1): *note Attribute Meanings::.

‘int ioctl (int FILEDES, int COMMAND, …)’

     ‘sys/ioctl.h’ (BSD): *note IOCTLs::.

‘struct iovec’

     ‘sys/uio.h’ (BSD): *note Scatter-Gather::.

‘int isalnum (int C)’

     ‘ctype.h’ (ISO): *note Classification of Characters::.

‘int isalpha (int C)’

     ‘ctype.h’ (ISO): *note Classification of Characters::.

‘int isascii (int C)’

     ‘ctype.h’ (SVID): *note Classification of Characters::.

     ‘ctype.h’ (BSD): *note Classification of Characters::.

‘int isatty (int FILEDES)’

     ‘unistd.h’ (POSIX.1): *note Is It a Terminal::.

‘int isblank (int C)’

     ‘ctype.h’ (ISO): *note Classification of Characters::.

‘int iscanonical (_float-type_ X)’

     ‘math.h’ (ISO): *note Floating Point Classes::.

‘int iscntrl (int C)’

     ‘ctype.h’ (ISO): *note Classification of Characters::.

‘int isdigit (int C)’

     ‘ctype.h’ (ISO): *note Classification of Characters::.

‘int iseqsig (_real-floating_ X, _real-floating_ Y)’

     ‘math.h’ (ISO): *note FP Comparison Functions::.

‘int isfinite (_float-type_ X)’

     ‘math.h’ (ISO): *note Floating Point Classes::.

‘int isgraph (int C)’

     ‘ctype.h’ (ISO): *note Classification of Characters::.

‘int isgreater (_real-floating_ X, _real-floating_ Y)’

     ‘math.h’ (ISO): *note FP Comparison Functions::.

‘int isgreaterequal (_real-floating_ X, _real-floating_ Y)’

     ‘math.h’ (ISO): *note FP Comparison Functions::.

‘int isinf (double X)’

     ‘math.h’ (BSD): *note Floating Point Classes::.

‘int isinff (float X)’

     ‘math.h’ (BSD): *note Floating Point Classes::.

‘int isinfl (long double X)’

     ‘math.h’ (BSD): *note Floating Point Classes::.

‘int isless (_real-floating_ X, _real-floating_ Y)’

     ‘math.h’ (ISO): *note FP Comparison Functions::.

‘int islessequal (_real-floating_ X, _real-floating_ Y)’

     ‘math.h’ (ISO): *note FP Comparison Functions::.

‘int islessgreater (_real-floating_ X, _real-floating_ Y)’

     ‘math.h’ (ISO): *note FP Comparison Functions::.

‘int islower (int C)’

     ‘ctype.h’ (ISO): *note Classification of Characters::.

‘int isnan (_float-type_ X)’

     ‘math.h’ (ISO): *note Floating Point Classes::.

‘int isnan (double X)’

     ‘math.h’ (BSD): *note Floating Point Classes::.

‘int isnanf (float X)’

     ‘math.h’ (BSD): *note Floating Point Classes::.

‘int isnanl (long double X)’

     ‘math.h’ (BSD): *note Floating Point Classes::.

‘int isnormal (_float-type_ X)’

     ‘math.h’ (ISO): *note Floating Point Classes::.

‘int isprint (int C)’

     ‘ctype.h’ (ISO): *note Classification of Characters::.

‘int ispunct (int C)’

     ‘ctype.h’ (ISO): *note Classification of Characters::.

‘int issignaling (_float-type_ X)’

     ‘math.h’ (ISO): *note Floating Point Classes::.

‘int isspace (int C)’

     ‘ctype.h’ (ISO): *note Classification of Characters::.

‘int issubnormal (_float-type_ X)’

     ‘math.h’ (ISO): *note Floating Point Classes::.

‘int isunordered (_real-floating_ X, _real-floating_ Y)’

     ‘math.h’ (ISO): *note FP Comparison Functions::.

‘int isupper (int C)’

     ‘ctype.h’ (ISO): *note Classification of Characters::.

‘int iswalnum (wint_t WC)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘int iswalpha (wint_t WC)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘int iswblank (wint_t WC)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘int iswcntrl (wint_t WC)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘int iswctype (wint_t WC, wctype_t DESC)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘int iswdigit (wint_t WC)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘int iswgraph (wint_t WC)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘int iswlower (wint_t WC)’

     ‘ctype.h’ (ISO): *note Classification of Wide Characters::.

‘int iswprint (wint_t WC)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘int iswpunct (wint_t WC)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘int iswspace (wint_t WC)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘int iswupper (wint_t WC)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘int iswxdigit (wint_t WC)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘int isxdigit (int C)’

     ‘ctype.h’ (ISO): *note Classification of Characters::.

‘int iszero (_float-type_ X)’

     ‘math.h’ (ISO): *note Floating Point Classes::.

‘struct itimerval’

     ‘sys/time.h’ (BSD): *note Setting an Alarm::.

‘double j0 (double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘float j0f (float X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘_FloatN j0fN (_FloatN X)’

     ‘math.h’ (GNU): *note Special Functions::.

‘_FloatNx j0fNx (_FloatNx X)’

     ‘math.h’ (GNU): *note Special Functions::.

‘long double j0l (long double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘double j1 (double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘float j1f (float X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘_FloatN j1fN (_FloatN X)’

     ‘math.h’ (GNU): *note Special Functions::.

‘_FloatNx j1fNx (_FloatNx X)’

     ‘math.h’ (GNU): *note Special Functions::.

‘long double j1l (long double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘jmp_buf’

     ‘setjmp.h’ (ISO): *note Non-Local Details::.

‘double jn (int N, double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘float jnf (int N, float X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘_FloatN jnfN (int N, _FloatN X)’

     ‘math.h’ (GNU): *note Special Functions::.

‘_FloatNx jnfNx (int N, _FloatNx X)’

     ‘math.h’ (GNU): *note Special Functions::.

‘long double jnl (int N, long double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘long int jrand48 (unsigned short int XSUBI[3])’

     ‘stdlib.h’ (SVID): *note SVID Random::.

‘int jrand48_r (unsigned short int XSUBI[3], struct drand48_data *BUFFER, long int *RESULT)’

     ‘stdlib.h’ (GNU): *note SVID Random::.

‘int kill (pid_t PID, int SIGNUM)’

     ‘signal.h’ (POSIX.1): *note Signaling Another Process::.

‘int killpg (int PGID, int SIGNUM)’

     ‘signal.h’ (BSD): *note Signaling Another Process::.

‘char * l64a (long int N)’

     ‘stdlib.h’ (XPG): *note Encode Binary Data::.

‘long int labs (long int NUMBER)’

     ‘stdlib.h’ (ISO): *note Absolute Value::.

‘void lcong48 (unsigned short int PARAM[7])’

     ‘stdlib.h’ (SVID): *note SVID Random::.

‘int lcong48_r (unsigned short int PARAM[7], struct drand48_data *BUFFER)’

     ‘stdlib.h’ (GNU): *note SVID Random::.

‘struct lconv’

     ‘locale.h’ (ISO): *note The Lame Way to Locale Data::.

‘double ldexp (double VALUE, int EXPONENT)’

     ‘math.h’ (ISO): *note Normalization Functions::.

‘float ldexpf (float VALUE, int EXPONENT)’

     ‘math.h’ (ISO): *note Normalization Functions::.

‘_FloatN ldexpfN (_FloatN VALUE, int EXPONENT)’

     ‘math.h’ (TS 18661-3:2015): *note Normalization Functions::.

‘_FloatNx ldexpfNx (_FloatNx VALUE, int EXPONENT)’

     ‘math.h’ (TS 18661-3:2015): *note Normalization Functions::.

‘long double ldexpl (long double VALUE, int EXPONENT)’

     ‘math.h’ (ISO): *note Normalization Functions::.

‘ldiv_t ldiv (long int NUMERATOR, long int DENOMINATOR)’

     ‘stdlib.h’ (ISO): *note Integer Division::.

‘ldiv_t’

     ‘stdlib.h’ (ISO): *note Integer Division::.

‘void * lfind (const void *KEY, const void *BASE, size_t *NMEMB, size_t SIZE, comparison_fn_t COMPAR)’

     ‘search.h’ (SVID): *note Array Search Function::.

‘double lgamma (double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘double lgamma_r (double X, int *SIGNP)’

     ‘math.h’ (XPG): *note Special Functions::.

‘float lgammaf (float X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘_FloatN lgammafN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Special Functions::.

‘_FloatN lgammafN_r (_FloatN X, int *SIGNP)’

     ‘math.h’ (GNU): *note Special Functions::.

‘_FloatNx lgammafNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Special Functions::.

‘_FloatNx lgammafNx_r (_FloatNx X, int *SIGNP)’

     ‘math.h’ (GNU): *note Special Functions::.

‘float lgammaf_r (float X, int *SIGNP)’

     ‘math.h’ (XPG): *note Special Functions::.

‘long double lgammal (long double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘long double lgammal_r (long double X, int *SIGNP)’

     ‘math.h’ (XPG): *note Special Functions::.

‘struct linger’

     ‘sys/socket.h’ (BSD): *note Socket-Level Options::.

‘int link (const char *OLDNAME, const char *NEWNAME)’

     ‘unistd.h’ (POSIX.1): *note Hard Links::.

‘int linkat (int oldfd, const char *OLDNAME, int newfd, const char *NEWNAME, int flags)’

     ‘unistd.h’ (POSIX.1): *note Hard Links::.

‘int lio_listio (int MODE, struct aiocb *const LIST[], int NENT, struct sigevent *SIG)’

     ‘aio.h’ (POSIX.1b): *note Asynchronous Reads/Writes::.

‘int lio_listio64 (int MODE, struct aiocb64 *const LIST[], int NENT, struct sigevent *SIG)’

     ‘aio.h’ (Unix98): *note Asynchronous Reads/Writes::.

‘int listen (int SOCKET, int N)’

     ‘sys/socket.h’ (BSD): *note Listening::.

‘long long int llabs (long long int NUMBER)’

     ‘stdlib.h’ (ISO): *note Absolute Value::.

‘lldiv_t lldiv (long long int NUMERATOR, long long int DENOMINATOR)’

     ‘stdlib.h’ (ISO): *note Integer Division::.

‘lldiv_t’

     ‘stdlib.h’ (ISO): *note Integer Division::.

‘long int llogb (double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘long int llogbf (float X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘long int llogbfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long int llogbfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long int llogbl (long double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘long long int llrint (double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘long long int llrintf (float X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘long long int llrintfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long long int llrintfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long long int llrintl (long double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘long long int llround (double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘long long int llroundf (float X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘long long int llroundfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long long int llroundfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long long int llroundl (long double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘struct lconv * localeconv (void)’

     ‘locale.h’ (ISO): *note The Lame Way to Locale Data::.

‘struct tm * localtime (const time_t *TIME)’

     ‘time.h’ (ISO): *note Broken-down Time::.

‘struct tm * localtime_r (const time_t *TIME, struct tm *RESULTP)’

     ‘time.h’ (POSIX.1c): *note Broken-down Time::.

‘double log (double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘double log10 (double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘float log10f (float X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatN log10fN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘_FloatNx log10fNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long double log10l (long double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘double log1p (double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘float log1pf (float X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatN log1pfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘_FloatNx log1pfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long double log1pl (long double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘double log2 (double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘float log2f (float X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatN log2fN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘_FloatNx log2fNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long double log2l (long double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘double logb (double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘float logbf (float X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatN logbfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘_FloatNx logbfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long double logbl (long double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘float logf (float X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatN logfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘_FloatNx logfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘void login (const struct utmp *ENTRY)’

     ‘utmp.h’ (BSD): *note Logging In and Out::.

‘int login_tty (int FILEDES)’

     ‘utmp.h’ (BSD): *note Logging In and Out::.

‘long double logl (long double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘int logout (const char *UT_LINE)’

     ‘utmp.h’ (BSD): *note Logging In and Out::.

‘void logwtmp (const char *UT_LINE, const char *UT_NAME, const char *UT_HOST)’

     ‘utmp.h’ (BSD): *note Logging In and Out::.

‘void longjmp (jmp_buf STATE, int VALUE)’

     ‘setjmp.h’ (ISO): *note Non-Local Details::.

‘long int lrand48 (void)’

     ‘stdlib.h’ (SVID): *note SVID Random::.

‘int lrand48_r (struct drand48_data *BUFFER, long int *RESULT)’

     ‘stdlib.h’ (GNU): *note SVID Random::.

‘long int lrint (double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘long int lrintf (float X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘long int lrintfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long int lrintfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long int lrintl (long double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘long int lround (double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘long int lroundf (float X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘long int lroundfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long int lroundfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long int lroundl (long double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘void * lsearch (const void *KEY, void *BASE, size_t *NMEMB, size_t SIZE, comparison_fn_t COMPAR)’

     ‘search.h’ (SVID): *note Array Search Function::.

‘off_t lseek (int FILEDES, off_t OFFSET, int WHENCE)’

     ‘unistd.h’ (POSIX.1): *note File Position Primitive::.

‘off64_t lseek64 (int FILEDES, off64_t OFFSET, int WHENCE)’

     ‘unistd.h’ (Unix98): *note File Position Primitive::.

‘int lstat (const char *FILENAME, struct stat *BUF)’

     ‘sys/stat.h’ (BSD): *note Reading Attributes::.

‘int lstat64 (const char *FILENAME, struct stat64 *BUF)’

     ‘sys/stat.h’ (Unix98): *note Reading Attributes::.

‘int lutimes (const char *FILENAME, const struct timeval TVP[2])’

     ‘sys/time.h’ (BSD): *note File Times::.

‘int madvise (void *ADDR, size_t LENGTH, int ADVICE)’

     ‘sys/mman.h’ (POSIX): *note Memory-mapped I/O::.

‘void makecontext (ucontext_t *UCP, void (*FUNC) (void), int ARGC, …)’

     ‘ucontext.h’ (SVID): *note System V contexts::.

‘struct mallinfo’

     ‘malloc.h’ (GNU): *note Statistics of Malloc::.

‘struct mallinfo mallinfo (void)’

     ‘malloc.h’ (SVID): *note Statistics of Malloc::.

‘void * malloc (size_t SIZE)’

     ‘malloc.h’ (ISO): *note Basic Allocation::.

     ‘stdlib.h’ (ISO): *note Basic Allocation::.

‘int mblen (const char *STRING, size_t SIZE)’

     ‘stdlib.h’ (ISO): *note Non-reentrant Character Conversion::.

‘size_t mbrlen (const char *restrict S, size_t N, mbstate_t *PS)’

     ‘wchar.h’ (ISO): *note Converting a Character::.

‘size_t mbrtowc (wchar_t *restrict PWC, const char *restrict S, size_t N, mbstate_t *restrict PS)’

     ‘wchar.h’ (ISO): *note Converting a Character::.

‘int mbsinit (const mbstate_t *PS)’

     ‘wchar.h’ (ISO): *note Keeping the state::.

‘size_t mbsnrtowcs (wchar_t *restrict DST, const char **restrict SRC, size_t NMC, size_t LEN, mbstate_t *restrict PS)’

     ‘wchar.h’ (GNU): *note Converting Strings::.

‘size_t mbsrtowcs (wchar_t *restrict DST, const char **restrict SRC, size_t LEN, mbstate_t *restrict PS)’

     ‘wchar.h’ (ISO): *note Converting Strings::.

‘mbstate_t’

     ‘wchar.h’ (ISO): *note Keeping the state::.

‘size_t mbstowcs (wchar_t *WSTRING, const char *STRING, size_t SIZE)’

     ‘stdlib.h’ (ISO): *note Non-reentrant String Conversion::.

‘int mbtowc (wchar_t *restrict RESULT, const char *restrict STRING, size_t SIZE)’

     ‘stdlib.h’ (ISO): *note Non-reentrant Character Conversion::.

‘int mcheck (void (*ABORTFN) (enum mcheck_status STATUS))’

     ‘mcheck.h’ (GNU): *note Heap Consistency Checking::.

‘void * memalign (size_t BOUNDARY, size_t SIZE)’

     ‘malloc.h’ (BSD): *note Aligned Memory Blocks::.

‘void * memccpy (void *restrict TO, const void *restrict FROM, int C, size_t SIZE)’

     ‘string.h’ (SVID): *note Copying Strings and Arrays::.

‘void * memchr (const void *BLOCK, int C, size_t SIZE)’

     ‘string.h’ (ISO): *note Search Functions::.

‘int memcmp (const void *A1, const void *A2, size_t SIZE)’

     ‘string.h’ (ISO): *note String/Array Comparison::.

‘void * memcpy (void *restrict TO, const void *restrict FROM, size_t SIZE)’

     ‘string.h’ (ISO): *note Copying Strings and Arrays::.

‘int memfd_create (const char *NAME, unsigned int FLAGS)’

     ‘sys/mman.h’ (Linux): *note Memory-mapped I/O::.

‘void * memfrob (void *MEM, size_t LENGTH)’

     ‘string.h’ (GNU): *note Obfuscating Data::.

‘void * memmem (const void *HAYSTACK, size_t HAYSTACK-LEN,
const void *NEEDLE, size_t NEEDLE-LEN)’

     ‘string.h’ (GNU): *note Search Functions::.

‘void * memmove (void *TO, const void *FROM, size_t SIZE)’

     ‘string.h’ (ISO): *note Copying Strings and Arrays::.

‘void * mempcpy (void *restrict TO, const void *restrict FROM, size_t SIZE)’

     ‘string.h’ (GNU): *note Copying Strings and Arrays::.

‘void * memrchr (const void *BLOCK, int C, size_t SIZE)’

     ‘string.h’ (GNU): *note Search Functions::.

‘void * memset (void *BLOCK, int C, size_t SIZE)’

     ‘string.h’ (ISO): *note Copying Strings and Arrays::.

‘int mkdir (const char *FILENAME, mode_t MODE)’

     ‘sys/stat.h’ (POSIX.1): *note Creating Directories::.

‘char * mkdtemp (char *TEMPLATE)’

     ‘stdlib.h’ (BSD): *note Temporary Files::.

‘int mkfifo (const char *FILENAME, mode_t MODE)’

     ‘sys/stat.h’ (POSIX.1): *note FIFO Special Files::.

‘int mknod (const char *FILENAME, mode_t MODE, dev_t DEV)’

     ‘sys/stat.h’ (BSD): *note Making Special Files::.

‘int mkstemp (char *TEMPLATE)’

     ‘stdlib.h’ (BSD): *note Temporary Files::.

‘char * mktemp (char *TEMPLATE)’

     ‘stdlib.h’ (Unix): *note Temporary Files::.

‘time_t mktime (struct tm *BROKENTIME)’

     ‘time.h’ (ISO): *note Broken-down Time::.

‘int mlock (const void *ADDR, size_t LEN)’

     ‘sys/mman.h’ (POSIX.1b): *note Page Lock Functions::.

‘int mlock2 (const void *ADDR, size_t LEN, unsigned int FLAGS)’

     ‘sys/mman.h’ (Linux): *note Page Lock Functions::.

‘int mlockall (int FLAGS)’

     ‘sys/mman.h’ (POSIX.1b): *note Page Lock Functions::.

‘void * mmap (void *ADDRESS, size_t LENGTH, int PROTECT, int FLAGS, int FILEDES, off_t OFFSET)’

     ‘sys/mman.h’ (POSIX): *note Memory-mapped I/O::.

‘void * mmap64 (void *ADDRESS, size_t LENGTH, int PROTECT, int FLAGS, int FILEDES, off64_t OFFSET)’

     ‘sys/mman.h’ (LFS): *note Memory-mapped I/O::.

‘struct mntent’

     ‘mntent.h’ (BSD): *note mtab::.

‘mode_t’

     ‘sys/types.h’ (POSIX.1): *note Attribute Meanings::.

‘double modf (double VALUE, double *INTEGER-PART)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘float modff (float VALUE, float *INTEGER-PART)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘_FloatN modffN (_FloatN VALUE, _FloatN *INTEGER-PART)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘_FloatNx modffNx (_FloatNx VALUE, _FloatNx *INTEGER-PART)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long double modfl (long double VALUE, long double *INTEGER-PART)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘int mount (const char *SPECIAL_FILE, const char *DIR, const char *FSTYPE, unsigned long int OPTIONS, const void *DATA)’

     ‘sys/mount.h’ (SVID): *note Mount-Unmount-Remount::.

     ‘sys/mount.h’ (BSD): *note Mount-Unmount-Remount::.

‘int mprotect (void *ADDRESS, size_t LENGTH, int PROTECTION)’

     ‘sys/mman.h’ (POSIX): *note Memory Protection::.

‘long int mrand48 (void)’

     ‘stdlib.h’ (SVID): *note SVID Random::.

‘int mrand48_r (struct drand48_data *BUFFER, long int *RESULT)’

     ‘stdlib.h’ (GNU): *note SVID Random::.

‘void * mremap (void *ADDRESS, size_t LENGTH, size_t NEW_LENGTH, int FLAG)’

     ‘sys/mman.h’ (GNU): *note Memory-mapped I/O::.

‘int msync (void *ADDRESS, size_t LENGTH, int FLAGS)’

     ‘sys/mman.h’ (POSIX): *note Memory-mapped I/O::.

‘void mtrace (void)’

     ‘mcheck.h’ (GNU): *note Tracing malloc::.

‘void mtx_destroy (mtx_t *MUTEX)’

     ‘threads.h’ (C11): *note ISO C Mutexes::.

‘int mtx_init (mtx_t *MUTEX, int TYPE)’

     ‘threads.h’ (C11): *note ISO C Mutexes::.

‘int mtx_lock (mtx_t *MUTEX)’

     ‘threads.h’ (C11): *note ISO C Mutexes::.

‘mtx_plain’

     ‘threads.h’ (C11): *note ISO C Mutexes::.

‘mtx_recursive’

     ‘threads.h’ (C11): *note ISO C Mutexes::.

‘mtx_t’

     ‘threads.h’ (C11): *note ISO C Mutexes::.

‘mtx_timed’

     ‘threads.h’ (C11): *note ISO C Mutexes::.

‘int mtx_timedlock (mtx_t *restrict MUTEX, const struct timespec *restrict TIME_POINT)’

     ‘threads.h’ (C11): *note ISO C Mutexes::.

‘int mtx_trylock (mtx_t *MUTEX)’

     ‘threads.h’ (C11): *note ISO C Mutexes::.

‘int mtx_unlock (mtx_t *MUTEX)’

     ‘threads.h’ (C11): *note ISO C Mutexes::.

‘int munlock (const void *ADDR, size_t LEN)’

     ‘sys/mman.h’ (POSIX.1b): *note Page Lock Functions::.

‘int munlockall (void)’

     ‘sys/mman.h’ (POSIX.1b): *note Page Lock Functions::.

‘int munmap (void *ADDR, size_t LENGTH)’

     ‘sys/mman.h’ (POSIX): *note Memory-mapped I/O::.

‘void muntrace (void)’

     ‘mcheck.h’ (GNU): *note Tracing malloc::.

‘double nan (const char *TAGP)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘float nanf (const char *TAGP)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘_FloatN nanfN (const char *TAGP)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘_FloatNx nanfNx (const char *TAGP)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘long double nanl (const char *TAGP)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘int nanosleep (const struct timespec *REQUESTED_TIME, struct timespec *REMAINING)’

     ‘time.h’ (POSIX.1): *note Sleeping::.

‘double nearbyint (double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘float nearbyintf (float X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘_FloatN nearbyintfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘_FloatNx nearbyintfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long double nearbyintl (long double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘struct netent’

     ‘netdb.h’ (BSD): *note Networks Database::.

‘double nextafter (double X, double Y)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘float nextafterf (float X, float Y)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘_FloatN nextafterfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘_FloatNx nextafterfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘long double nextafterl (long double X, long double Y)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘double nextdown (double X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘float nextdownf (float X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘_FloatN nextdownfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘_FloatNx nextdownfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘long double nextdownl (long double X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘double nexttoward (double X, long double Y)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘float nexttowardf (float X, long double Y)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘long double nexttowardl (long double X, long double Y)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘double nextup (double X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘float nextupf (float X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘_FloatN nextupfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘_FloatNx nextupfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘long double nextupl (long double X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘int nftw (const char *FILENAME, __nftw_func_t FUNC, int DESCRIPTORS, int FLAG)’

     ‘ftw.h’ (XPG4.2): *note Working with Directory Trees::.

‘int nftw64 (const char *FILENAME, __nftw64_func_t FUNC, int DESCRIPTORS, int FLAG)’

     ‘ftw.h’ (Unix98): *note Working with Directory Trees::.

‘char * ngettext (const char *MSGID1, const char *MSGID2, unsigned long int N)’

     ‘libintl.h’ (GNU): *note Advanced gettext functions::.

‘int nice (int INCREMENT)’

     ‘unistd.h’ (BSD): *note Traditional Scheduling Functions::.

‘char * nl_langinfo (nl_item ITEM)’

     ‘langinfo.h’ (XOPEN): *note The Elegant and Fast Way::.

‘nlink_t’

     ‘sys/types.h’ (POSIX.1): *note Attribute Meanings::.

‘long int nrand48 (unsigned short int XSUBI[3])’

     ‘stdlib.h’ (SVID): *note SVID Random::.

‘int nrand48_r (unsigned short int XSUBI[3], struct drand48_data *BUFFER, long int *RESULT)’

     ‘stdlib.h’ (GNU): *note SVID Random::.

‘uint32_t ntohl (uint32_t NETLONG)’

     ‘netinet/in.h’ (BSD): *note Byte Order::.

‘uint16_t ntohs (uint16_t NETSHORT)’

     ‘netinet/in.h’ (BSD): *note Byte Order::.

‘int ntp_adjtime (struct timex *TPTR)’

     ‘sys/timex.h’ (GNU): *note High Accuracy Clock::.

‘int ntp_gettime (struct ntptimeval *TPTR)’

     ‘sys/timex.h’ (GNU): *note High Accuracy Clock::.

‘struct obstack’

     ‘obstack.h’ (GNU): *note Creating Obstacks::.

‘void obstack_1grow (struct obstack *OBSTACK-PTR, char C)’

     ‘obstack.h’ (GNU): *note Growing Objects::.

‘void obstack_1grow_fast (struct obstack *OBSTACK-PTR, char C)’

     ‘obstack.h’ (GNU): *note Extra Fast Growing::.

‘int obstack_alignment_mask (struct obstack *OBSTACK-PTR)’

     ‘obstack.h’ (GNU): *note Obstacks Data Alignment::.

‘void * obstack_alloc (struct obstack *OBSTACK-PTR, int SIZE)’

     ‘obstack.h’ (GNU): *note Allocation in an Obstack::.

‘obstack_alloc_failed_handler’

     ‘obstack.h’ (GNU): *note Preparing for Obstacks::.

‘void * obstack_base (struct obstack *OBSTACK-PTR)’

     ‘obstack.h’ (GNU): *note Status of an Obstack::.

‘void obstack_blank (struct obstack *OBSTACK-PTR, int SIZE)’

     ‘obstack.h’ (GNU): *note Growing Objects::.

‘void obstack_blank_fast (struct obstack *OBSTACK-PTR, int SIZE)’

     ‘obstack.h’ (GNU): *note Extra Fast Growing::.

‘int obstack_chunk_size (struct obstack *OBSTACK-PTR)’

     ‘obstack.h’ (GNU): *note Obstack Chunks::.

‘void * obstack_copy (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)’

     ‘obstack.h’ (GNU): *note Allocation in an Obstack::.

‘void * obstack_copy0 (struct obstack *OBSTACK-PTR, void *ADDRESS, int SIZE)’

     ‘obstack.h’ (GNU): *note Allocation in an Obstack::.

‘void * obstack_finish (struct obstack *OBSTACK-PTR)’

     ‘obstack.h’ (GNU): *note Growing Objects::.

‘void obstack_free (struct obstack *OBSTACK-PTR, void *OBJECT)’

     ‘obstack.h’ (GNU): *note Freeing Obstack Objects::.

‘void obstack_grow (struct obstack *OBSTACK-PTR, void *DATA, int SIZE)’

     ‘obstack.h’ (GNU): *note Growing Objects::.

‘void obstack_grow0 (struct obstack *OBSTACK-PTR, void *DATA, int SIZE)’

     ‘obstack.h’ (GNU): *note Growing Objects::.

‘int obstack_init (struct obstack *OBSTACK-PTR)’

     ‘obstack.h’ (GNU): *note Preparing for Obstacks::.

‘void obstack_int_grow (struct obstack *OBSTACK-PTR, int DATA)’

     ‘obstack.h’ (GNU): *note Growing Objects::.

‘void obstack_int_grow_fast (struct obstack *OBSTACK-PTR, int DATA)’

     ‘obstack.h’ (GNU): *note Extra Fast Growing::.

‘void * obstack_next_free (struct obstack *OBSTACK-PTR)’

     ‘obstack.h’ (GNU): *note Status of an Obstack::.

‘int obstack_object_size (struct obstack *OBSTACK-PTR)’

     ‘obstack.h’ (GNU): *note Growing Objects::.

     ‘obstack.h’ (GNU): *note Status of an Obstack::.

‘int obstack_printf (struct obstack *OBSTACK, const char *TEMPLATE, …)’

     ‘stdio.h’ (GNU): *note Dynamic Output::.

‘void obstack_ptr_grow (struct obstack *OBSTACK-PTR, void *DATA)’

     ‘obstack.h’ (GNU): *note Growing Objects::.

‘void obstack_ptr_grow_fast (struct obstack *OBSTACK-PTR, void *DATA)’

     ‘obstack.h’ (GNU): *note Extra Fast Growing::.

‘int obstack_room (struct obstack *OBSTACK-PTR)’

     ‘obstack.h’ (GNU): *note Extra Fast Growing::.

‘int obstack_vprintf (struct obstack *OBSTACK, const char *TEMPLATE, va_list AP)’

     ‘stdio.h’ (GNU): *note Variable Arguments Output::.

‘off64_t’

     ‘sys/types.h’ (Unix98): *note File Position Primitive::.

‘off_t’

     ‘sys/types.h’ (POSIX.1): *note File Position Primitive::.

‘size_t offsetof (TYPE, MEMBER)’

     ‘stddef.h’ (ISO): *note Structure Measurement::.

‘int on_exit (void (*FUNCTION)(int STATUS, void *ARG), void *ARG)’

     ‘stdlib.h’ (SunOS): *note Cleanups on Exit::.

‘once_flag’

     ‘threads.h’ (C11): *note Call Once::.

‘int open (const char *FILENAME, int FLAGS[, mode_t MODE])’

     ‘fcntl.h’ (POSIX.1): *note Opening and Closing Files::.

‘int open64 (const char *FILENAME, int FLAGS[, mode_t MODE])’

     ‘fcntl.h’ (Unix98): *note Opening and Closing Files::.

‘FILE * open_memstream (char **PTR, size_t *SIZELOC)’

     ‘stdio.h’ (GNU): *note String Streams::.

‘DIR * opendir (const char *DIRNAME)’

     ‘dirent.h’ (POSIX.1): *note Opening a Directory::.

‘void openlog (const char *IDENT, int OPTION, int FACILITY)’

     ‘syslog.h’ (BSD): *note openlog::.

‘int openpty (int *AMASTER, int *ASLAVE, char *NAME, const struct termios *TERMP, const struct winsize *WINP)’

     ‘pty.h’ (BSD): *note Pseudo-Terminal Pairs::.

‘char * optarg’

     ‘unistd.h’ (POSIX.2): *note Using Getopt::.

‘int opterr’

     ‘unistd.h’ (POSIX.2): *note Using Getopt::.

‘int optind’

     ‘unistd.h’ (POSIX.2): *note Using Getopt::.

‘struct option’

     ‘getopt.h’ (GNU): *note Getopt Long Options::.

‘int optopt’

     ‘unistd.h’ (POSIX.2): *note Using Getopt::.

‘size_t parse_printf_format (const char *TEMPLATE, size_t N, int *ARGTYPES)’

     ‘printf.h’ (GNU): *note Parsing a Template String::.

‘struct passwd’

     ‘pwd.h’ (POSIX.1): *note User Data Structure::.

‘long int pathconf (const char *FILENAME, int PARAMETER)’

     ‘unistd.h’ (POSIX.1): *note Pathconf::.

‘int pause (void)’

     ‘unistd.h’ (POSIX.1): *note Using Pause::.

‘int pclose (FILE *STREAM)’

     ‘stdio.h’ (POSIX.2): *note Pipe to a Subprocess::.

     ‘stdio.h’ (SVID): *note Pipe to a Subprocess::.

     ‘stdio.h’ (BSD): *note Pipe to a Subprocess::.

‘void perror (const char *MESSAGE)’

     ‘stdio.h’ (ISO): *note Error Messages::.

‘pid_t’

     ‘sys/types.h’ (POSIX.1): *note Process Identification::.

‘int pipe (int FILEDES[2])’

     ‘unistd.h’ (POSIX.1): *note Creating a Pipe::.

‘int pkey_alloc (unsigned int FLAGS, unsigned int RESTRICTIONS)’

     ‘sys/mman.h’ (Linux): *note Memory Protection::.

‘int pkey_free (int KEY)’

     ‘sys/mman.h’ (Linux): *note Memory Protection::.

‘int pkey_get (int KEY)’

     ‘sys/mman.h’ (Linux): *note Memory Protection::.

‘int pkey_mprotect (void *ADDRESS, size_t LENGTH, int PROTECTION, int KEY)’

     ‘sys/mman.h’ (Linux): *note Memory Protection::.

‘int pkey_set (int KEY, unsigned int RIGHTS)’

     ‘sys/mman.h’ (Linux): *note Memory Protection::.

‘FILE * popen (const char *COMMAND, const char *MODE)’

     ‘stdio.h’ (POSIX.2): *note Pipe to a Subprocess::.

     ‘stdio.h’ (SVID): *note Pipe to a Subprocess::.

     ‘stdio.h’ (BSD): *note Pipe to a Subprocess::.

‘int posix_memalign (void **MEMPTR, size_t ALIGNMENT, size_t SIZE)’

     ‘stdlib.h’ (POSIX): *note Aligned Memory Blocks::.

‘double pow (double BASE, double POWER)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘float powf (float BASE, float POWER)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatN powfN (_FloatN BASE, _FloatN POWER)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘_FloatNx powfNx (_FloatNx BASE, _FloatNx POWER)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long double powl (long double BASE, long double POWER)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘ssize_t pread (int FILEDES, void *BUFFER, size_t SIZE, off_t OFFSET)’

     ‘unistd.h’ (Unix98): *note I/O Primitives::.

‘ssize_t pread64 (int FILEDES, void *BUFFER, size_t SIZE, off64_t OFFSET)’

     ‘unistd.h’ (Unix98): *note I/O Primitives::.

‘ssize_t preadv (int FD, const struct iovec *IOV, int IOVCNT, off_t OFFSET)’

     ‘sys/uio.h’ (BSD): *note Scatter-Gather::.

‘ssize_t preadv2 (int FD, const struct iovec *IOV, int IOVCNT, off_t OFFSET, int FLAGS)’

     ‘sys/uio.h’ (GNU): *note Scatter-Gather::.

‘ssize_t preadv64 (int FD, const struct iovec *IOV, int IOVCNT, off64_t OFFSET)’

     ‘unistd.h’ (BSD): *note Scatter-Gather::.

‘ssize_t preadv64v2 (int FD, const struct iovec *IOV, int IOVCNT, off64_t OFFSET, int FLAGS)’

     ‘unistd.h’ (GNU): *note Scatter-Gather::.

‘int printf (const char *TEMPLATE, …)’

     ‘stdio.h’ (ISO): *note Formatted Output Functions::.

‘printf_arginfo_function’

     ‘printf.h’ (GNU): *note Defining the Output Handler::.

‘printf_function’

     ‘printf.h’ (GNU): *note Defining the Output Handler::.

‘struct printf_info’

     ‘printf.h’ (GNU): *note Conversion Specifier Options::.

‘int printf_size (FILE *FP, const struct printf_info *INFO, const void *const *ARGS)’

     ‘printf.h’ (GNU): *note Predefined Printf Handlers::.

‘int printf_size_info (const struct printf_info *INFO, size_t N, int *ARGTYPES)’

     ‘printf.h’ (GNU): *note Predefined Printf Handlers::.

‘char * program_invocation_name’

     ‘errno.h’ (GNU): *note Error Messages::.

‘char * program_invocation_short_name’

     ‘errno.h’ (GNU): *note Error Messages::.

‘struct protoent’

     ‘netdb.h’ (BSD): *note Protocols Database::.

‘void psignal (int SIGNUM, const char *MESSAGE)’

     ‘signal.h’ (BSD): *note Signal Messages::.

‘int pthread_getattr_default_np (pthread_attr_t *ATTR)’

     ‘pthread.h’ (GNU): *note Default Thread Attributes::.

‘void *pthread_getspecific (pthread_key_t KEY)’

     ‘pthread.h’ (POSIX): *note Thread-specific Data::.

‘int pthread_key_create (pthread_key_t *KEY, void (*DESTRUCTOR)(void*))’

     ‘pthread.h’ (POSIX): *note Thread-specific Data::.

‘int pthread_key_delete (pthread_key_t KEY)’

     ‘pthread.h’ (POSIX): *note Thread-specific Data::.

‘int pthread_setattr_default_np (pthread_attr_t *ATTR)’

     ‘pthread.h’ (GNU): *note Default Thread Attributes::.

‘int pthread_setspecific (pthread_key_t KEY, const void *VALUE)’

     ‘pthread.h’ (POSIX): *note Thread-specific Data::.

‘ptrdiff_t’

     ‘stddef.h’ (ISO): *note Important Data Types::.

‘char * ptsname (int FILEDES)’

     ‘stdlib.h’ (SVID): *note Allocation::.

     ‘stdlib.h’ (XPG4.2): *note Allocation::.

‘int ptsname_r (int FILEDES, char *BUF, size_t LEN)’

     ‘stdlib.h’ (GNU): *note Allocation::.

‘int putc (int C, FILE *STREAM)’

     ‘stdio.h’ (ISO): *note Simple Output::.

‘int putc_unlocked (int C, FILE *STREAM)’

     ‘stdio.h’ (POSIX): *note Simple Output::.

‘int putchar (int C)’

     ‘stdio.h’ (ISO): *note Simple Output::.

‘int putchar_unlocked (int C)’

     ‘stdio.h’ (POSIX): *note Simple Output::.

‘int putenv (char *STRING)’

     ‘stdlib.h’ (SVID): *note Environment Access::.

‘int putpwent (const struct passwd *P, FILE *STREAM)’

     ‘pwd.h’ (SVID): *note Writing a User Entry::.

‘int puts (const char *S)’

     ‘stdio.h’ (ISO): *note Simple Output::.

‘struct utmp * pututline (const struct utmp *UTMP)’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

‘struct utmpx * pututxline (const struct utmpx *UTMP)’

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘int putw (int W, FILE *STREAM)’

     ‘stdio.h’ (SVID): *note Simple Output::.

‘wint_t putwc (wchar_t WC, FILE *STREAM)’

     ‘wchar.h’ (ISO): *note Simple Output::.

‘wint_t putwc_unlocked (wchar_t WC, FILE *STREAM)’

     ‘wchar.h’ (GNU): *note Simple Output::.

‘wint_t putwchar (wchar_t WC)’

     ‘wchar.h’ (ISO): *note Simple Output::.

‘wint_t putwchar_unlocked (wchar_t WC)’

     ‘wchar.h’ (GNU): *note Simple Output::.

‘ssize_t pwrite (int FILEDES, const void *BUFFER, size_t SIZE, off_t OFFSET)’

     ‘unistd.h’ (Unix98): *note I/O Primitives::.

‘ssize_t pwrite64 (int FILEDES, const void *BUFFER, size_t SIZE, off64_t OFFSET)’

     ‘unistd.h’ (Unix98): *note I/O Primitives::.

‘ssize_t pwritev (int FD, const struct iovec *IOV, int IOVCNT, off_t OFFSET)’

     ‘sys/uio.h’ (BSD): *note Scatter-Gather::.

‘ssize_t pwritev2 (int FD, const struct iovec *IOV, int IOVCNT, off_t OFFSET, int FLAGS)’

     ‘sys/uio.h’ (GNU): *note Scatter-Gather::.

‘ssize_t pwritev64 (int FD, const struct iovec *IOV, int IOVCNT, off64_t OFFSET)’

     ‘unistd.h’ (BSD): *note Scatter-Gather::.

‘ssize_t pwritev64v2 (int FD, const struct iovec *IOV, int IOVCNT, off64_t OFFSET, int FLAGS)’

     ‘unistd.h’ (GNU): *note Scatter-Gather::.

‘char * qecvt (long double VALUE, int NDIGIT, int *DECPT, int *NEG)’

     ‘stdlib.h’ (GNU): *note System V Number Conversion::.

‘int qecvt_r (long double VALUE, int NDIGIT, int *DECPT, int *NEG, char *BUF, size_t LEN)’

     ‘stdlib.h’ (GNU): *note System V Number Conversion::.

‘char * qfcvt (long double VALUE, int NDIGIT, int *DECPT, int *NEG)’

     ‘stdlib.h’ (GNU): *note System V Number Conversion::.

‘int qfcvt_r (long double VALUE, int NDIGIT, int *DECPT, int *NEG, char *BUF, size_t LEN)’

     ‘stdlib.h’ (GNU): *note System V Number Conversion::.

‘char * qgcvt (long double VALUE, int NDIGIT, char *BUF)’

     ‘stdlib.h’ (GNU): *note System V Number Conversion::.

‘void qsort (void *ARRAY, size_t COUNT, size_t SIZE, comparison_fn_t COMPARE)’

     ‘stdlib.h’ (ISO): *note Array Sort Function::.

‘int raise (int SIGNUM)’

     ‘signal.h’ (ISO): *note Signaling Yourself::.

‘int rand (void)’

     ‘stdlib.h’ (ISO): *note ISO Random::.

‘int rand_r (unsigned int *SEED)’

     ‘stdlib.h’ (POSIX.1): *note ISO Random::.

‘long int random (void)’

     ‘stdlib.h’ (BSD): *note BSD Random::.

‘struct random_data’

     ‘stdlib.h’ (GNU): *note BSD Random::.

‘int random_r (struct random_data *restrict BUF, int32_t *restrict RESULT)’

     ‘stdlib.h’ (GNU): *note BSD Random::.

‘void * rawmemchr (const void *BLOCK, int C)’

     ‘string.h’ (GNU): *note Search Functions::.

‘ssize_t read (int FILEDES, void *BUFFER, size_t SIZE)’

     ‘unistd.h’ (POSIX.1): *note I/O Primitives::.

‘struct dirent * readdir (DIR *DIRSTREAM)’

     ‘dirent.h’ (POSIX.1): *note Reading/Closing Directory::.

‘struct dirent64 * readdir64 (DIR *DIRSTREAM)’

     ‘dirent.h’ (LFS): *note Reading/Closing Directory::.

‘int readdir64_r (DIR *DIRSTREAM, struct dirent64 *ENTRY, struct dirent64 **RESULT)’

     ‘dirent.h’ (LFS): *note Reading/Closing Directory::.

‘int readdir_r (DIR *DIRSTREAM, struct dirent *ENTRY, struct dirent **RESULT)’

     ‘dirent.h’ (GNU): *note Reading/Closing Directory::.

‘ssize_t readlink (const char *FILENAME, char *BUFFER, size_t SIZE)’

     ‘unistd.h’ (BSD): *note Symbolic Links::.

‘ssize_t readv (int FILEDES, const struct iovec *VECTOR, int COUNT)’

     ‘sys/uio.h’ (BSD): *note Scatter-Gather::.

‘void * realloc (void *PTR, size_t NEWSIZE)’

     ‘malloc.h’ (ISO): *note Changing Block Size::.

     ‘stdlib.h’ (ISO): *note Changing Block Size::.

‘void * reallocarray (void *PTR, size_t NMEMB, size_t SIZE)’

     ‘malloc.h’ (BSD): *note Changing Block Size::.

     ‘stdlib.h’ (BSD): *note Changing Block Size::.

‘char * realpath (const char *restrict NAME, char *restrict RESOLVED)’

     ‘stdlib.h’ (XPG): *note Symbolic Links::.

‘ssize_t recv (int SOCKET, void *BUFFER, size_t SIZE, int FLAGS)’

     ‘sys/socket.h’ (BSD): *note Receiving Data::.

‘ssize_t recvfrom (int SOCKET, void *BUFFER, size_t SIZE, int FLAGS, struct sockaddr *ADDR, socklen_t *LENGTH-PTR)’

     ‘sys/socket.h’ (BSD): *note Receiving Datagrams::.

‘int regcomp (regex_t *restrict COMPILED, const char *restrict PATTERN, int CFLAGS)’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘size_t regerror (int ERRCODE, const regex_t *restrict COMPILED, char *restrict BUFFER, size_t LENGTH)’

     ‘regex.h’ (POSIX.2): *note Regexp Cleanup::.

‘regex_t’

     ‘regex.h’ (POSIX.2): *note POSIX Regexp Compilation::.

‘int regexec (const regex_t *restrict COMPILED, const char *restrict STRING, size_t NMATCH, regmatch_t MATCHPTR[restrict], int EFLAGS)’

     ‘regex.h’ (POSIX.2): *note Matching POSIX Regexps::.

‘void regfree (regex_t *COMPILED)’

     ‘regex.h’ (POSIX.2): *note Regexp Cleanup::.

‘int register_printf_function (int SPEC, printf_function HANDLER-FUNCTION, printf_arginfo_function ARGINFO-FUNCTION)’

     ‘printf.h’ (GNU): *note Registering New Conversions::.

‘regmatch_t’

     ‘regex.h’ (POSIX.2): *note Regexp Subexpressions::.

‘regoff_t’

     ‘regex.h’ (POSIX.2): *note Regexp Subexpressions::.

‘double remainder (double NUMERATOR, double DENOMINATOR)’

     ‘math.h’ (ISO): *note Remainder Functions::.

‘float remainderf (float NUMERATOR, float DENOMINATOR)’

     ‘math.h’ (ISO): *note Remainder Functions::.

‘_FloatN remainderfN (_FloatN NUMERATOR, _FloatN DENOMINATOR)’

     ‘math.h’ (TS 18661-3:2015): *note Remainder Functions::.

‘_FloatNx remainderfNx (_FloatNx NUMERATOR, _FloatNx DENOMINATOR)’

     ‘math.h’ (TS 18661-3:2015): *note Remainder Functions::.

‘long double remainderl (long double NUMERATOR, long double DENOMINATOR)’

     ‘math.h’ (ISO): *note Remainder Functions::.

‘int remove (const char *FILENAME)’

     ‘stdio.h’ (ISO): *note Deleting Files::.

‘int rename (const char *OLDNAME, const char *NEWNAME)’

     ‘stdio.h’ (ISO): *note Renaming Files::.

‘void rewind (FILE *STREAM)’

     ‘stdio.h’ (ISO): *note File Positioning::.

‘void rewinddir (DIR *DIRSTREAM)’

     ‘dirent.h’ (POSIX.1): *note Random Access Directory::.

‘char * rindex (const char *STRING, int C)’

     ‘string.h’ (BSD): *note Search Functions::.

‘double rint (double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘float rintf (float X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘_FloatN rintfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘_FloatNx rintfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long double rintl (long double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘struct rlimit’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘struct rlimit64’

     ‘sys/resource.h’ (Unix98): *note Limits on Resources::.

‘int rmdir (const char *FILENAME)’

     ‘unistd.h’ (POSIX.1): *note Deleting Files::.

‘double round (double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘double roundeven (double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘float roundevenf (float X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘_FloatN roundevenfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘_FloatNx roundevenfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long double roundevenl (long double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘float roundf (float X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘_FloatN roundfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘_FloatNx roundfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long double roundl (long double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘int rpmatch (const char *RESPONSE)’

     ‘stdlib.h’ (GNU): *note Yes-or-No Questions::.

‘struct rusage’

     ‘sys/resource.h’ (BSD): *note Resource Usage::.

‘void *sbrk (ptrdiff_t DELTA)’

     ‘unistd.h’ (BSD): *note Resizing the Data Segment::.

‘double scalb (double VALUE, double EXPONENT)’

     ‘math.h’ (BSD): *note Normalization Functions::.

‘float scalbf (float VALUE, float EXPONENT)’

     ‘math.h’ (BSD): *note Normalization Functions::.

‘long double scalbl (long double VALUE, long double EXPONENT)’

     ‘math.h’ (BSD): *note Normalization Functions::.

‘double scalbln (double X, long int N)’

     ‘math.h’ (BSD): *note Normalization Functions::.

‘float scalblnf (float X, long int N)’

     ‘math.h’ (BSD): *note Normalization Functions::.

‘_FloatN scalblnfN (_FloatN X, long int N)’

     ‘math.h’ (TS 18661-3:2015): *note Normalization Functions::.

‘_FloatNx scalblnfNx (_FloatNx X, long int N)’

     ‘math.h’ (TS 18661-3:2015): *note Normalization Functions::.

‘long double scalblnl (long double X, long int N)’

     ‘math.h’ (BSD): *note Normalization Functions::.

‘double scalbn (double X, int N)’

     ‘math.h’ (BSD): *note Normalization Functions::.

‘float scalbnf (float X, int N)’

     ‘math.h’ (BSD): *note Normalization Functions::.

‘_FloatN scalbnfN (_FloatN X, int N)’

     ‘math.h’ (TS 18661-3:2015): *note Normalization Functions::.

‘_FloatNx scalbnfNx (_FloatNx X, int N)’

     ‘math.h’ (TS 18661-3:2015): *note Normalization Functions::.

‘long double scalbnl (long double X, int N)’

     ‘math.h’ (BSD): *note Normalization Functions::.

‘int scandir (const char *DIR, struct dirent ***NAMELIST, int (*SELECTOR) (const struct dirent *), int (*CMP) (const struct dirent **, const struct dirent **))’

     ‘dirent.h’ (BSD): *note Scanning Directory Content::.

     ‘dirent.h’ (SVID): *note Scanning Directory Content::.

‘int scandir64 (const char *DIR, struct dirent64 ***NAMELIST, int (*SELECTOR) (const struct dirent64 *), int (*CMP) (const struct dirent64 **, const struct dirent64 **))’

     ‘dirent.h’ (GNU): *note Scanning Directory Content::.

‘int scanf (const char *TEMPLATE, …)’

     ‘stdio.h’ (ISO): *note Formatted Input Functions::.

‘int sched_get_priority_max (int POLICY)’

     ‘sched.h’ (POSIX): *note Basic Scheduling Functions::.

‘int sched_get_priority_min (int POLICY)’

     ‘sched.h’ (POSIX): *note Basic Scheduling Functions::.

‘int sched_getaffinity (pid_t PID, size_t CPUSETSIZE, cpu_set_t *CPUSET)’

     ‘sched.h’ (GNU): *note CPU Affinity::.

‘int sched_getparam (pid_t PID, struct sched_param *PARAM)’

     ‘sched.h’ (POSIX): *note Basic Scheduling Functions::.

‘int sched_getscheduler (pid_t PID)’

     ‘sched.h’ (POSIX): *note Basic Scheduling Functions::.

‘struct sched_param’

     ‘sched.h’ (POSIX): *note Basic Scheduling Functions::.

‘int sched_rr_get_interval (pid_t PID, struct timespec *INTERVAL)’

     ‘sched.h’ (POSIX): *note Basic Scheduling Functions::.

‘int sched_setaffinity (pid_t PID, size_t CPUSETSIZE, const cpu_set_t *CPUSET)’

     ‘sched.h’ (GNU): *note CPU Affinity::.

‘int sched_setparam (pid_t PID, const struct sched_param *PARAM)’

     ‘sched.h’ (POSIX): *note Basic Scheduling Functions::.

‘int sched_setscheduler (pid_t PID, int POLICY, const struct sched_param *PARAM)’

     ‘sched.h’ (POSIX): *note Basic Scheduling Functions::.

‘int sched_yield (void)’

     ‘sched.h’ (POSIX): *note Basic Scheduling Functions::.

‘char * secure_getenv (const char *NAME)’

     ‘stdlib.h’ (GNU): *note Environment Access::.

‘unsigned short int * seed48 (unsigned short int SEED16V[3])’

     ‘stdlib.h’ (SVID): *note SVID Random::.

‘int seed48_r (unsigned short int SEED16V[3], struct drand48_data *BUFFER)’

     ‘stdlib.h’ (GNU): *note SVID Random::.

‘void seekdir (DIR *DIRSTREAM, long int POS)’

     ‘dirent.h’ (BSD): *note Random Access Directory::.

‘int select (int NFDS, fd_set *READ-FDS, fd_set *WRITE-FDS, fd_set *EXCEPT-FDS, struct timeval *TIMEOUT)’

     ‘sys/types.h’ (BSD): *note Waiting for I/O::.

‘ssize_t send (int SOCKET, const void *BUFFER, size_t SIZE, int FLAGS)’

     ‘sys/socket.h’ (BSD): *note Sending Data::.

‘ssize_t sendto (int SOCKET, const void *BUFFER, size_t SIZE, int FLAGS, struct sockaddr *ADDR, socklen_t LENGTH)’

     ‘sys/socket.h’ (BSD): *note Sending Datagrams::.

‘struct servent’

     ‘netdb.h’ (BSD): *note Services Database::.

‘void setbuf (FILE *STREAM, char *BUF)’

     ‘stdio.h’ (ISO): *note Controlling Buffering::.

‘void setbuffer (FILE *STREAM, char *BUF, size_t SIZE)’

     ‘stdio.h’ (BSD): *note Controlling Buffering::.

‘int setcontext (const ucontext_t *UCP)’

     ‘ucontext.h’ (SVID): *note System V contexts::.

‘int setdomainname (const char *NAME, size_t LENGTH)’

     ‘unistd.h’ (???): *note Host Identification::.

‘int setegid (gid_t NEWGID)’

     ‘unistd.h’ (POSIX.1): *note Setting Groups::.

‘int setenv (const char *NAME, const char *VALUE, int REPLACE)’

     ‘stdlib.h’ (BSD): *note Environment Access::.

‘int seteuid (uid_t NEWEUID)’

     ‘unistd.h’ (POSIX.1): *note Setting User ID::.

‘int setfsent (void)’

     ‘fstab.h’ (BSD): *note fstab::.

‘int setgid (gid_t NEWGID)’

     ‘unistd.h’ (POSIX.1): *note Setting Groups::.

‘void setgrent (void)’

     ‘grp.h’ (SVID): *note Scanning All Groups::.

     ‘grp.h’ (BSD): *note Scanning All Groups::.

‘int setgroups (size_t COUNT, const gid_t *GROUPS)’

     ‘grp.h’ (BSD): *note Setting Groups::.

‘void sethostent (int STAYOPEN)’

     ‘netdb.h’ (BSD): *note Host Names::.

‘int sethostid (long int ID)’

     ‘unistd.h’ (BSD): *note Host Identification::.

‘int sethostname (const char *NAME, size_t LENGTH)’

     ‘unistd.h’ (BSD): *note Host Identification::.

‘int setitimer (int WHICH, const struct itimerval *NEW, struct itimerval *OLD)’

     ‘sys/time.h’ (BSD): *note Setting an Alarm::.

‘int setjmp (jmp_buf STATE)’

     ‘setjmp.h’ (ISO): *note Non-Local Details::.

‘void setlinebuf (FILE *STREAM)’

     ‘stdio.h’ (BSD): *note Controlling Buffering::.

‘char * setlocale (int CATEGORY, const char *LOCALE)’

     ‘locale.h’ (ISO): *note Setting the Locale::.

‘int setlogmask (int MASK)’

     ‘syslog.h’ (BSD): *note setlogmask::.

‘FILE * setmntent (const char *FILE, const char *MODE)’

     ‘mntent.h’ (BSD): *note mtab::.

‘void setnetent (int STAYOPEN)’

     ‘netdb.h’ (BSD): *note Networks Database::.

‘int setnetgrent (const char *NETGROUP)’

     ‘netdb.h’ (BSD): *note Lookup Netgroup::.

‘int setpayload (double *X, double PAYLOAD)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘int setpayloadf (float *X, float PAYLOAD)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘int setpayloadfN (_FloatN *X, _FloatN PAYLOAD)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘int setpayloadfNx (_FloatNx *X, _FloatNx PAYLOAD)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘int setpayloadl (long double *X, long double PAYLOAD)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘int setpayloadsig (double *X, double PAYLOAD)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘int setpayloadsigf (float *X, float PAYLOAD)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘int setpayloadsigfN (_FloatN *X, _FloatN PAYLOAD)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘int setpayloadsigfNx (_FloatNx *X, _FloatNx PAYLOAD)’

     ‘math.h’ (TS 18661-3:2015): *note FP Bit Twiddling::.

‘int setpayloadsigl (long double *X, long double PAYLOAD)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘int setpgid (pid_t PID, pid_t PGID)’

     ‘unistd.h’ (POSIX.1): *note Process Group Functions::.

‘int setpgrp (pid_t PID, pid_t PGID)’

     ‘unistd.h’ (BSD): *note Process Group Functions::.

‘int setpriority (int CLASS, int ID, int NICEVAL)’

     ‘sys/resource.h’ (BSD): *note Traditional Scheduling Functions::.

     ‘sys/resource.h’ (POSIX): *note Traditional Scheduling Functions::.

‘void setprotoent (int STAYOPEN)’

     ‘netdb.h’ (BSD): *note Protocols Database::.

‘void setpwent (void)’

     ‘pwd.h’ (SVID): *note Scanning All Users::.

     ‘pwd.h’ (BSD): *note Scanning All Users::.

‘int setregid (gid_t RGID, gid_t EGID)’

     ‘unistd.h’ (BSD): *note Setting Groups::.

‘int setreuid (uid_t RUID, uid_t EUID)’

     ‘unistd.h’ (BSD): *note Setting User ID::.

‘int setrlimit (int RESOURCE, const struct rlimit *RLP)’

     ‘sys/resource.h’ (BSD): *note Limits on Resources::.

‘int setrlimit64 (int RESOURCE, const struct rlimit64 *RLP)’

     ‘sys/resource.h’ (Unix98): *note Limits on Resources::.

‘void setservent (int STAYOPEN)’

     ‘netdb.h’ (BSD): *note Services Database::.

‘pid_t setsid (void)’

     ‘unistd.h’ (POSIX.1): *note Process Group Functions::.

‘int setsockopt (int SOCKET, int LEVEL, int OPTNAME, const void *OPTVAL, socklen_t OPTLEN)’

     ‘sys/socket.h’ (BSD): *note Socket Option Functions::.

‘char * setstate (char *STATE)’

     ‘stdlib.h’ (BSD): *note BSD Random::.

‘int setstate_r (char *restrict STATEBUF, struct random_data *restrict BUF)’

     ‘stdlib.h’ (GNU): *note BSD Random::.

‘int settimeofday (const struct timeval *TP, const struct timezone *TZP)’

     ‘sys/time.h’ (BSD): *note High-Resolution Calendar::.

‘int setuid (uid_t NEWUID)’

     ‘unistd.h’ (POSIX.1): *note Setting User ID::.

‘void setutent (void)’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

‘void setutxent (void)’

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘int setvbuf (FILE *STREAM, char *BUF, int MODE, size_t SIZE)’

     ‘stdio.h’ (ISO): *note Controlling Buffering::.

‘struct sgttyb’

     ‘termios.h’ (BSD): *note BSD Terminal Modes::.

‘int shm_open (const char *NAME, int OFLAG, mode_t MODE)’

     ‘sys/mman.h’ (POSIX): *note Memory-mapped I/O::.

‘int shutdown (int SOCKET, int HOW)’

     ‘sys/socket.h’ (BSD): *note Closing a Socket::.

‘sig_atomic_t’

     ‘signal.h’ (ISO): *note Atomic Types::.

‘int sigaction (int SIGNUM, const struct sigaction *restrict ACTION, struct sigaction *restrict OLD-ACTION)’

     ‘signal.h’ (POSIX.1): *note Advanced Signal Handling::.

‘struct sigaction’

     ‘signal.h’ (POSIX.1): *note Advanced Signal Handling::.

‘int sigaddset (sigset_t *SET, int SIGNUM)’

     ‘signal.h’ (POSIX.1): *note Signal Sets::.

‘int sigaltstack (const stack_t *restrict STACK, stack_t *restrict OLDSTACK)’

     ‘signal.h’ (XPG): *note Signal Stack::.

‘int sigblock (int MASK)’

     ‘signal.h’ (BSD): *note BSD Signal Handling::.

‘int sigdelset (sigset_t *SET, int SIGNUM)’

     ‘signal.h’ (POSIX.1): *note Signal Sets::.

‘int sigemptyset (sigset_t *SET)’

     ‘signal.h’ (POSIX.1): *note Signal Sets::.

‘int sigfillset (sigset_t *SET)’

     ‘signal.h’ (POSIX.1): *note Signal Sets::.

‘sighandler_t’

     ‘signal.h’ (GNU): *note Basic Signal Handling::.

‘int siginterrupt (int SIGNUM, int FAILFLAG)’

     ‘signal.h’ (XPG): *note BSD Signal Handling::.

‘int sigismember (const sigset_t *SET, int SIGNUM)’

     ‘signal.h’ (POSIX.1): *note Signal Sets::.

‘sigjmp_buf’

     ‘setjmp.h’ (POSIX.1): *note Non-Local Exits and Signals::.

‘void siglongjmp (sigjmp_buf STATE, int VALUE)’

     ‘setjmp.h’ (POSIX.1): *note Non-Local Exits and Signals::.

‘int sigmask (int SIGNUM)’

     ‘signal.h’ (BSD): *note BSD Signal Handling::.

‘sighandler_t signal (int SIGNUM, sighandler_t ACTION)’

     ‘signal.h’ (ISO): *note Basic Signal Handling::.

‘int signbit (_float-type_ X)’

     ‘math.h’ (ISO): *note FP Bit Twiddling::.

‘double significand (double X)’

     ‘math.h’ (BSD): *note Normalization Functions::.

‘float significandf (float X)’

     ‘math.h’ (BSD): *note Normalization Functions::.

‘long double significandl (long double X)’

     ‘math.h’ (BSD): *note Normalization Functions::.

‘int sigpause (int MASK)’

     ‘signal.h’ (BSD): *note BSD Signal Handling::.

‘int sigpending (sigset_t *SET)’

     ‘signal.h’ (POSIX.1): *note Checking for Pending Signals::.

‘int sigprocmask (int HOW, const sigset_t *restrict SET, sigset_t *restrict OLDSET)’

     ‘signal.h’ (POSIX.1): *note Process Signal Mask::.

‘sigset_t’

     ‘signal.h’ (POSIX.1): *note Signal Sets::.

‘int sigsetjmp (sigjmp_buf STATE, int SAVESIGS)’

     ‘setjmp.h’ (POSIX.1): *note Non-Local Exits and Signals::.

‘int sigsetmask (int MASK)’

     ‘signal.h’ (BSD): *note BSD Signal Handling::.

‘int sigstack (struct sigstack *STACK, struct sigstack *OLDSTACK)’

     ‘signal.h’ (BSD): *note Signal Stack::.

‘struct sigstack’

     ‘signal.h’ (BSD): *note Signal Stack::.

‘int sigsuspend (const sigset_t *SET)’

     ‘signal.h’ (POSIX.1): *note Sigsuspend::.

‘double sin (double X)’

     ‘math.h’ (ISO): *note Trig Functions::.

‘void sincos (double X, double *SINX, double *COSX)’

     ‘math.h’ (GNU): *note Trig Functions::.

‘void sincosf (float X, float *SINX, float *COSX)’

     ‘math.h’ (GNU): *note Trig Functions::.

‘_FloatN sincosfN (_FloatN X, _FloatN *SINX, _FloatN *COSX)’

     ‘math.h’ (GNU): *note Trig Functions::.

‘_FloatNx sincosfNx (_FloatNx X, _FloatNx *SINX, _FloatNx *COSX)’

     ‘math.h’ (GNU): *note Trig Functions::.

‘void sincosl (long double X, long double *SINX, long double *COSX)’

     ‘math.h’ (GNU): *note Trig Functions::.

‘float sinf (float X)’

     ‘math.h’ (ISO): *note Trig Functions::.

‘_FloatN sinfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Trig Functions::.

‘_FloatNx sinfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Trig Functions::.

‘double sinh (double X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘float sinhf (float X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘_FloatN sinhfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘_FloatNx sinhfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘long double sinhl (long double X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘long double sinl (long double X)’

     ‘math.h’ (ISO): *note Trig Functions::.

‘size_t’

     ‘stddef.h’ (ISO): *note Important Data Types::.

‘unsigned int sleep (unsigned int SECONDS)’

     ‘unistd.h’ (POSIX.1): *note Sleeping::.

‘int snprintf (char *S, size_t SIZE, const char *TEMPLATE, …)’

     ‘stdio.h’ (GNU): *note Formatted Output Functions::.

‘struct sockaddr’

     ‘sys/socket.h’ (BSD): *note Address Formats::.

‘struct sockaddr_in’

     ‘netinet/in.h’ (BSD): *note Internet Address Formats::.

‘struct sockaddr_un’

     ‘sys/un.h’ (BSD): *note Local Namespace Details::.

‘int socket (int NAMESPACE, int STYLE, int PROTOCOL)’

     ‘sys/socket.h’ (BSD): *note Creating a Socket::.

‘int socketpair (int NAMESPACE, int STYLE, int PROTOCOL, int FILEDES[2])’

     ‘sys/socket.h’ (BSD): *note Socket Pairs::.

‘speed_t’

     ‘termios.h’ (POSIX.1): *note Line Speed::.

‘int sprintf (char *S, const char *TEMPLATE, …)’

     ‘stdio.h’ (ISO): *note Formatted Output Functions::.

‘double sqrt (double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘float sqrtf (float X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘_FloatN sqrtfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘_FloatNx sqrtfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Exponents and Logarithms::.

‘long double sqrtl (long double X)’

     ‘math.h’ (ISO): *note Exponents and Logarithms::.

‘void srand (unsigned int SEED)’

     ‘stdlib.h’ (ISO): *note ISO Random::.

‘void srand48 (long int SEEDVAL)’

     ‘stdlib.h’ (SVID): *note SVID Random::.

‘int srand48_r (long int SEEDVAL, struct drand48_data *BUFFER)’

     ‘stdlib.h’ (GNU): *note SVID Random::.

‘void srandom (unsigned int SEED)’

     ‘stdlib.h’ (BSD): *note BSD Random::.

‘int srandom_r (unsigned int SEED, struct random_data *BUF)’

     ‘stdlib.h’ (GNU): *note BSD Random::.

‘int sscanf (const char *S, const char *TEMPLATE, …)’

     ‘stdio.h’ (ISO): *note Formatted Input Functions::.

‘sighandler_t ssignal (int SIGNUM, sighandler_t ACTION)’

     ‘signal.h’ (SVID): *note Basic Signal Handling::.

‘ssize_t’

     ‘unistd.h’ (POSIX.1): *note I/O Primitives::.

‘stack_t’

     ‘signal.h’ (XPG): *note Signal Stack::.

‘int stat (const char *FILENAME, struct stat *BUF)’

     ‘sys/stat.h’ (POSIX.1): *note Reading Attributes::.

‘struct stat’

     ‘sys/stat.h’ (POSIX.1): *note Attribute Meanings::.

‘int stat64 (const char *FILENAME, struct stat64 *BUF)’

     ‘sys/stat.h’ (Unix98): *note Reading Attributes::.

‘struct stat64’

     ‘sys/stat.h’ (LFS): *note Attribute Meanings::.

‘FILE * stderr’

     ‘stdio.h’ (ISO): *note Standard Streams::.

‘FILE * stdin’

     ‘stdio.h’ (ISO): *note Standard Streams::.

‘FILE * stdout’

     ‘stdio.h’ (ISO): *note Standard Streams::.

‘int stime (const time_t *NEWTIME)’

     ‘time.h’ (SVID): *note Simple Calendar Time::.

     ‘time.h’ (XPG): *note Simple Calendar Time::.

‘char * stpcpy (char *restrict TO, const char *restrict FROM)’

     ‘string.h’ (Unknown origin): *note Copying Strings and Arrays::.

‘char * stpncpy (char *restrict TO, const char *restrict FROM, size_t SIZE)’

     ‘string.h’ (GNU): *note Truncating Strings::.

‘int strcasecmp (const char *S1, const char *S2)’

     ‘string.h’ (BSD): *note String/Array Comparison::.

‘char * strcasestr (const char *HAYSTACK, const char *NEEDLE)’

     ‘string.h’ (GNU): *note Search Functions::.

‘char * strcat (char *restrict TO, const char *restrict FROM)’

     ‘string.h’ (ISO): *note Concatenating Strings::.

‘char * strchr (const char *STRING, int C)’

     ‘string.h’ (ISO): *note Search Functions::.

‘char * strchrnul (const char *STRING, int C)’

     ‘string.h’ (GNU): *note Search Functions::.

‘int strcmp (const char *S1, const char *S2)’

     ‘string.h’ (ISO): *note String/Array Comparison::.

‘int strcoll (const char *S1, const char *S2)’

     ‘string.h’ (ISO): *note Collation Functions::.

‘char * strcpy (char *restrict TO, const char *restrict FROM)’

     ‘string.h’ (ISO): *note Copying Strings and Arrays::.

‘size_t strcspn (const char *STRING, const char *STOPSET)’

     ‘string.h’ (ISO): *note Search Functions::.

‘char * strdup (const char *S)’

     ‘string.h’ (SVID): *note Copying Strings and Arrays::.

‘char * strdupa (const char *S)’

     ‘string.h’ (GNU): *note Copying Strings and Arrays::.

‘char * strerror (int ERRNUM)’

     ‘string.h’ (ISO): *note Error Messages::.

‘char * strerror_r (int ERRNUM, char *BUF, size_t N)’

     ‘string.h’ (GNU): *note Error Messages::.

‘int strfromd (char *restrict STRING, size_t SIZE, const char *restrict FORMAT, double VALUE)’

     ‘stdlib.h’ (ISO/IEC TS 18661-1): *note Printing of Floats::.

‘int strfromf (char *restrict STRING, size_t SIZE, const char *restrict FORMAT, float VALUE)’

     ‘stdlib.h’ (ISO/IEC TS 18661-1): *note Printing of Floats::.

‘int strfromfN (char *restrict STRING, size_t SIZE, const char *restrict FORMAT, _FloatN VALUE)’

     ‘stdlib.h’ (ISO/IEC TS 18661-3): *note Printing of Floats::.

‘int strfromfNx (char *restrict STRING, size_t SIZE, const char *restrict FORMAT, _FloatNx VALUE)’

     ‘stdlib.h’ (ISO/IEC TS 18661-3): *note Printing of Floats::.

‘int strfroml (char *restrict STRING, size_t SIZE, const char *restrict FORMAT, long double VALUE)’

     ‘stdlib.h’ (ISO/IEC TS 18661-1): *note Printing of Floats::.

‘char * strfry (char *STRING)’

     ‘string.h’ (GNU): *note Shuffling Bytes::.

‘size_t strftime (char *S, size_t SIZE, const char *TEMPLATE, const struct tm *BROKENTIME)’

     ‘time.h’ (ISO): *note Formatting Calendar Time::.

‘size_t strlen (const char *S)’

     ‘string.h’ (ISO): *note String Length::.

‘int strncasecmp (const char *S1, const char *S2, size_t N)’

     ‘string.h’ (BSD): *note String/Array Comparison::.

‘char * strncat (char *restrict TO, const char *restrict FROM, size_t SIZE)’

     ‘string.h’ (ISO): *note Truncating Strings::.

‘int strncmp (const char *S1, const char *S2, size_t SIZE)’

     ‘string.h’ (ISO): *note String/Array Comparison::.

‘char * strncpy (char *restrict TO, const char *restrict FROM, size_t SIZE)’

     ‘string.h’ (C90): *note Truncating Strings::.

‘char * strndup (const char *S, size_t SIZE)’

     ‘string.h’ (GNU): *note Truncating Strings::.

‘char * strndupa (const char *S, size_t SIZE)’

     ‘string.h’ (GNU): *note Truncating Strings::.

‘size_t strnlen (const char *S, size_t MAXLEN)’

     ‘string.h’ (GNU): *note String Length::.

‘char * strpbrk (const char *STRING, const char *STOPSET)’

     ‘string.h’ (ISO): *note Search Functions::.

‘char * strptime (const char *S, const char *FMT, struct tm *TP)’

     ‘time.h’ (XPG4): *note Low-Level Time String Parsing::.

‘char * strrchr (const char *STRING, int C)’

     ‘string.h’ (ISO): *note Search Functions::.

‘char * strsep (char **STRING_PTR, const char *DELIMITER)’

     ‘string.h’ (BSD): *note Finding Tokens in a String::.

‘char * strsignal (int SIGNUM)’

     ‘string.h’ (GNU): *note Signal Messages::.

‘size_t strspn (const char *STRING, const char *SKIPSET)’

     ‘string.h’ (ISO): *note Search Functions::.

‘char * strstr (const char *HAYSTACK, const char *NEEDLE)’

     ‘string.h’ (ISO): *note Search Functions::.

‘double strtod (const char *restrict STRING, char **restrict TAILPTR)’

     ‘stdlib.h’ (ISO): *note Parsing of Floats::.

‘float strtof (const char *STRING, char **TAILPTR)’

     ‘stdlib.h’ (ISO): *note Parsing of Floats::.

‘_FloatN strtofN (const char *STRING, char **TAILPTR)’

     ‘stdlib.h’ (ISO/IEC TS 18661-3): *note Parsing of Floats::.

‘_FloatNx strtofNx (const char *STRING, char **TAILPTR)’

     ‘stdlib.h’ (ISO/IEC TS 18661-3): *note Parsing of Floats::.

‘intmax_t strtoimax (const char *restrict STRING, char **restrict TAILPTR, int BASE)’

     ‘inttypes.h’ (ISO): *note Parsing of Integers::.

‘char * strtok (char *restrict NEWSTRING, const char *restrict DELIMITERS)’

     ‘string.h’ (ISO): *note Finding Tokens in a String::.

‘char * strtok_r (char *NEWSTRING, const char *DELIMITERS, char **SAVE_PTR)’

     ‘string.h’ (POSIX): *note Finding Tokens in a String::.

‘long int strtol (const char *restrict STRING, char **restrict TAILPTR, int BASE)’

     ‘stdlib.h’ (ISO): *note Parsing of Integers::.

‘long double strtold (const char *STRING, char **TAILPTR)’

     ‘stdlib.h’ (ISO): *note Parsing of Floats::.

‘long long int strtoll (const char *restrict STRING, char **restrict TAILPTR, int BASE)’

     ‘stdlib.h’ (ISO): *note Parsing of Integers::.

‘long long int strtoq (const char *restrict STRING, char **restrict TAILPTR, int BASE)’

     ‘stdlib.h’ (BSD): *note Parsing of Integers::.

‘unsigned long int strtoul (const char *restrict STRING, char **restrict TAILPTR, int BASE)’

     ‘stdlib.h’ (ISO): *note Parsing of Integers::.

‘unsigned long long int strtoull (const char *restrict STRING, char **restrict TAILPTR, int BASE)’

     ‘stdlib.h’ (ISO): *note Parsing of Integers::.

‘uintmax_t strtoumax (const char *restrict STRING, char **restrict TAILPTR, int BASE)’

     ‘inttypes.h’ (ISO): *note Parsing of Integers::.

‘unsigned long long int strtouq (const char *restrict STRING, char **restrict TAILPTR, int BASE)’

     ‘stdlib.h’ (BSD): *note Parsing of Integers::.

‘int strverscmp (const char *S1, const char *S2)’

     ‘string.h’ (GNU): *note String/Array Comparison::.

‘size_t strxfrm (char *restrict TO, const char *restrict FROM, size_t SIZE)’

     ‘string.h’ (ISO): *note Collation Functions::.

‘int stty (int FILEDES, const struct sgttyb *ATTRIBUTES)’

     ‘sgtty.h’ (BSD): *note BSD Terminal Modes::.

‘int swapcontext (ucontext_t *restrict OUCP, const ucontext_t *restrict UCP)’

     ‘ucontext.h’ (SVID): *note System V contexts::.

‘int swprintf (wchar_t *WS, size_t SIZE, const wchar_t *TEMPLATE, …)’

     ‘wchar.h’ (GNU): *note Formatted Output Functions::.

‘int swscanf (const wchar_t *WS, const wchar_t *TEMPLATE, …)’

     ‘wchar.h’ (ISO): *note Formatted Input Functions::.

‘int symlink (const char *OLDNAME, const char *NEWNAME)’

     ‘unistd.h’ (BSD): *note Symbolic Links::.

‘void sync (void)’

     ‘unistd.h’ (X/Open): *note Synchronizing I/O::.

‘long int syscall (long int SYSNO, …)’

     ‘unistd.h’ (???): *note System Calls::.

‘long int sysconf (int PARAMETER)’

     ‘unistd.h’ (POSIX.1): *note Sysconf Definition::.

‘int sysctl (int *NAMES, int NLEN, void *OLDVAL, size_t *OLDLENP, void *NEWVAL, size_t NEWLEN)’

     ‘sys/sysctl.h’ (BSD): *note System Parameters::.

‘void syslog (int FACILITY_PRIORITY, const char *FORMAT, …)’

     ‘syslog.h’ (BSD): *note syslog; vsyslog::.

‘int system (const char *COMMAND)’

     ‘stdlib.h’ (ISO): *note Running a Command::.

‘sighandler_t sysv_signal (int SIGNUM, sighandler_t ACTION)’

     ‘signal.h’ (GNU): *note Basic Signal Handling::.

‘double tan (double X)’

     ‘math.h’ (ISO): *note Trig Functions::.

‘float tanf (float X)’

     ‘math.h’ (ISO): *note Trig Functions::.

‘_FloatN tanfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Trig Functions::.

‘_FloatNx tanfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Trig Functions::.

‘double tanh (double X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘float tanhf (float X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘_FloatN tanhfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘_FloatNx tanhfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Hyperbolic Functions::.

‘long double tanhl (long double X)’

     ‘math.h’ (ISO): *note Hyperbolic Functions::.

‘long double tanl (long double X)’

     ‘math.h’ (ISO): *note Trig Functions::.

‘int tcdrain (int FILEDES)’

     ‘termios.h’ (POSIX.1): *note Line Control::.

‘tcflag_t’

     ‘termios.h’ (POSIX.1): *note Mode Data Types::.

‘int tcflow (int FILEDES, int ACTION)’

     ‘termios.h’ (POSIX.1): *note Line Control::.

‘int tcflush (int FILEDES, int QUEUE)’

     ‘termios.h’ (POSIX.1): *note Line Control::.

‘int tcgetattr (int FILEDES, struct termios *TERMIOS-P)’

     ‘termios.h’ (POSIX.1): *note Mode Functions::.

‘pid_t tcgetpgrp (int FILEDES)’

     ‘unistd.h’ (POSIX.1): *note Terminal Access Functions::.

‘pid_t tcgetsid (int FILDES)’

     ‘termios.h’ (Unix98): *note Terminal Access Functions::.

‘int tcsendbreak (int FILEDES, int DURATION)’

     ‘termios.h’ (POSIX.1): *note Line Control::.

‘int tcsetattr (int FILEDES, int WHEN, const struct termios *TERMIOS-P)’

     ‘termios.h’ (POSIX.1): *note Mode Functions::.

‘int tcsetpgrp (int FILEDES, pid_t PGID)’

     ‘unistd.h’ (POSIX.1): *note Terminal Access Functions::.

‘void * tdelete (const void *KEY, void **ROOTP, comparison_fn_t COMPAR)’

     ‘search.h’ (SVID): *note Tree Search Function::.

‘void tdestroy (void *VROOT, __free_fn_t FREEFCT)’

     ‘search.h’ (GNU): *note Tree Search Function::.

‘long int telldir (DIR *DIRSTREAM)’

     ‘dirent.h’ (BSD): *note Random Access Directory::.

‘char * tempnam (const char *DIR, const char *PREFIX)’

     ‘stdio.h’ (SVID): *note Temporary Files::.

‘struct termios’

     ‘termios.h’ (POSIX.1): *note Mode Data Types::.

‘char * textdomain (const char *DOMAINNAME)’

     ‘libintl.h’ (GNU): *note Locating gettext catalog::.

‘void * tfind (const void *KEY, void *const *ROOTP, comparison_fn_t COMPAR)’

     ‘search.h’ (SVID): *note Tree Search Function::.

‘double tgamma (double X)’

     ‘math.h’ (XPG): *note Special Functions::.

     ‘math.h’ (ISO): *note Special Functions::.

‘float tgammaf (float X)’

     ‘math.h’ (XPG): *note Special Functions::.

     ‘math.h’ (ISO): *note Special Functions::.

‘_FloatN tgammafN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Special Functions::.

‘_FloatNx tgammafNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Special Functions::.

‘long double tgammal (long double X)’

     ‘math.h’ (XPG): *note Special Functions::.

     ‘math.h’ (ISO): *note Special Functions::.

‘int tgkill (pid_t PID, pid_t TID, int SIGNUM)’

     ‘signal.h’ (Linux): *note Signaling Another Process::.

‘thrd_busy’

     ‘threads.h’ (C11): *note ISO C Threads Return Values::.

‘int thrd_create (thrd_t *THR, thrd_start_t FUNC, void *ARG)’

     ‘threads.h’ (C11): *note ISO C Thread Management::.

‘thrd_t thrd_current (void)’

     ‘threads.h’ (C11): *note ISO C Thread Management::.

‘int thrd_detach (thrd_t THR)’

     ‘threads.h’ (C11): *note ISO C Thread Management::.

‘int thrd_equal (thrd_t LHS, thrd_t RHS)’

     ‘threads.h’ (C11): *note ISO C Thread Management::.

‘thrd_error’

     ‘threads.h’ (C11): *note ISO C Threads Return Values::.

‘_Noreturn void thrd_exit (int RES)’

     ‘threads.h’ (C11): *note ISO C Thread Management::.

‘int thrd_join (thrd_t THR, int *RES)’

     ‘threads.h’ (C11): *note ISO C Thread Management::.

‘thrd_nomem’

     ‘threads.h’ (C11): *note ISO C Threads Return Values::.

‘int thrd_sleep (const struct timespec *TIME_POINT, struct timespec *REMAINING)’

     ‘threads.h’ (C11): *note ISO C Thread Management::.

‘thrd_start_t’

     ‘threads.h’ (C11): *note ISO C Thread Management::.

‘thrd_success’

     ‘threads.h’ (C11): *note ISO C Threads Return Values::.

‘thrd_t’

     ‘threads.h’ (C11): *note ISO C Thread Management::.

‘thrd_timedout’

     ‘threads.h’ (C11): *note ISO C Threads Return Values::.

‘void thrd_yield (void)’

     ‘threads.h’ (C11): *note ISO C Thread Management::.

‘thread_local’

     ‘threads.h’ (C11): *note ISO C Thread-local Storage::.

‘time_t time (time_t *RESULT)’

     ‘time.h’ (ISO): *note Simple Calendar Time::.

‘time_t’

     ‘time.h’ (ISO): *note Simple Calendar Time::.

‘time_t timegm (struct tm *BROKENTIME)’

     ‘time.h’ (???): *note Broken-down Time::.

‘time_t timelocal (struct tm *BROKENTIME)’

     ‘time.h’ (???): *note Broken-down Time::.

‘clock_t times (struct tms *BUFFER)’

     ‘sys/times.h’ (POSIX.1): *note Processor Time::.

‘struct timespec’

     ‘sys/time.h’ (POSIX.1): *note Elapsed Time::.

‘struct timeval’

     ‘sys/time.h’ (BSD): *note Elapsed Time::.

‘long int timezone’

     ‘time.h’ (SVID): *note Time Zone Functions::.

‘struct timezone’

     ‘sys/time.h’ (BSD): *note High-Resolution Calendar::.

‘struct tm’

     ‘time.h’ (ISO): *note Broken-down Time::.

‘FILE * tmpfile (void)’

     ‘stdio.h’ (ISO): *note Temporary Files::.

‘FILE * tmpfile64 (void)’

     ‘stdio.h’ (Unix98): *note Temporary Files::.

‘char * tmpnam (char *RESULT)’

     ‘stdio.h’ (ISO): *note Temporary Files::.

‘char * tmpnam_r (char *RESULT)’

     ‘stdio.h’ (GNU): *note Temporary Files::.

‘struct tms’

     ‘sys/times.h’ (POSIX.1): *note Processor Time::.

‘int toascii (int C)’

     ‘ctype.h’ (SVID): *note Case Conversion::.

     ‘ctype.h’ (BSD): *note Case Conversion::.

‘int tolower (int C)’

     ‘ctype.h’ (ISO): *note Case Conversion::.

‘int totalorder (double X, double Y)’

     ‘math.h’ (TS 18661-1:2014): *note FP Comparison Functions::.

‘int totalorderf (float X, float Y)’

     ‘math.h’ (TS 18661-1:2014): *note FP Comparison Functions::.

‘int totalorderfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note FP Comparison Functions::.

‘int totalorderfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note FP Comparison Functions::.

‘int totalorderl (long double X, long double Y)’

     ‘math.h’ (TS 18661-1:2014): *note FP Comparison Functions::.

‘int totalordermag (double X, double Y)’

     ‘math.h’ (TS 18661-1:2014): *note FP Comparison Functions::.

‘int totalordermagf (float X, float Y)’

     ‘math.h’ (TS 18661-1:2014): *note FP Comparison Functions::.

‘int totalordermagfN (_FloatN X, _FloatN Y)’

     ‘math.h’ (TS 18661-3:2015): *note FP Comparison Functions::.

‘int totalordermagfNx (_FloatNx X, _FloatNx Y)’

     ‘math.h’ (TS 18661-3:2015): *note FP Comparison Functions::.

‘int totalordermagl (long double X, long double Y)’

     ‘math.h’ (TS 18661-1:2014): *note FP Comparison Functions::.

‘int toupper (int C)’

     ‘ctype.h’ (ISO): *note Case Conversion::.

‘wint_t towctrans (wint_t WC, wctrans_t DESC)’

     ‘wctype.h’ (ISO): *note Wide Character Case Conversion::.

‘wint_t towlower (wint_t WC)’

     ‘wctype.h’ (ISO): *note Wide Character Case Conversion::.

‘wint_t towupper (wint_t WC)’

     ‘wctype.h’ (ISO): *note Wide Character Case Conversion::.

‘double trunc (double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘int truncate (const char *FILENAME, off_t LENGTH)’

     ‘unistd.h’ (X/Open): *note File Size::.

‘int truncate64 (const char *NAME, off64_t LENGTH)’

     ‘unistd.h’ (Unix98): *note File Size::.

‘float truncf (float X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘_FloatN truncfN (_FloatN X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘_FloatNx truncfNx (_FloatNx X)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘long double truncl (long double X)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘void * tsearch (const void *KEY, void **ROOTP, comparison_fn_t COMPAR)’

     ‘search.h’ (SVID): *note Tree Search Function::.

‘int tss_create (tss_t *TSS_KEY, tss_dtor_t DESTRUCTOR)’

     ‘threads.h’ (C11): *note ISO C Thread-local Storage::.

‘void tss_delete (tss_t TSS_KEY)’

     ‘threads.h’ (C11): *note ISO C Thread-local Storage::.

‘tss_dtor_t’

     ‘threads.h’ (C11): *note ISO C Thread-local Storage::.

‘void * tss_get (tss_t TSS_KEY)’

     ‘threads.h’ (C11): *note ISO C Thread-local Storage::.

‘int tss_set (tss_t TSS_KEY, void *VAL)’

     ‘threads.h’ (C11): *note ISO C Thread-local Storage::.

‘tss_t’

     ‘threads.h’ (C11): *note ISO C Thread-local Storage::.

‘char * ttyname (int FILEDES)’

     ‘unistd.h’ (POSIX.1): *note Is It a Terminal::.

‘int ttyname_r (int FILEDES, char *BUF, size_t LEN)’

     ‘unistd.h’ (POSIX.1): *note Is It a Terminal::.

‘void twalk (const void *ROOT, __action_fn_t ACTION)’

     ‘search.h’ (SVID): *note Tree Search Function::.

‘void twalk_r (const void *ROOT, void (*ACTION) (const void *KEY, VISIT WHICH, void *CLOSURE), void *CLOSURE)’

     ‘search.h’ (GNU): *note Tree Search Function::.

‘char * tzname [2]’

     ‘time.h’ (POSIX.1): *note Time Zone Functions::.

‘void tzset (void)’

     ‘time.h’ (POSIX.1): *note Time Zone Functions::.

‘ucontext_t’

     ‘ucontext.h’ (SVID): *note System V contexts::.

‘uintmax_t ufromfp (double X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘uintmax_t ufromfpf (float X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘uintmax_t ufromfpfN (_FloatN X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘uintmax_t ufromfpfNx (_FloatNx X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘uintmax_t ufromfpl (long double X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘uintmax_t ufromfpx (double X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘uintmax_t ufromfpxf (float X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘uintmax_t ufromfpxfN (_FloatN X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘uintmax_t ufromfpxfNx (_FloatNx X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (TS 18661-3:2015): *note Rounding Functions::.

‘uintmax_t ufromfpxl (long double X, int ROUND, unsigned int WIDTH)’

     ‘math.h’ (ISO): *note Rounding Functions::.

‘uid_t’

     ‘sys/types.h’ (POSIX.1): *note Reading Persona::.

‘long int ulimit (int CMD, …)’

     ‘ulimit.h’ (BSD): *note Limits on Resources::.

‘mode_t umask (mode_t MASK)’

     ‘sys/stat.h’ (POSIX.1): *note Setting Permissions::.

‘int umount (const char *FILE)’

     ‘sys/mount.h’ (SVID): *note Mount-Unmount-Remount::.

     ‘sys/mount.h’ (GNU): *note Mount-Unmount-Remount::.

‘int umount2 (const char *FILE, int FLAGS)’

     ‘sys/mount.h’ (GNU): *note Mount-Unmount-Remount::.

‘int uname (struct utsname *INFO)’

     ‘sys/utsname.h’ (POSIX.1): *note Platform Type::.

‘int ungetc (int C, FILE *STREAM)’

     ‘stdio.h’ (ISO): *note How Unread::.

‘wint_t ungetwc (wint_t WC, FILE *STREAM)’

     ‘wchar.h’ (ISO): *note How Unread::.

‘int unlink (const char *FILENAME)’

     ‘unistd.h’ (POSIX.1): *note Deleting Files::.

‘int unlockpt (int FILEDES)’

     ‘stdlib.h’ (SVID): *note Allocation::.

     ‘stdlib.h’ (XPG4.2): *note Allocation::.

‘int unsetenv (const char *NAME)’

     ‘stdlib.h’ (BSD): *note Environment Access::.

‘void updwtmp (const char *WTMP_FILE, const struct utmp *UTMP)’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

‘struct utimbuf’

     ‘utime.h’ (POSIX.1): *note File Times::.

‘int utime (const char *FILENAME, const struct utimbuf *TIMES)’

     ‘utime.h’ (POSIX.1): *note File Times::.

‘int utimes (const char *FILENAME, const struct timeval TVP[2])’

     ‘sys/time.h’ (BSD): *note File Times::.

‘int utmpname (const char *FILE)’

     ‘utmp.h’ (SVID): *note Manipulating the Database::.

‘int utmpxname (const char *FILE)’

     ‘utmpx.h’ (XPG4.2): *note XPG Functions::.

‘struct utsname’

     ‘sys/utsname.h’ (POSIX.1): *note Platform Type::.

‘TYPE va_arg (va_list AP, TYPE)’

     ‘stdarg.h’ (ISO): *note Argument Macros::.

‘void va_copy (va_list DEST, va_list SRC)’

     ‘stdarg.h’ (C99): *note Argument Macros::.

‘void va_end (va_list AP)’

     ‘stdarg.h’ (ISO): *note Argument Macros::.

‘va_list’

     ‘stdarg.h’ (ISO): *note Argument Macros::.

‘void va_start (va_list AP, LAST-REQUIRED)’

     ‘stdarg.h’ (ISO): *note Argument Macros::.

‘void * valloc (size_t SIZE)’

     ‘malloc.h’ (BSD): *note Aligned Memory Blocks::.

     ‘stdlib.h’ (BSD): *note Aligned Memory Blocks::.

‘int vasprintf (char **PTR, const char *TEMPLATE, va_list AP)’

     ‘stdio.h’ (GNU): *note Variable Arguments Output::.

‘void verr (int STATUS, const char *FORMAT, va_list AP)’

     ‘err.h’ (BSD): *note Error Messages::.

‘void verrx (int STATUS, const char *FORMAT, va_list AP)’

     ‘err.h’ (BSD): *note Error Messages::.

‘int versionsort (const struct dirent **A, const struct dirent **B)’

     ‘dirent.h’ (GNU): *note Scanning Directory Content::.

‘int versionsort64 (const struct dirent64 **A, const struct dirent64 **B)’

     ‘dirent.h’ (GNU): *note Scanning Directory Content::.

‘pid_t vfork (void)’

     ‘unistd.h’ (BSD): *note Creating a Process::.

‘int vfprintf (FILE *STREAM, const char *TEMPLATE, va_list AP)’

     ‘stdio.h’ (ISO): *note Variable Arguments Output::.

‘int vfscanf (FILE *STREAM, const char *TEMPLATE, va_list AP)’

     ‘stdio.h’ (ISO): *note Variable Arguments Input::.

‘int vfwprintf (FILE *STREAM, const wchar_t *TEMPLATE, va_list AP)’

     ‘wchar.h’ (ISO): *note Variable Arguments Output::.

‘int vfwscanf (FILE *STREAM, const wchar_t *TEMPLATE, va_list AP)’

     ‘wchar.h’ (ISO): *note Variable Arguments Input::.

‘int vlimit (int RESOURCE, int LIMIT)’

     ‘sys/vlimit.h’ (BSD): *note Limits on Resources::.

‘int vprintf (const char *TEMPLATE, va_list AP)’

     ‘stdio.h’ (ISO): *note Variable Arguments Output::.

‘int vscanf (const char *TEMPLATE, va_list AP)’

     ‘stdio.h’ (ISO): *note Variable Arguments Input::.

‘int vsnprintf (char *S, size_t SIZE, const char *TEMPLATE, va_list AP)’

     ‘stdio.h’ (GNU): *note Variable Arguments Output::.

‘int vsprintf (char *S, const char *TEMPLATE, va_list AP)’

     ‘stdio.h’ (ISO): *note Variable Arguments Output::.

‘int vsscanf (const char *S, const char *TEMPLATE, va_list AP)’

     ‘stdio.h’ (ISO): *note Variable Arguments Input::.

‘int vswprintf (wchar_t *WS, size_t SIZE, const wchar_t *TEMPLATE, va_list AP)’

     ‘wchar.h’ (GNU): *note Variable Arguments Output::.

‘int vswscanf (const wchar_t *S, const wchar_t *TEMPLATE, va_list AP)’

     ‘wchar.h’ (ISO): *note Variable Arguments Input::.

‘void vsyslog (int FACILITY_PRIORITY, const char *FORMAT, va_list ARGLIST)’

     ‘syslog.h’ (BSD): *note syslog; vsyslog::.

‘int vtimes (struct vtimes *CURRENT, struct vtimes *CHILD)’

     ‘sys/vtimes.h’ (???): *note Resource Usage::.

‘void vwarn (const char *FORMAT, va_list AP)’

     ‘err.h’ (BSD): *note Error Messages::.

‘void vwarnx (const char *FORMAT, va_list AP)’

     ‘err.h’ (BSD): *note Error Messages::.

‘int vwprintf (const wchar_t *TEMPLATE, va_list AP)’

     ‘wchar.h’ (ISO): *note Variable Arguments Output::.

‘int vwscanf (const wchar_t *TEMPLATE, va_list AP)’

     ‘wchar.h’ (ISO): *note Variable Arguments Input::.

‘pid_t wait (int *STATUS-PTR)’

     ‘sys/wait.h’ (POSIX.1): *note Process Completion::.

‘pid_t wait3 (int *STATUS-PTR, int OPTIONS, struct rusage *USAGE)’

     ‘sys/wait.h’ (BSD): *note BSD Wait Functions::.

‘pid_t wait4 (pid_t PID, int *STATUS-PTR, int OPTIONS, struct rusage *USAGE)’

     ‘sys/wait.h’ (BSD): *note Process Completion::.

‘pid_t waitpid (pid_t PID, int *STATUS-PTR, int OPTIONS)’

     ‘sys/wait.h’ (POSIX.1): *note Process Completion::.

‘void warn (const char *FORMAT, …)’

     ‘err.h’ (BSD): *note Error Messages::.

‘void warnx (const char *FORMAT, …)’

     ‘err.h’ (BSD): *note Error Messages::.

‘wchar_t’

     ‘stddef.h’ (ISO): *note Extended Char Intro::.

‘wchar_t * wcpcpy (wchar_t *restrict WTO, const wchar_t *restrict WFROM)’

     ‘wchar.h’ (GNU): *note Copying Strings and Arrays::.

‘wchar_t * wcpncpy (wchar_t *restrict WTO, const wchar_t *restrict WFROM, size_t SIZE)’

     ‘wchar.h’ (GNU): *note Truncating Strings::.

‘size_t wcrtomb (char *restrict S, wchar_t WC, mbstate_t *restrict PS)’

     ‘wchar.h’ (ISO): *note Converting a Character::.

‘int wcscasecmp (const wchar_t *WS1, const wchar_t *WS2)’

     ‘wchar.h’ (GNU): *note String/Array Comparison::.

‘wchar_t * wcscat (wchar_t *restrict WTO, const wchar_t *restrict WFROM)’

     ‘wchar.h’ (ISO): *note Concatenating Strings::.

‘wchar_t * wcschr (const wchar_t *WSTRING, int WC)’

     ‘wchar.h’ (ISO): *note Search Functions::.

‘wchar_t * wcschrnul (const wchar_t *WSTRING, wchar_t WC)’

     ‘wchar.h’ (GNU): *note Search Functions::.

‘int wcscmp (const wchar_t *WS1, const wchar_t *WS2)’

     ‘wchar.h’ (ISO): *note String/Array Comparison::.

‘int wcscoll (const wchar_t *WS1, const wchar_t *WS2)’

     ‘wchar.h’ (ISO): *note Collation Functions::.

‘wchar_t * wcscpy (wchar_t *restrict WTO, const wchar_t *restrict WFROM)’

     ‘wchar.h’ (ISO): *note Copying Strings and Arrays::.

‘size_t wcscspn (const wchar_t *WSTRING, const wchar_t *STOPSET)’

     ‘wchar.h’ (ISO): *note Search Functions::.

‘wchar_t * wcsdup (const wchar_t *WS)’

     ‘wchar.h’ (GNU): *note Copying Strings and Arrays::.

‘size_t wcsftime (wchar_t *S, size_t SIZE, const wchar_t *TEMPLATE, const struct tm *BROKENTIME)’

     ‘time.h’ (ISO/Amend1): *note Formatting Calendar Time::.

‘size_t wcslen (const wchar_t *WS)’

     ‘wchar.h’ (ISO): *note String Length::.

‘int wcsncasecmp (const wchar_t *WS1, const wchar_t *S2, size_t N)’

     ‘wchar.h’ (GNU): *note String/Array Comparison::.

‘wchar_t * wcsncat (wchar_t *restrict WTO, const wchar_t *restrict WFROM, size_t SIZE)’

     ‘wchar.h’ (ISO): *note Truncating Strings::.

‘int wcsncmp (const wchar_t *WS1, const wchar_t *WS2, size_t SIZE)’

     ‘wchar.h’ (ISO): *note String/Array Comparison::.

‘wchar_t * wcsncpy (wchar_t *restrict WTO, const wchar_t *restrict WFROM, size_t SIZE)’

     ‘wchar.h’ (ISO): *note Truncating Strings::.

‘size_t wcsnlen (const wchar_t *WS, size_t MAXLEN)’

     ‘wchar.h’ (GNU): *note String Length::.

‘size_t wcsnrtombs (char *restrict DST, const wchar_t **restrict SRC, size_t NWC, size_t LEN, mbstate_t *restrict PS)’

     ‘wchar.h’ (GNU): *note Converting Strings::.

‘wchar_t * wcspbrk (const wchar_t *WSTRING, const wchar_t *STOPSET)’

     ‘wchar.h’ (ISO): *note Search Functions::.

‘wchar_t * wcsrchr (const wchar_t *WSTRING, wchar_t C)’

     ‘wchar.h’ (ISO): *note Search Functions::.

‘size_t wcsrtombs (char *restrict DST, const wchar_t **restrict SRC, size_t LEN, mbstate_t *restrict PS)’

     ‘wchar.h’ (ISO): *note Converting Strings::.

‘size_t wcsspn (const wchar_t *WSTRING, const wchar_t *SKIPSET)’

     ‘wchar.h’ (ISO): *note Search Functions::.

‘wchar_t * wcsstr (const wchar_t *HAYSTACK, const wchar_t *NEEDLE)’

     ‘wchar.h’ (ISO): *note Search Functions::.

‘double wcstod (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR)’

     ‘wchar.h’ (ISO): *note Parsing of Floats::.

‘float wcstof (const wchar_t *STRING, wchar_t **TAILPTR)’

     ‘wchar.h’ (ISO): *note Parsing of Floats::.

‘_FloatN wcstofN (const wchar_t *STRING, wchar_t **TAILPTR)’

     ‘wchar.h’ (GNU): *note Parsing of Floats::.

‘_FloatNx wcstofNx (const wchar_t *STRING, wchar_t **TAILPTR)’

     ‘wchar.h’ (GNU): *note Parsing of Floats::.

‘intmax_t wcstoimax (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)’

     ‘wchar.h’ (ISO): *note Parsing of Integers::.

‘wchar_t * wcstok (wchar_t *NEWSTRING, const wchar_t *DELIMITERS, wchar_t **SAVE_PTR)’

     ‘wchar.h’ (ISO): *note Finding Tokens in a String::.

‘long int wcstol (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)’

     ‘wchar.h’ (ISO): *note Parsing of Integers::.

‘long double wcstold (const wchar_t *STRING, wchar_t **TAILPTR)’

     ‘wchar.h’ (ISO): *note Parsing of Floats::.

‘long long int wcstoll (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)’

     ‘wchar.h’ (ISO): *note Parsing of Integers::.

‘size_t wcstombs (char *STRING, const wchar_t *WSTRING, size_t SIZE)’

     ‘stdlib.h’ (ISO): *note Non-reentrant String Conversion::.

‘long long int wcstoq (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)’

     ‘wchar.h’ (GNU): *note Parsing of Integers::.

‘unsigned long int wcstoul (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)’

     ‘wchar.h’ (ISO): *note Parsing of Integers::.

‘unsigned long long int wcstoull (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)’

     ‘wchar.h’ (ISO): *note Parsing of Integers::.

‘uintmax_t wcstoumax (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)’

     ‘wchar.h’ (ISO): *note Parsing of Integers::.

‘unsigned long long int wcstouq (const wchar_t *restrict STRING, wchar_t **restrict TAILPTR, int BASE)’

     ‘wchar.h’ (GNU): *note Parsing of Integers::.

‘wchar_t * wcswcs (const wchar_t *HAYSTACK, const wchar_t *NEEDLE)’

     ‘wchar.h’ (XPG): *note Search Functions::.

‘size_t wcsxfrm (wchar_t *restrict WTO, const wchar_t *WFROM, size_t SIZE)’

     ‘wchar.h’ (ISO): *note Collation Functions::.

‘int wctob (wint_t C)’

     ‘wchar.h’ (ISO): *note Converting a Character::.

‘int wctomb (char *STRING, wchar_t WCHAR)’

     ‘stdlib.h’ (ISO): *note Non-reentrant Character Conversion::.

‘wctrans_t wctrans (const char *PROPERTY)’

     ‘wctype.h’ (ISO): *note Wide Character Case Conversion::.

‘wctrans_t’

     ‘wctype.h’ (ISO): *note Wide Character Case Conversion::.

‘wctype_t wctype (const char *PROPERTY)’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘wctype_t’

     ‘wctype.h’ (ISO): *note Classification of Wide Characters::.

‘wint_t’

     ‘wchar.h’ (ISO): *note Extended Char Intro::.

‘wchar_t * wmemchr (const wchar_t *BLOCK, wchar_t WC, size_t SIZE)’

     ‘wchar.h’ (ISO): *note Search Functions::.

‘int wmemcmp (const wchar_t *A1, const wchar_t *A2, size_t SIZE)’

     ‘wchar.h’ (ISO): *note String/Array Comparison::.

‘wchar_t * wmemcpy (wchar_t *restrict WTO, const wchar_t *restrict WFROM, size_t SIZE)’

     ‘wchar.h’ (ISO): *note Copying Strings and Arrays::.

‘wchar_t * wmemmove (wchar_t *WTO, const wchar_t *WFROM, size_t SIZE)’

     ‘wchar.h’ (ISO): *note Copying Strings and Arrays::.

‘wchar_t * wmempcpy (wchar_t *restrict WTO, const wchar_t *restrict WFROM, size_t SIZE)’

     ‘wchar.h’ (GNU): *note Copying Strings and Arrays::.

‘wchar_t * wmemset (wchar_t *BLOCK, wchar_t WC, size_t SIZE)’

     ‘wchar.h’ (ISO): *note Copying Strings and Arrays::.

‘int wordexp (const char *WORDS, wordexp_t *WORD-VECTOR-PTR, int FLAGS)’

     ‘wordexp.h’ (POSIX.2): *note Calling Wordexp::.

‘wordexp_t’

     ‘wordexp.h’ (POSIX.2): *note Calling Wordexp::.

‘void wordfree (wordexp_t *WORD-VECTOR-PTR)’

     ‘wordexp.h’ (POSIX.2): *note Calling Wordexp::.

‘int wprintf (const wchar_t *TEMPLATE, …)’

     ‘wchar.h’ (ISO): *note Formatted Output Functions::.

‘ssize_t write (int FILEDES, const void *BUFFER, size_t SIZE)’

     ‘unistd.h’ (POSIX.1): *note I/O Primitives::.

‘ssize_t writev (int FILEDES, const struct iovec *VECTOR, int COUNT)’

     ‘sys/uio.h’ (BSD): *note Scatter-Gather::.

‘int wscanf (const wchar_t *TEMPLATE, …)’

     ‘wchar.h’ (ISO): *note Formatted Input Functions::.

‘double y0 (double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘float y0f (float X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘_FloatN y0fN (_FloatN X)’

     ‘math.h’ (GNU): *note Special Functions::.

‘_FloatNx y0fNx (_FloatNx X)’

     ‘math.h’ (GNU): *note Special Functions::.

‘long double y0l (long double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘double y1 (double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘float y1f (float X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘_FloatN y1fN (_FloatN X)’

     ‘math.h’ (GNU): *note Special Functions::.

‘_FloatNx y1fNx (_FloatNx X)’

     ‘math.h’ (GNU): *note Special Functions::.

‘long double y1l (long double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘double yn (int N, double X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘float ynf (int N, float X)’

     ‘math.h’ (SVID): *note Special Functions::.

‘_FloatN ynfN (int N, _FloatN X)’

     ‘math.h’ (GNU): *note Special Functions::.

‘_FloatNx ynfNx (int N, _FloatNx X)’

     ‘math.h’ (GNU): *note Special Functions::.

‘long double ynl (int N, long double X)’

     ‘math.h’ (SVID): *note Special Functions::.

